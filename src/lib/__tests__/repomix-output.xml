This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
api-config.test.ts
README_ENHANCED.md
xcontroller.client.test.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api-config.test.ts">
/**
 * API Configuration Tests
 * Tests the API URL resolution fallback chain to prevent production errors
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { getApiBaseUrl } from '../api-config';
import { DataController } from '../xcontroller.client';
import logger from './logger';

// Mock the xcontroller module
jest.mock('../xcontroller.client', () => ({
  dataController: {
    loadData: jest.fn(),
  },
}));

describe('API Configuration', () => {
  let mockLoadData: jest.MockedFunction<typeof DataController.prototype.loadData>;
  let originalEnv: any;

  beforeEach(() => {
    // Store original import.meta.env
    originalEnv = { ...import.meta.env };

    // Get mocked loadData
    mockLoadData = (require('../xcontroller.client').dataController.loadData as jest.MockedFunction<typeof DataController.prototype.loadData>);

    // Reset all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Restore original environment
    Object.assign(import.meta.env, originalEnv);
  });

  describe('getApiBaseUrl', () => {
    test('should prioritize VITE_API_URL (for static deployments)', () => {
      // Mock VITE_API_URL environment variable
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      // Mock xcontroller returning server config (should be ignored)
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Should use VITE_API_URL, not xcontroller
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should NOT call loadData when VITE_API_URL is available
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should fall back to server-passed config when VITE_API_URL is unavailable', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning server config
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should fall back to /api for local development when both sources are unavailable', () => {
      // Mock xcontroller returning null
      mockLoadData.mockReturnValue(null);

      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should handle empty string from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data with empty apiUrl
      mockLoadData.mockReturnValue({
        apiUrl: '',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Empty string is falsy, should fall back to /api
      expect(apiUrl).toBe('/api');
    });

    test('should handle undefined apiUrl from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data without apiUrl property
      mockLoadData.mockReturnValue({
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      } as any);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
    });

    test('should use production API URL from environment variable', () => {
      // This test simulates GitHub Pages deployment
      mockLoadData.mockReturnValue(null);
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
    });

    test('should preserve URL format from xcontroller', () => {
      // Test with various URL formats
      const testUrls = [
        'https://api.example.com',
        'https://api.example.com:8080',
        'https://api.example.com/v1',
        'http://localhost:3001',
        '/api',
      ];

      testUrls.forEach(url => {
        mockLoadData.mockReturnValue({
          apiUrl: url,
          environment: 'test',
          features: { search: true, analytics: true, monitoring: true },
          version: '1.0.0',
        });

        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });

    test('should preserve URL format from VITE_API_URL', () => {
      mockLoadData.mockReturnValue(null);

      const testUrls = [
        'https://api.example.com',
        'http://localhost:3001/api',
        '/api',
      ];

      testUrls.forEach(url => {
        (import.meta.env as any).VITE_API_URL = url;
        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });
  });

  describe('Error Prevention', () => {
    test('REGRESSION: should not return relative /api when VITE_API_URL is set', () => {
      // This is the bug that caused the production issue
      // The component was falling back to '/api' instead of using VITE_API_URL

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Must NOT be '/api' when VITE_API_URL is available
      expect(apiUrl).not.toBe('/api');
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not even call loadData when VITE_API_URL is set
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should work in GitHub Pages deployment scenario', () => {
      // Simulates exact production environment:
      // - No xcontroller data (static HTML)
      // - VITE_API_URL set during build

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Should resolve to production API, not relative path
      expect(apiUrl).toBe('https://api.alephatx.info');
      expect(apiUrl).toMatch(/^https:\/\//);
      // Should not call loadData to avoid console errors
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should not log console errors in static builds', () => {
      // This test ensures we don't call loadData when VITE_API_URL is available
      // Previously caused "[DataController] Script tag with id 'initial-data' not found" error

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Verify the xcontroller was never called (preventing logger.error)
      expect(mockLoadData).not.toHaveBeenCalled();
      expect(apiUrl).toBe('https://api.alephatx.info');
    });
  });

  describe('Integration Scenarios', () => {
    test('should work in server-side rendered scenario (no VITE_API_URL)', () => {
      // SSR scenarios don't set VITE_API_URL
      delete (import.meta.env as any).VITE_API_URL;

      mockLoadData.mockReturnValue({
        apiUrl: 'https://ssr-api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://ssr-api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should work in static site scenario (GitHub Pages)', () => {
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not call loadData in static builds
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should work in local development scenario', () => {
      delete (import.meta.env as any).VITE_API_URL;
      mockLoadData.mockReturnValue(null);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });
  });
});
</file>

<file path="README_ENHANCED.md">
# __tests__

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "__tests__",
  "description": "Directory containing 1 code files with 1 classes and 1 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions",
    "1 function definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `xcontroller.client.test.ts` (typescript)

**Classes:**
- `AppConfig` - Line 294

**Functions:**
- `createScript()` - Line 230

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="xcontroller.client.test.ts">
/**
 * XController Client Tests
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { DataController } from '../xcontroller.client';

describe('DataController', () => {
  let controller: DataController;
  let scriptElement: HTMLScriptElement;

  beforeEach(() => {
    controller = new DataController(true); // debug mode
    // Clean up any existing test elements
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  afterEach(() => {
    // Clean up after each test
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  describe('loadData', () => {
    test('should load data from valid JSON script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-data';
      scriptElement.textContent = JSON.stringify({ test: 'value', number: 123 });
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ test: string; number: number }>('test-data');

      expect(data).not.toBeNull();
      expect(data?.test).toBe('value');
      expect(data?.number).toBe(123);
    });

    test('should return null for non-existent script tag', () => {
      const data = controller.loadData('non-existent');
      expect(data).toBeNull();
    });

    test('should return null for wrong type attribute', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'text/javascript';
      scriptElement.id = 'test-wrong-type';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-wrong-type');
      expect(data).toBeNull();
    });

    test('should return null for invalid JSON', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-invalid';
      scriptElement.textContent = 'not valid json {]';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-invalid');
      expect(data).toBeNull();
    });

    test('should cache loaded data', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-cache';
      scriptElement.textContent = JSON.stringify({ cached: true });
      document.body.appendChild(scriptElement);

      const data1 = controller.loadData('test-cache');
      const data2 = controller.loadData('test-cache');

      expect(data1).toBe(data2); // Same reference = cached
      expect(controller.getCacheSize()).toBe(1);
    });

    test('should handle empty script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-empty';
      scriptElement.textContent = '';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-empty');
      expect(data).toBeNull();
    });

    test('should handle null values', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-null';
      scriptElement.textContent = 'null';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-null');
      expect(data).toBeNull(); // null is not valid (fails validation)
    });

    test('should handle arrays', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-array';
      scriptElement.textContent = JSON.stringify([1, 2, 3]);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<number[]>('test-array');
      expect(Array.isArray(data)).toBe(true);
      expect(data).toEqual([1, 2, 3]);
    });

    test('should handle complex nested objects', () => {
      const complexData = {
        user: { id: 1, name: 'John', roles: ['admin', 'user'] },
        config: { theme: 'dark', features: { analytics: true } },
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-complex';
      scriptElement.textContent = JSON.stringify(complexData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof complexData>('test-complex');
      expect(data).toEqual(complexData);
    });

    test('should handle unicode and special characters', () => {
      const unicodeData = {
        text: 'Hello ä¸–ç•Œ',
        emoji: 'ðŸš€',
        escaped: 'Line 1\nLine 2',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-unicode';
      scriptElement.textContent = JSON.stringify(unicodeData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof unicodeData>('test-unicode');
      expect(data).toEqual(unicodeData);
    });
  });

  describe('loadDataWithFallback', () => {
    beforeEach(() => {
      // Mock fetch
      global.fetch = jest.fn();
    });

    test('should use script tag data first', async () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-fallback';
      scriptElement.textContent = JSON.stringify({ source: 'script' });
      document.body.appendChild(scriptElement);

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'test-fallback',
        '/api/fallback'
      );

      expect(data?.source).toBe('script');
      expect(global.fetch).not.toHaveBeenCalled();
    });

    test('should fallback to API when script tag missing', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ source: 'api' }),
      });

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'non-existent',
        '/api/fallback'
      );

      expect(data?.source).toBe('api');
      expect(global.fetch).toHaveBeenCalledWith('/api/fallback');
    });

    test('should cache API fallback data', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ cached: true }),
      });

      await controller.loadDataWithFallback('test-api-cache', '/api/data');
      await controller.loadDataWithFallback('test-api-cache', '/api/data');

      expect(global.fetch).toHaveBeenCalledTimes(1); // Only called once
    });

    test('should return null on API error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const data = await controller.loadDataWithFallback('missing', '/api/error');
      expect(data).toBeNull();
    });

    test('should return null on network error', async () => {
      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const data = await controller.loadDataWithFallback('missing', '/api/network-error');
      expect(data).toBeNull();
    });
  });

  describe('cache management', () => {
    test('should clear cache', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-clear';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      controller.loadData('test-clear');
      expect(controller.getCacheSize()).toBe(1);

      controller.clearCache();
      expect(controller.getCacheSize()).toBe(0);
    });

    test('should report correct cache size', () => {
      const createScript = (id: string) => {
        const script = document.createElement('script');
        script.type = 'application/json';
        script.id = id;
        script.textContent = JSON.stringify({ test: id });
        document.body.appendChild(script);
      };

      createScript('test-1');
      createScript('test-2');
      createScript('test-3');

      controller.loadData('test-1');
      expect(controller.getCacheSize()).toBe(1);

      controller.loadData('test-2');
      expect(controller.getCacheSize()).toBe(2);

      controller.loadData('test-3');
      expect(controller.getCacheSize()).toBe(3);
    });
  });

  describe('XSS Prevention', () => {
    test('should safely parse data with script tags', () => {
      const xssData = {
        payload: '<script>alert("xss")</script>',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-xss';
      scriptElement.textContent = JSON.stringify(xssData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof xssData>('test-xss');

      // Data should be parsed, but not executed
      expect(data?.payload).toBe('<script>alert("xss")</script>');

      // No actual script execution should occur
      const scripts = document.querySelectorAll('script[src*="alert"]');
      expect(scripts.length).toBe(0);
    });

    test('should handle encoded dangerous characters', () => {
      // Data as it would come from server with proper encoding
      const encodedData = '{"html":"\\u003Cscript\\u003Ealert(\\"xss\\")\\u003C/script\\u003E"}';

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-encoded';
      scriptElement.textContent = encodedData;
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ html: string }>('test-encoded');

      // Should decode properly
      expect(data?.html).toBe('<script>alert("xss")</script>');
    });
  });

  describe('Type Safety', () => {
    test('should preserve type information', () => {
      interface AppConfig {
        apiUrl: string;
        features: {
          analytics: boolean;
          search: boolean;
        };
        version: string;
      }

      const config: AppConfig = {
        apiUrl: '/api',
        features: { analytics: true, search: true },
        version: '1.0.0',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-typed';
      scriptElement.textContent = JSON.stringify(config);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<AppConfig>('test-typed');

      expect(data).toBeTruthy();
      expect(data!.apiUrl).toBe('/api');
      expect(data!.features.analytics).toBe(true);
      expect(typeof data!.version).toBe('string');
    });
  });

  describe('Error Handling', () => {
    test('should log errors in debug mode', () => {
      const consoleError = jest.spyOn(console, 'error').mockImplementation();

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-error';
      scriptElement.textContent = 'invalid json';
      document.body.appendChild(scriptElement);

      controller.loadData('test-error');

      expect(consoleError).toHaveBeenCalled();
      consoleError.mockRestore();
    });

    test('should handle missing textContent', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-no-content';
      // No textContent set
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-no-content');
      expect(data).toBeNull();
    });
  });
});
</file>

</files>
