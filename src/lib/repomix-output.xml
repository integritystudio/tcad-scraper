This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  api-config.test.ts
  README_ENHANCED.md
  xcontroller.client.test.ts
analytics.ts
api-config.ts
logger.ts
README_ENHANCED.md
xcontroller.client.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/api-config.test.ts">
/**
 * API Configuration Tests
 * Tests the API URL resolution fallback chain to prevent production errors
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { getApiBaseUrl } from '../api-config';
import { DataController } from '../xcontroller.client';
import logger from './logger';

// Mock the xcontroller module
jest.mock('../xcontroller.client', () => ({
  dataController: {
    loadData: jest.fn(),
  },
}));

describe('API Configuration', () => {
  let mockLoadData: jest.MockedFunction<typeof DataController.prototype.loadData>;
  let originalEnv: any;

  beforeEach(() => {
    // Store original import.meta.env
    originalEnv = { ...import.meta.env };

    // Get mocked loadData
    mockLoadData = (require('../xcontroller.client').dataController.loadData as jest.MockedFunction<typeof DataController.prototype.loadData>);

    // Reset all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Restore original environment
    Object.assign(import.meta.env, originalEnv);
  });

  describe('getApiBaseUrl', () => {
    test('should prioritize VITE_API_URL (for static deployments)', () => {
      // Mock VITE_API_URL environment variable
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      // Mock xcontroller returning server config (should be ignored)
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Should use VITE_API_URL, not xcontroller
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should NOT call loadData when VITE_API_URL is available
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should fall back to server-passed config when VITE_API_URL is unavailable', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning server config
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should fall back to /api for local development when both sources are unavailable', () => {
      // Mock xcontroller returning null
      mockLoadData.mockReturnValue(null);

      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should handle empty string from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data with empty apiUrl
      mockLoadData.mockReturnValue({
        apiUrl: '',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Empty string is falsy, should fall back to /api
      expect(apiUrl).toBe('/api');
    });

    test('should handle undefined apiUrl from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data without apiUrl property
      mockLoadData.mockReturnValue({
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      } as any);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
    });

    test('should use production API URL from environment variable', () => {
      // This test simulates GitHub Pages deployment
      mockLoadData.mockReturnValue(null);
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
    });

    test('should preserve URL format from xcontroller', () => {
      // Test with various URL formats
      const testUrls = [
        'https://api.example.com',
        'https://api.example.com:8080',
        'https://api.example.com/v1',
        'http://localhost:3001',
        '/api',
      ];

      testUrls.forEach(url => {
        mockLoadData.mockReturnValue({
          apiUrl: url,
          environment: 'test',
          features: { search: true, analytics: true, monitoring: true },
          version: '1.0.0',
        });

        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });

    test('should preserve URL format from VITE_API_URL', () => {
      mockLoadData.mockReturnValue(null);

      const testUrls = [
        'https://api.example.com',
        'http://localhost:3001/api',
        '/api',
      ];

      testUrls.forEach(url => {
        (import.meta.env as any).VITE_API_URL = url;
        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });
  });

  describe('Error Prevention', () => {
    test('REGRESSION: should not return relative /api when VITE_API_URL is set', () => {
      // This is the bug that caused the production issue
      // The component was falling back to '/api' instead of using VITE_API_URL

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Must NOT be '/api' when VITE_API_URL is available
      expect(apiUrl).not.toBe('/api');
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not even call loadData when VITE_API_URL is set
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should work in GitHub Pages deployment scenario', () => {
      // Simulates exact production environment:
      // - No xcontroller data (static HTML)
      // - VITE_API_URL set during build

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Should resolve to production API, not relative path
      expect(apiUrl).toBe('https://api.alephatx.info');
      expect(apiUrl).toMatch(/^https:\/\//);
      // Should not call loadData to avoid console errors
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should not log console errors in static builds', () => {
      // This test ensures we don't call loadData when VITE_API_URL is available
      // Previously caused "[DataController] Script tag with id 'initial-data' not found" error

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Verify the xcontroller was never called (preventing logger.error)
      expect(mockLoadData).not.toHaveBeenCalled();
      expect(apiUrl).toBe('https://api.alephatx.info');
    });
  });

  describe('Integration Scenarios', () => {
    test('should work in server-side rendered scenario (no VITE_API_URL)', () => {
      // SSR scenarios don't set VITE_API_URL
      delete (import.meta.env as any).VITE_API_URL;

      mockLoadData.mockReturnValue({
        apiUrl: 'https://ssr-api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://ssr-api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should work in static site scenario (GitHub Pages)', () => {
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not call loadData in static builds
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should work in local development scenario', () => {
      delete (import.meta.env as any).VITE_API_URL;
      mockLoadData.mockReturnValue(null);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });
  });
});
</file>

<file path="__tests__/README_ENHANCED.md">
# __tests__

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "__tests__",
  "description": "Directory containing 1 code files with 1 classes and 1 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions",
    "1 function definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `xcontroller.client.test.ts` (typescript)

**Classes:**
- `AppConfig` - Line 294

**Functions:**
- `createScript()` - Line 230

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="__tests__/xcontroller.client.test.ts">
/**
 * XController Client Tests
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { DataController } from '../xcontroller.client';

describe('DataController', () => {
  let controller: DataController;
  let scriptElement: HTMLScriptElement;

  beforeEach(() => {
    controller = new DataController(true); // debug mode
    // Clean up any existing test elements
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  afterEach(() => {
    // Clean up after each test
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  describe('loadData', () => {
    test('should load data from valid JSON script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-data';
      scriptElement.textContent = JSON.stringify({ test: 'value', number: 123 });
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ test: string; number: number }>('test-data');

      expect(data).not.toBeNull();
      expect(data?.test).toBe('value');
      expect(data?.number).toBe(123);
    });

    test('should return null for non-existent script tag', () => {
      const data = controller.loadData('non-existent');
      expect(data).toBeNull();
    });

    test('should return null for wrong type attribute', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'text/javascript';
      scriptElement.id = 'test-wrong-type';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-wrong-type');
      expect(data).toBeNull();
    });

    test('should return null for invalid JSON', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-invalid';
      scriptElement.textContent = 'not valid json {]';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-invalid');
      expect(data).toBeNull();
    });

    test('should cache loaded data', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-cache';
      scriptElement.textContent = JSON.stringify({ cached: true });
      document.body.appendChild(scriptElement);

      const data1 = controller.loadData('test-cache');
      const data2 = controller.loadData('test-cache');

      expect(data1).toBe(data2); // Same reference = cached
      expect(controller.getCacheSize()).toBe(1);
    });

    test('should handle empty script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-empty';
      scriptElement.textContent = '';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-empty');
      expect(data).toBeNull();
    });

    test('should handle null values', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-null';
      scriptElement.textContent = 'null';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-null');
      expect(data).toBeNull(); // null is not valid (fails validation)
    });

    test('should handle arrays', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-array';
      scriptElement.textContent = JSON.stringify([1, 2, 3]);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<number[]>('test-array');
      expect(Array.isArray(data)).toBe(true);
      expect(data).toEqual([1, 2, 3]);
    });

    test('should handle complex nested objects', () => {
      const complexData = {
        user: { id: 1, name: 'John', roles: ['admin', 'user'] },
        config: { theme: 'dark', features: { analytics: true } },
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-complex';
      scriptElement.textContent = JSON.stringify(complexData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof complexData>('test-complex');
      expect(data).toEqual(complexData);
    });

    test('should handle unicode and special characters', () => {
      const unicodeData = {
        text: 'Hello ä¸–ç•Œ',
        emoji: 'ðŸš€',
        escaped: 'Line 1\nLine 2',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-unicode';
      scriptElement.textContent = JSON.stringify(unicodeData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof unicodeData>('test-unicode');
      expect(data).toEqual(unicodeData);
    });
  });

  describe('loadDataWithFallback', () => {
    beforeEach(() => {
      // Mock fetch
      global.fetch = jest.fn();
    });

    test('should use script tag data first', async () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-fallback';
      scriptElement.textContent = JSON.stringify({ source: 'script' });
      document.body.appendChild(scriptElement);

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'test-fallback',
        '/api/fallback'
      );

      expect(data?.source).toBe('script');
      expect(global.fetch).not.toHaveBeenCalled();
    });

    test('should fallback to API when script tag missing', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ source: 'api' }),
      });

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'non-existent',
        '/api/fallback'
      );

      expect(data?.source).toBe('api');
      expect(global.fetch).toHaveBeenCalledWith('/api/fallback');
    });

    test('should cache API fallback data', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ cached: true }),
      });

      await controller.loadDataWithFallback('test-api-cache', '/api/data');
      await controller.loadDataWithFallback('test-api-cache', '/api/data');

      expect(global.fetch).toHaveBeenCalledTimes(1); // Only called once
    });

    test('should return null on API error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const data = await controller.loadDataWithFallback('missing', '/api/error');
      expect(data).toBeNull();
    });

    test('should return null on network error', async () => {
      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const data = await controller.loadDataWithFallback('missing', '/api/network-error');
      expect(data).toBeNull();
    });
  });

  describe('cache management', () => {
    test('should clear cache', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-clear';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      controller.loadData('test-clear');
      expect(controller.getCacheSize()).toBe(1);

      controller.clearCache();
      expect(controller.getCacheSize()).toBe(0);
    });

    test('should report correct cache size', () => {
      const createScript = (id: string) => {
        const script = document.createElement('script');
        script.type = 'application/json';
        script.id = id;
        script.textContent = JSON.stringify({ test: id });
        document.body.appendChild(script);
      };

      createScript('test-1');
      createScript('test-2');
      createScript('test-3');

      controller.loadData('test-1');
      expect(controller.getCacheSize()).toBe(1);

      controller.loadData('test-2');
      expect(controller.getCacheSize()).toBe(2);

      controller.loadData('test-3');
      expect(controller.getCacheSize()).toBe(3);
    });
  });

  describe('XSS Prevention', () => {
    test('should safely parse data with script tags', () => {
      const xssData = {
        payload: '<script>alert("xss")</script>',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-xss';
      scriptElement.textContent = JSON.stringify(xssData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof xssData>('test-xss');

      // Data should be parsed, but not executed
      expect(data?.payload).toBe('<script>alert("xss")</script>');

      // No actual script execution should occur
      const scripts = document.querySelectorAll('script[src*="alert"]');
      expect(scripts.length).toBe(0);
    });

    test('should handle encoded dangerous characters', () => {
      // Data as it would come from server with proper encoding
      const encodedData = '{"html":"\\u003Cscript\\u003Ealert(\\"xss\\")\\u003C/script\\u003E"}';

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-encoded';
      scriptElement.textContent = encodedData;
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ html: string }>('test-encoded');

      // Should decode properly
      expect(data?.html).toBe('<script>alert("xss")</script>');
    });
  });

  describe('Type Safety', () => {
    test('should preserve type information', () => {
      interface AppConfig {
        apiUrl: string;
        features: {
          analytics: boolean;
          search: boolean;
        };
        version: string;
      }

      const config: AppConfig = {
        apiUrl: '/api',
        features: { analytics: true, search: true },
        version: '1.0.0',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-typed';
      scriptElement.textContent = JSON.stringify(config);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<AppConfig>('test-typed');

      expect(data).toBeTruthy();
      expect(data!.apiUrl).toBe('/api');
      expect(data!.features.analytics).toBe(true);
      expect(typeof data!.version).toBe('string');
    });
  });

  describe('Error Handling', () => {
    test('should log errors in debug mode', () => {
      const consoleError = jest.spyOn(console, 'error').mockImplementation();

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-error';
      scriptElement.textContent = 'invalid json';
      document.body.appendChild(scriptElement);

      controller.loadData('test-error');

      expect(consoleError).toHaveBeenCalled();
      consoleError.mockRestore();
    });

    test('should handle missing textContent', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-no-content';
      // No textContent set
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-no-content');
      expect(data).toBeNull();
    });
  });
});
</file>

<file path="analytics.ts">
/**
 * Analytics utility functions for tracking user events
 * Integrates with Google Analytics and Meta Pixel
 */

// Extend the Window interface to include tracking functions
declare global {
  interface Window {
    gtag?: (...args: any[]) => void;
    fbq?: (...args: any[]) => void;
    dataLayer?: any[];
  }
}

export type EventCategory =
  | 'search'
  | 'navigation'
  | 'engagement'
  | 'conversion';

export interface AnalyticsEvent {
  category: EventCategory;
  action: string;
  label?: string;
  value?: number;
  metadata?: Record<string, any>;
}

/**
 * Track a custom event to both GA and Meta Pixel
 */
export const trackEvent = (event: AnalyticsEvent): void => {
  const { category, action, label, value, metadata } = event;

  // Google Analytics 4 event
  if (window.gtag) {
    window.gtag('event', action, {
      event_category: category,
      event_label: label,
      value: value,
      ...metadata,
    });
  }

  // Meta Pixel custom event
  if (window.fbq) {
    window.fbq('trackCustom', action, {
      category,
      label,
      value,
      ...metadata,
    });
  }

  // Console log in development
  if (import.meta.env.DEV) {
    console.log('Analytics Event:', { category, action, label, value, metadata });
  }
};

/**
 * Track a search event
 */
export const trackSearch = (query: string, resultsCount?: number): void => {
  trackEvent({
    category: 'search',
    action: 'property_search',
    label: query,
    value: resultsCount,
    metadata: {
      search_term: query,
      results_count: resultsCount,
    },
  });

  // GA search event
  if (window.gtag) {
    window.gtag('event', 'search', {
      search_term: query,
    });
  }

  // Meta Pixel search event
  if (window.fbq) {
    window.fbq('track', 'Search', {
      search_string: query,
      content_category: 'property',
    });
  }
};

/**
 * Track when a user clicks an example query
 */
export const trackExampleQueryClick = (query: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'example_query_clicked',
    label: query,
    metadata: {
      query_text: query,
    },
  });
};

/**
 * Track when search results are displayed
 */
export const trackSearchResults = (
  query: string,
  resultsCount: number,
  hasExplanation: boolean
): void => {
  trackEvent({
    category: 'search',
    action: 'search_results_displayed',
    label: query,
    value: resultsCount,
    metadata: {
      query: query,
      results_count: resultsCount,
      has_explanation: hasExplanation,
    },
  });
};

/**
 * Track when a user views property details
 */
export const trackPropertyView = (propertyId: string, propertyAddress?: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'property_viewed',
    label: propertyAddress || propertyId,
    metadata: {
      property_id: propertyId,
      property_address: propertyAddress,
    },
  });

  // Meta Pixel content view
  if (window.fbq) {
    window.fbq('track', 'ViewContent', {
      content_name: propertyAddress || propertyId,
      content_category: 'property',
      content_ids: [propertyId],
      content_type: 'product',
    });
  }
};

/**
 * Track page view (automatically called on route change)
 */
export const trackPageView = (path: string, title?: string): void => {
  if (window.gtag) {
    window.gtag('config', 'G-J7TL7PQH7S', {
      page_path: path,
      page_title: title,
    });
  }

  if (window.fbq) {
    window.fbq('track', 'PageView');
  }
};

/**
 * Track errors
 */
export const trackError = (errorMessage: string, errorContext?: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'error_occurred',
    label: errorMessage,
    metadata: {
      error_message: errorMessage,
      error_context: errorContext,
    },
  });
};

/**
 * Track custom conversion events
 */
export const trackConversion = (conversionType: string, value?: number): void => {
  trackEvent({
    category: 'conversion',
    action: conversionType,
    value: value,
  });

  // Meta Pixel conversion
  if (window.fbq) {
    window.fbq('track', 'Lead', {
      content_name: conversionType,
      value: value,
      currency: 'USD',
    });
  }
};
</file>

<file path="api-config.ts">
/**
 * API Configuration Utility
 * Handles API URL resolution with proper fallback chain:
 * 1. Server-passed config (xcontroller)
 * 2. Build-time environment variable (VITE_API_URL)
 * 3. Local development fallback (/api)
 */

import { dataController } from './xcontroller.client';

interface InitialAppData {
  apiUrl: string;
  environment: string;
  features: {
    search: boolean;
    analytics: boolean;
    monitoring: boolean;
  };
  version: string;
}

/**
 * Get the API base URL for making requests
 * @returns The API base URL to use for API calls
 */
export function getApiBaseUrl(): string {
  // Priority 1: Build-time environment variable (for static deployments)
  // VITE_API_URL is set in .github/workflows/deploy.yml for GitHub Pages
  // Check this first to avoid console errors in static builds where no script tag exists
  const viteApiUrl = import.meta.env.VITE_API_URL;
  if (viteApiUrl) {
    return viteApiUrl;
  }

  // Priority 2: Server-passed configuration (for SSR scenarios)
  // Only check this if VITE_API_URL isn't set (to avoid console errors in static builds)
  const initialData = dataController.loadData<InitialAppData>('initial-data');
  if (initialData?.apiUrl) {
    return initialData.apiUrl;
  }

  // Priority 3: Local development fallback
  // Uses relative path for local dev server proxy configuration
  return '/api';
}
</file>

<file path="logger.ts">
/**
 * Client-side logger
 *
 * Simple wrapper around console for consistent logging in the browser
 * Can be enhanced later with remote logging, log levels, etc.
 */

const isDevelopment = import.meta.env.DEV;

const logger = {
  info: (...args: any[]) => {
    if (isDevelopment) {
      console.log('[INFO]', ...args);
    }
  },

  error: (...args: any[]) => {
    console.error('[ERROR]', ...args);
  },

  warn: (...args: any[]) => {
    if (isDevelopment) {
      console.warn('[WARN]', ...args);
    }
  },

  debug: (...args: any[]) => {
    if (isDevelopment) {
      console.debug('[DEBUG]', ...args);
    }
  },

  log: (...args: any[]) => {
    if (isDevelopment) {
      console.log(...args);
    }
  }
};

export default logger;
</file>

<file path="README_ENHANCED.md">
# lib

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "lib",
  "description": "Directory containing 3 code files with 4 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions"
  ]
}
</script>

## Overview

This directory contains 3 code file(s) with extracted schemas.

## Subdirectories

- `__tests__/`

## Files and Schemas

### `analytics.ts` (typescript)

**Classes:**
- `Window` - Line 7
- `AnalyticsEvent` - Line 20

### `api-config.ts` (typescript)

**Classes:**
- `InitialAppData` - Line 10

### `xcontroller.client.ts` (typescript)

**Classes:**
- `DataController` - Line 5

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="xcontroller.client.ts">
/**
 * XController Client - Data Controller for loading server-passed data
 * Safely loads and caches JSON data from script tags in the DOM
 */

export class DataController {
  private cache: Map<string, any> = new Map();
  private debug: boolean;

  constructor(debug = false) {
    this.debug = debug;
  }

  /**
   * Load data from a JSON script tag in the DOM
   * @param id - The ID of the script tag containing JSON data
   * @returns The parsed data or null if not found/invalid
   */
  loadData<T = any>(id: string): T | null {
    // Check cache first
    if (this.cache.has(id)) {
      return this.cache.get(id) as T;
    }

    try {
      const scriptElement = document.getElementById(id);

      if (!scriptElement) {
        if (this.debug) {
          console.error(`[DataController] Script tag with id="${id}" not found`);
        }
        return null;
      }

      if (scriptElement.getAttribute('type') !== 'application/json') {
        if (this.debug) {
          console.error(
            `[DataController] Script tag with id="${id}" has wrong type attribute`
          );
        }
        return null;
      }

      const content = scriptElement.textContent;
      if (!content || content.trim() === '') {
        if (this.debug) {
          console.error(`[DataController] Script tag with id="${id}" is empty`);
        }
        return null;
      }

      const data = JSON.parse(content);

      // Validate that data is not null (null is not considered valid)
      if (data === null) {
        if (this.debug) {
          console.error(`[DataController] Data in script tag id="${id}" is null`);
        }
        return null;
      }

      // Cache the parsed data
      this.cache.set(id, data);

      return data as T;
    } catch (error) {
      if (this.debug) {
        console.error(`[DataController] Error loading data from id="${id}":`, error);
      }
      return null;
    }
  }

  /**
   * Load data with API fallback
   * @param id - The ID of the script tag
   * @param fallbackUrl - The API URL to fetch from if script tag is missing
   * @returns The data or null
   */
  async loadDataWithFallback<T = any>(
    id: string,
    fallbackUrl: string
  ): Promise<T | null> {
    // Try loading from script tag first
    const scriptData = this.loadData<T>(id);
    if (scriptData !== null) {
      return scriptData;
    }

    // Check if we already fetched this fallback
    const fallbackCacheKey = `__fallback__${fallbackUrl}`;
    if (this.cache.has(fallbackCacheKey)) {
      return this.cache.get(fallbackCacheKey) as T;
    }

    // Fallback to API
    try {
      const response = await fetch(fallbackUrl);

      if (!response.ok) {
        if (this.debug) {
          console.error(
            `[DataController] API fallback failed: ${response.status} ${response.statusText}`
          );
        }
        return null;
      }

      const data = await response.json();

      // Cache the API response
      this.cache.set(fallbackCacheKey, data);

      return data as T;
    } catch (error) {
      if (this.debug) {
        console.error(`[DataController] Error fetching fallback data:`, error);
      }
      return null;
    }
  }

  /**
   * Clear the cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get the cache size
   */
  getCacheSize(): number {
    return this.cache.size;
  }
}

// Export a singleton instance for convenience
export const dataController = new DataController(import.meta.env.DEV);
</file>

</files>
