This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
components/
  features/
    PropertySearch/
      ExampleQueries.module.css
      ExampleQueries.tsx
      index.ts
      PropertyCard.module.css
      PropertyCard.tsx
      PropertySearchContainer.module.css
      PropertySearchContainer.tsx
      SearchBox.module.css
      SearchBox.tsx
      SearchResults.module.css
      SearchResults.tsx
  ui/
    Badge/
      Badge.module.css
      Badge.tsx
      index.ts
    Button/
      Button.module.css
      Button.tsx
      index.ts
    Card/
      Card.module.css
      Card.tsx
      index.ts
    Icon/
      Icon.tsx
      icons.ts
      index.ts
    Input/
      index.ts
      Input.module.css
      Input.tsx
    index.ts
  Analytics.css
  Analytics.tsx
  Charts.css
  Charts.tsx
  ErrorBoundary.tsx
  Filters.css
  Filters.tsx
  PropertySearch.css
  PropertySearch.tsx
  PropertyTable.css
  PropertyTable.tsx
  README.md
  ScrapeManager.css
  ScrapeManager.tsx
hooks/
  index.ts
  README_ENHANCED.md
  useAnalytics.ts
  useDebounce.ts
  useFormatting.ts
  usePagination.ts
  usePropertySearch.ts
lib/
  __tests__/
    api-config.test.ts
    README_ENHANCED.md
    xcontroller.client.test.ts
  analytics.ts
  api-config.ts
  logger.ts
  README_ENHANCED.md
  xcontroller.client.ts
services/
  api.service.ts
  README_ENHANCED.md
  README.md
types/
  index.ts
  README_ENHANCED.md
  README.md
utils/
  __tests__/
    formatters.test.ts
  constants.ts
  formatters.ts
  helpers.ts
  index.ts
App.css
App.tsx
database.ts
main.tsx
query-db.ts
README_ENHANCED.md
README.md
test-api-direct.ts
vite-env.d.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/features/PropertySearch/ExampleQueries.module.css">
.container {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.75rem;
  margin-top: 1rem;
}

.label {
  font-size: 0.875rem;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

.chips {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.chip {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 20px;
  color: white;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(10px);
}

.chip:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.3);
  border-color: rgba(255, 255, 255, 0.5);
  transform: translateY(-2px);
}

.chip:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</file>

<file path="components/features/PropertySearch/ExampleQueries.tsx">
import { useAnalytics } from '../../../hooks';
import { EXAMPLE_QUERIES } from '../../../utils/constants';
import styles from './ExampleQueries.module.css';

interface ExampleQueriesProps {
  onSelectQuery: (query: string) => void;
  disabled?: boolean;
}

export const ExampleQueries = ({
  onSelectQuery,
  disabled = false,
}: ExampleQueriesProps) => {
  const { logExampleQueryClick } = useAnalytics();

  const handleQueryClick = (query: string) => {
    logExampleQueryClick(query);
    onSelectQuery(query);
  };

  return (
    <div className={styles.container}>
      <span className={styles.label}>Try:</span>
      <div className={styles.chips}>
        {EXAMPLE_QUERIES.map((example, idx) => (
          <button
            key={idx}
            onClick={() => handleQueryClick(example)}
            className={styles.chip}
            disabled={disabled}
          >
            {example}
          </button>
        ))}
      </div>
    </div>
  );
};
</file>

<file path="components/features/PropertySearch/index.ts">
export { PropertySearchContainer } from './PropertySearchContainer';
export { PropertyCard } from './PropertyCard';
export { SearchBox } from './SearchBox';
export { ExampleQueries } from './ExampleQueries';
export { SearchResults } from './SearchResults';
</file>

<file path="components/features/PropertySearch/PropertyCard.module.css">
.card {
  height: 100%;
  transition: all 0.2s ease;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
}

.owner {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--neutral-900, #111827);
  margin: 0;
  flex: 1;
}

.address {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  color: var(--neutral-600, #4b5563);
  margin-bottom: 1rem;
}

.details {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.detailItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid var(--neutral-100, #f3f4f6);
}

.detailItem:last-child {
  border-bottom: none;
}

.detailLabel {
  font-size: 0.875rem;
  color: var(--neutral-600, #4b5563);
}

.detailValue {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--neutral-900, #111827);
}

.mono {
  font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
  font-size: 0.8125rem;
}
</file>

<file path="components/features/PropertySearch/PropertyCard.tsx">
import { useEffect } from 'react';
import { Property } from '../../../types';
import { useFormatting, useAnalytics } from '../../../hooks';
import { Card, CardHeader, CardBody } from '../../ui/Card';
import { Badge } from '../../ui/Badge';
import { Icon } from '../../ui/Icon';
import styles from './PropertyCard.module.css';

interface PropertyCardProps {
  property: Property;
}

export const PropertyCard = ({ property }: PropertyCardProps) => {
  const { formatCurrency } = useFormatting();
  const { logPropertyView } = useAnalytics();

  // Track property view when card is rendered
  useEffect(() => {
    logPropertyView(property.property_id, property.property_address);
  }, [property.property_id, property.property_address, logPropertyView]);

  return (
    <Card variant="elevated" className={styles.card}>
      <CardHeader>
        <div className={styles.header}>
          <h3 className={styles.owner}>{property.name}</h3>
          <Badge variant="info" size="sm">
            {property.prop_type}
          </Badge>
        </div>
      </CardHeader>

      <CardBody>
        <div className={styles.address}>
          <Icon name="location" size={14} />
          {property.property_address}
          {property.city && `, ${property.city}`}
        </div>

        <div className={styles.details}>
          <div className={styles.detailItem}>
            <span className={styles.detailLabel}>Appraised Value</span>
            <span className={styles.detailValue}>
              {formatCurrency(property.appraised_value)}
            </span>
          </div>

          {property.assessed_value && (
            <div className={styles.detailItem}>
              <span className={styles.detailLabel}>Assessed Value</span>
              <span className={styles.detailValue}>
                {formatCurrency(property.assessed_value)}
              </span>
            </div>
          )}

          <div className={styles.detailItem}>
            <span className={styles.detailLabel}>Property ID</span>
            <span className={`${styles.detailValue} ${styles.mono}`}>
              {property.property_id}
            </span>
          </div>
        </div>
      </CardBody>
    </Card>
  );
};
</file>

<file path="components/features/PropertySearch/PropertySearchContainer.module.css">
.container {
  min-height: 100vh;
  background: linear-gradient(to bottom, #f9fafb 0%, white 50%);
}

.hero {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 4rem 2rem;
  color: white;
}

.header {
  max-width: 1200px;
  margin: 0 auto 3rem;
  text-align: center;
}

.header h1 {
  font-size: 3.5rem;
  font-weight: 800;
  margin: 0 0 1rem;
  line-height: 1.2;
}

.subtitle {
  font-size: 1.25rem;
  opacity: 0.95;
  margin: 0;
}

.searchContainer {
  max-width: 900px;
  margin: 0 auto;
}

@media (max-width: 768px) {
  .hero {
    padding: 3rem 1.5rem;
  }

  .header h1 {
    font-size: 2rem;
  }

  .subtitle {
    font-size: 1rem;
  }
}

@media (max-width: 640px) {
  .hero {
    padding: 2rem 1rem;
  }

  .header h1 {
    font-size: 1.75rem;
  }
}
</file>

<file path="components/features/PropertySearch/PropertySearchContainer.tsx">
import { useState, useEffect } from 'react';
import { usePropertySearch, useAnalytics } from '../../../hooks';
import { SearchBox } from './SearchBox';
import { ExampleQueries } from './ExampleQueries';
import { SearchResults } from './SearchResults';
import styles from './PropertySearchContainer.module.css';

export const PropertySearchContainer = () => {
  const { results, loading, error, totalResults, explanation, search } =
    usePropertySearch();
  const { logSearch, logSearchResults, logError } = useAnalytics();
  const [searchQuery, setSearchQuery] = useState('');

  const handleSearch = async (query: string) => {
    setSearchQuery(query);

    // Track search initiation
    logSearch(query);

    await search(query);
  };

  // Track search results when they change
  useEffect(() => {
    if (results.length > 0 && searchQuery) {
      logSearchResults(searchQuery, totalResults, !!explanation);
    }
  }, [results, totalResults, explanation, searchQuery, logSearchResults]);

  // Track errors
  useEffect(() => {
    if (error) {
      logError(error, 'property_search');
    }
  }, [error, logError]);

  return (
    <div className={styles.container}>
      <div className={styles.hero}>
        <div className={styles.header}>
          <h1>TCAD Property Explorer</h1>
          <p className={styles.subtitle}>
            Search 122,000+ Travis County properties using natural language
          </p>
        </div>

        <div className={styles.searchContainer}>
          <SearchBox onSearch={handleSearch} loading={loading} />
          <ExampleQueries
            onSelectQuery={handleSearch}
            disabled={loading}
          />
        </div>
      </div>

      <SearchResults
        results={results}
        totalResults={totalResults}
        explanation={explanation}
        error={error}
        loading={loading}
        searchQuery={searchQuery}
      />
    </div>
  );
};
</file>

<file path="components/features/PropertySearch/SearchBox.module.css">
.searchBox {
  position: relative;
  display: flex;
  align-items: center;
  background: white;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
  overflow: hidden;
  transition: all 0.3s ease;
}

.searchBox:focus-within {
  box-shadow: 0 10px 60px rgba(0, 0, 0, 0.2);
  transform: translateY(-2px);
}

.searchIcon {
  position: absolute;
  left: 1.5rem;
  display: flex;
  align-items: center;
  color: var(--neutral-400, #9ca3af);
  pointer-events: none;
}

.searchInput {
  flex: 1;
  padding: 1.25rem 1.5rem 1.25rem 4rem;
  border: none;
  font-size: 1rem;
  line-height: 1.5rem;
  color: var(--neutral-900, #111827);
  background: transparent;
}

.searchInput:focus {
  outline: none;
}

.searchInput::placeholder {
  color: var(--neutral-400, #9ca3af);
}

.searchInput:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

@media (max-width: 640px) {
  .searchBox {
    flex-direction: column;
    align-items: stretch;
  }

  .searchInput {
    padding-right: 1.5rem;
  }

  .searchBox button {
    border-radius: 0;
    border-bottom-left-radius: 12px;
    border-bottom-right-radius: 12px;
  }
}
</file>

<file path="components/features/PropertySearch/SearchBox.tsx">
import { useState, KeyboardEvent } from 'react';
import { Button } from '../../ui/Button';
import { Icon } from '../../ui/Icon';
import styles from './SearchBox.module.css';

interface SearchBoxProps {
  onSearch: (query: string) => void;
  loading?: boolean;
  placeholder?: string;
}

export const SearchBox = ({
  onSearch,
  loading = false,
  placeholder = "Ask anything... e.g., 'properties in Austin worth over $500k'",
}: SearchBoxProps) => {
  const [query, setQuery] = useState('');

  const handleSearch = () => {
    if (query.trim()) {
      onSearch(query);
    }
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  return (
    <div className={styles.searchBox}>
      <div className={styles.searchIcon}>
        <Icon name="search" />
      </div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyPress={handleKeyPress}
        placeholder={placeholder}
        className={styles.searchInput}
        disabled={loading}
      />
      <Button
        onClick={handleSearch}
        disabled={loading || !query.trim()}
        variant="primary"
      >
        {loading ? 'Searching...' : 'Search'}
      </Button>
    </div>
  );
};
</file>

<file path="components/features/PropertySearch/SearchResults.module.css">
.container {
  margin-top: 3rem;
}

.explanation {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem 1.5rem;
  background: var(--neutral-50, #f9fafb);
  border-left: 4px solid var(--primary, #2563eb);
  border-radius: 8px;
  margin-bottom: 2rem;
  font-size: 0.875rem;
  color: var(--neutral-700, #374151);
}

.explanationIcon {
  display: flex;
  align-items: center;
  color: var(--primary, #2563eb);
}

.resultCount {
  margin-left: auto;
  font-weight: 600;
  color: var(--primary, #2563eb);
}

.resultsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
}

.loadMore {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  margin-top: 3rem;
  padding: 2rem;
  text-align: center;
}

.loadMore p {
  margin: 0;
  color: var(--neutral-600, #4b5563);
}

.errorMessage {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem 1.5rem;
  background: #fee2e2;
  color: #991b1b;
  border-radius: 8px;
  margin-top: 2rem;
}

.noResults {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 4rem 2rem;
  text-align: center;
  color: var(--neutral-500, #6b7280);
}

.noResults h3 {
  margin: 1rem 0 0.5rem;
  color: var(--neutral-700, #374151);
}

.noResults p {
  margin: 0;
}

@media (max-width: 640px) {
  .resultsGrid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="components/features/PropertySearch/SearchResults.tsx">
import { Property } from '../../../types';
import { PropertyCard } from './PropertyCard';
import { Icon } from '../../ui/Icon';
import { Button } from '../../ui/Button';
import styles from './SearchResults.module.css';

interface SearchResultsProps {
  results: Property[];
  totalResults: number;
  explanation?: string;
  error?: string;
  loading?: boolean;
  searchQuery?: string;
  onLoadMore?: () => void;
}

export const SearchResults = ({
  results,
  totalResults,
  explanation,
  error,
  loading,
  searchQuery,
  onLoadMore,
}: SearchResultsProps) => {
  if (error) {
    return (
      <div className={styles.errorMessage}>
        <Icon name="alertCircle" />
        <div>
          <strong>Error:</strong> {error}
        </div>
      </div>
    );
  }

  if (!loading && results.length === 0 && searchQuery) {
    return (
      <div className={styles.noResults}>
        <Icon name="search" size={48} />
        <h3>No properties found</h3>
        <p>Try adjusting your search query or using one of the examples above</p>
      </div>
    );
  }

  if (results.length === 0) {
    return null;
  }

  return (
    <div className={styles.container}>
      {explanation && (
        <div className={styles.explanation}>
          <div className={styles.explanationIcon}>
            <Icon name="chevronRight" size={16} />
          </div>
          <span>{explanation}</span>
          <span className={styles.resultCount}>({totalResults} results)</span>
        </div>
      )}

      <div className={styles.resultsGrid}>
        {results.map((property) => (
          <PropertyCard key={property.id} property={property} />
        ))}
      </div>

      {results.length < totalResults && onLoadMore && (
        <div className={styles.loadMore}>
          <p>
            Showing {results.length} of {totalResults} results
          </p>
          <Button onClick={onLoadMore} variant="outline">
            Load More
          </Button>
        </div>
      )}
    </div>
  );
};
</file>

<file path="components/ui/Badge/Badge.module.css">
.badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  font-weight: 600;
  white-space: nowrap;
}

/* Sizes */
.sm {
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
  line-height: 1rem;
}

.md {
  padding: 0.375rem 0.75rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.lg {
  padding: 0.5rem 1rem;
  font-size: 1rem;
  line-height: 1.5rem;
}

/* Variants */
.default {
  background: var(--neutral-100, #f3f4f6);
  color: var(--neutral-700, #374151);
}

.success {
  background: #d1fae5;
  color: #065f46;
}

.warning {
  background: #fef3c7;
  color: #92400e;
}

.error {
  background: #fee2e2;
  color: #991b1b;
}

.info {
  background: #dbeafe;
  color: #1e40af;
}
</file>

<file path="components/ui/Badge/Badge.tsx">
import { ReactNode } from 'react';
import styles from './Badge.module.css';

type BadgeVariant = 'default' | 'success' | 'warning' | 'error' | 'info';
type BadgeSize = 'sm' | 'md' | 'lg';

interface BadgeProps {
  variant?: BadgeVariant;
  size?: BadgeSize;
  children: ReactNode;
  className?: string;
}

export const Badge = ({
  variant = 'default',
  size = 'md',
  children,
  className = '',
}: BadgeProps) => {
  const classes = [
    styles.badge,
    styles[variant],
    styles[size],
    className,
  ]
    .filter(Boolean)
    .join(' ');

  return <span className={classes}>{children}</span>;
};
</file>

<file path="components/ui/Badge/index.ts">
export { Badge } from './Badge';
</file>

<file path="components/ui/Button/Button.module.css">
.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: inherit;
  white-space: nowrap;
}

.button:focus-visible {
  outline: 2px solid var(--primary, #2563eb);
  outline-offset: 2px;
}

.button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Sizes */
.sm {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.md {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  line-height: 1.5rem;
}

.lg {
  padding: 1rem 2rem;
  font-size: 1.125rem;
  line-height: 1.75rem;
}

/* Variants */
.primary {
  background: var(--primary, #2563eb);
  color: white;
}

.primary:hover:not(:disabled) {
  background: var(--primary-dark, #1d4ed8);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
}

.secondary {
  background: var(--neutral-200, #e5e7eb);
  color: var(--neutral-900, #111827);
}

.secondary:hover:not(:disabled) {
  background: var(--neutral-300, #d1d5db);
}

.outline {
  background: transparent;
  border: 2px solid var(--primary, #2563eb);
  color: var(--primary, #2563eb);
}

.outline:hover:not(:disabled) {
  background: var(--primary, #2563eb);
  color: white;
}

.ghost {
  background: transparent;
  color: var(--neutral-700, #374151);
}

.ghost:hover:not(:disabled) {
  background: var(--neutral-100, #f3f4f6);
}

.fullWidth {
  width: 100%;
}
</file>

<file path="components/ui/Button/Button.tsx">
import { ReactNode, ButtonHTMLAttributes } from 'react';
import styles from './Button.module.css';

type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'ghost';
type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  children: ReactNode;
  fullWidth?: boolean;
}

export const Button = ({
  variant = 'primary',
  size = 'md',
  children,
  fullWidth = false,
  className = '',
  disabled,
  ...props
}: ButtonProps) => {
  const classes = [
    styles.button,
    styles[variant],
    styles[size],
    fullWidth && styles.fullWidth,
    className,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button className={classes} disabled={disabled} {...props}>
      {children}
    </button>
  );
};
</file>

<file path="components/ui/Button/index.ts">
export { Button } from './Button';
</file>

<file path="components/ui/Card/Card.module.css">
.card {
  background: white;
  border-radius: 12px;
  transition: all 0.2s ease;
}

.default {
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.elevated {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.elevated:hover {
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

.outlined {
  border: 1px solid var(--neutral-200, #e5e7eb);
  box-shadow: none;
}

/* Padding variants */
.padding-sm {
  padding: 1rem;
}

.padding-md {
  padding: 1.5rem;
}

.padding-lg {
  padding: 2rem;
}

/* Card sections */
.header {
  margin-bottom: 1rem;
}

.body {
  flex: 1;
}

.footer {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--neutral-200, #e5e7eb);
}
</file>

<file path="components/ui/Card/Card.tsx">
import { ReactNode, HTMLAttributes } from 'react';
import styles from './Card.module.css';

type CardVariant = 'default' | 'elevated' | 'outlined';

interface CardProps extends HTMLAttributes<HTMLDivElement> {
  variant?: CardVariant;
  children: ReactNode;
  padding?: 'sm' | 'md' | 'lg';
}

export const Card = ({
  variant = 'default',
  children,
  padding = 'md',
  className = '',
  ...props
}: CardProps) => {
  const classes = [
    styles.card,
    styles[variant],
    styles[`padding-${padding}`],
    className,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <div className={classes} {...props}>
      {children}
    </div>
  );
};

interface CardHeaderProps {
  children: ReactNode;
  className?: string;
}

export const CardHeader = ({ children, className = '' }: CardHeaderProps) => {
  return <div className={`${styles.header} ${className}`}>{children}</div>;
};

interface CardBodyProps {
  children: ReactNode;
  className?: string;
}

export const CardBody = ({ children, className = '' }: CardBodyProps) => {
  return <div className={`${styles.body} ${className}`}>{children}</div>;
};

interface CardFooterProps {
  children: ReactNode;
  className?: string;
}

export const CardFooter = ({ children, className = '' }: CardFooterProps) => {
  return <div className={`${styles.footer} ${className}`}>{children}</div>;
};
</file>

<file path="components/ui/Card/index.ts">
export { Card, CardHeader, CardBody, CardFooter } from './Card';
</file>

<file path="components/ui/Icon/Icon.tsx">
import { iconPaths, IconName } from './icons';

interface IconProps {
  name: IconName;
  size?: number;
  color?: string;
  className?: string;
  'aria-hidden'?: boolean;
}

export const Icon = ({
  name,
  size = 24,
  color = 'currentColor',
  className = '',
  'aria-hidden': ariaHidden = true,
}: IconProps) => {
  const pathData = iconPaths[name];

  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
      aria-hidden={ariaHidden}
    >
      <path d={pathData} />
    </svg>
  );
};
</file>

<file path="components/ui/Icon/icons.ts">
/**
 * SVG icon paths as string data
 * Centralizes all icon definitions
 */

export const iconPaths: Record<string, string> = {
  search: 'M11 11m-8 0a8 8 0 1 0 16 0a8 8 0 1 0 -16 0M21 21l-4.35-4.35',
  location: 'M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0zM12 10m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0',
  chevronRight: 'M9 18l6-6l-6-6',
  calendar: 'M3 6a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6zM16 2v4M8 2v4M3 10h18',
  check: 'M20 6L9 17l-5-5',
  x: 'M18 6L6 18M6 6l12 12',
  alertCircle: 'M12 12m-10 0a10 10 0 1 0 20 0a10 10 0 1 0 -20 0M12 8v4M12 16h0.01',
  info: 'M12 12m-10 0a10 10 0 1 0 20 0a10 10 0 1 0 -20 0M12 16v-4M12 8h0.01',
  arrowUp: 'M12 19V5',
  arrowDown: 'M12 5v14',
  loader: 'M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83',
  filter: 'M22 3H2l8 9.46V19l4 2V12.46L22 3z',
  download: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5l5-5M12 15V3',
  refresh: 'M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15',
};

export type IconName = keyof typeof iconPaths;
</file>

<file path="components/ui/Icon/index.ts">
export { Icon } from './Icon';
export { iconPaths, type IconName } from './icons';
</file>

<file path="components/ui/Input/index.ts">
export { Input } from './Input';
</file>

<file path="components/ui/Input/Input.module.css">
.inputWrapper {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.label {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--neutral-700, #374151);
}

.inputContainer {
  position: relative;
  display: flex;
  align-items: center;
}

.input {
  width: 100%;
  padding: 0.75rem 1rem;
  border: 1px solid var(--neutral-300, #d1d5db);
  border-radius: 8px;
  font-size: 1rem;
  line-height: 1.5rem;
  transition: all 0.2s ease;
  font-family: inherit;
}

.input:focus {
  outline: none;
  border-color: var(--primary, #2563eb);
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.input.withIcon {
  padding-left: 3rem;
}

.input.error {
  border-color: #ef4444;
}

.input.error:focus {
  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
}

.icon {
  position: absolute;
  left: 1rem;
  display: flex;
  align-items: center;
  color: var(--neutral-500, #6b7280);
  pointer-events: none;
}

.errorText {
  font-size: 0.875rem;
  color: #ef4444;
}

.input:disabled {
  background: var(--neutral-100, #f3f4f6);
  cursor: not-allowed;
  opacity: 0.6;
}
</file>

<file path="components/ui/Input/Input.tsx">
import { InputHTMLAttributes, ReactNode } from 'react';
import styles from './Input.module.css';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  icon?: ReactNode;
}

export const Input = ({
  label,
  error,
  icon,
  id,
  className = '',
  ...props
}: InputProps) => {
  const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`;

  return (
    <div className={`${styles.inputWrapper} ${className}`}>
      {label && (
        <label htmlFor={inputId} className={styles.label}>
          {label}
        </label>
      )}
      <div className={styles.inputContainer}>
        {icon && <div className={styles.icon}>{icon}</div>}
        <input
          id={inputId}
          className={`${styles.input} ${icon ? styles.withIcon : ''} ${
            error ? styles.error : ''
          }`}
          {...props}
        />
      </div>
      {error && <span className={styles.errorText}>{error}</span>}
    </div>
  );
};
</file>

<file path="components/ui/index.ts">
// UI Component Library Barrel Export
export { Icon, iconPaths, type IconName } from './Icon';
export { Button } from './Button';
export { Card, CardHeader, CardBody, CardFooter } from './Card';
export { Badge } from './Badge';
export { Input } from './Input';
</file>

<file path="components/Analytics.css">
.analytics {
  max-width: 1200px;
  margin: 0 auto 48px;
}

.analytics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.stat-card {
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  transition: transform 0.2s, box-shadow 0.2s;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.stat-card.primary {
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  color: white;
}

.stat-label {
  font-size: 0.875rem;
  font-weight: 500;
  opacity: 0.8;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.stat-card.primary .stat-label {
  opacity: 0.9;
}

.stat-value {
  font-size: 2rem;
  font-weight: 700;
  line-height: 1.2;
}

.analytics-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 24px;
}

.detail-card {
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}

.detail-card h3 {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--neutral-800);
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 2px solid var(--neutral-100);
}

.detail-content {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.detail-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
}

.detail-label {
  font-size: 0.875rem;
  color: var(--neutral-600);
  font-weight: 500;
}

.detail-value {
  font-size: 0.875rem;
  color: var(--neutral-900);
  font-weight: 600;
}

@media (max-width: 768px) {
  .analytics {
    margin-bottom: 32px;
  }

  .analytics-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .analytics-details {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .stat-card {
    padding: 20px;
  }

  .stat-value {
    font-size: 1.75rem;
  }
}
</file>

<file path="components/Analytics.tsx">
import { useMemo } from 'react';
import { Property } from '../types';
import './Analytics.css';

interface AnalyticsProps {
  properties: Property[];
}

function Analytics({ properties }: AnalyticsProps) {
  const stats = useMemo(() => {
    if (properties.length === 0) {
      return {
        totalProperties: 0,
        totalAppraised: 0,
        totalAssessed: 0,
        avgAppraised: 0,
        avgAssessed: 0,
        maxAppraised: 0,
        minAppraised: 0,
        propertyTypes: {},
        cities: {},
      };
    }

    const totalAppraised = properties.reduce((sum, p) => sum + p.appraised_value, 0);
    const totalAssessed = properties.reduce((sum, p) => sum + p.assessed_value, 0);
    const appraisedValues = properties.map(p => p.appraised_value).filter(v => v > 0);

    const propertyTypes: Record<string, number> = {};
    const cities: Record<string, number> = {};

    properties.forEach(p => {
      propertyTypes[p.prop_type] = (propertyTypes[p.prop_type] || 0) + 1;
      if (p.city) {
        cities[p.city] = (cities[p.city] || 0) + 1;
      }
    });

    return {
      totalProperties: properties.length,
      totalAppraised,
      totalAssessed,
      avgAppraised: totalAppraised / properties.length,
      avgAssessed: totalAssessed / properties.length,
      maxAppraised: Math.max(...appraisedValues),
      minAppraised: Math.min(...appraisedValues),
      propertyTypes,
      cities,
    };
  }, [properties]);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };

  const topPropertyTypes = Object.entries(stats.propertyTypes)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  const topCities = Object.entries(stats.cities)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  return (
    <div className="analytics">
      <div className="analytics-grid">
        <div className="stat-card primary">
          <div className="stat-label">Total Properties</div>
          <div className="stat-value">{stats.totalProperties.toLocaleString()}</div>
        </div>

        <div className="stat-card">
          <div className="stat-label">Total Appraised Value</div>
          <div className="stat-value">{formatCurrency(stats.totalAppraised)}</div>
        </div>

        <div className="stat-card">
          <div className="stat-label">Average Appraised Value</div>
          <div className="stat-value">{formatCurrency(stats.avgAppraised)}</div>
        </div>

        <div className="stat-card">
          <div className="stat-label">Total Assessed Value</div>
          <div className="stat-value">{formatCurrency(stats.totalAssessed)}</div>
        </div>
      </div>

      <div className="analytics-details">
        <div className="detail-card">
          <h3>Value Range</h3>
          <div className="detail-content">
            <div className="detail-item">
              <span className="detail-label">Highest Value:</span>
              <span className="detail-value">{formatCurrency(stats.maxAppraised)}</span>
            </div>
            <div className="detail-item">
              <span className="detail-label">Lowest Value:</span>
              <span className="detail-value">{formatCurrency(stats.minAppraised)}</span>
            </div>
          </div>
        </div>

        <div className="detail-card">
          <h3>Top Property Types</h3>
          <div className="detail-content">
            {topPropertyTypes.map(([type, count]) => (
              <div key={type} className="detail-item">
                <span className="detail-label">{type || 'Unknown'}:</span>
                <span className="detail-value">{count} properties</span>
              </div>
            ))}
          </div>
        </div>

        <div className="detail-card">
          <h3>Top Cities</h3>
          <div className="detail-content">
            {topCities.map(([city, count]) => (
              <div key={city} className="detail-item">
                <span className="detail-label">{city}:</span>
                <span className="detail-value">{count} properties</span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

export default Analytics;
</file>

<file path="components/Charts.css">
.charts {
  max-width: 1200px;
  margin: 0 auto 32px;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 24px;
}

.chart-card {
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}

.chart-card.full-width {
  grid-column: 1 / -1;
}

.chart-card h3 {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--neutral-800);
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 2px solid var(--neutral-100);
}

.chart-content {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.bar-group {
  display: grid;
  grid-template-columns: 120px 1fr;
  align-items: center;
  gap: 12px;
}

.bar-label {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--neutral-700);
  text-align: right;
}

.bar-container {
  background-color: var(--neutral-100);
  border-radius: 6px;
  overflow: hidden;
  height: 32px;
  position: relative;
}

.bar {
  height: 100%;
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 0 12px;
  min-width: 60px;
  transition: width 0.6s ease;
  position: relative;
}

.bar.secondary {
  background: linear-gradient(135deg, var(--secondary) 0%, #059669 100%);
}

.bar.accent {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
}

.bar-value {
  color: white;
  font-size: 0.75rem;
  font-weight: 600;
  white-space: nowrap;
}

@media (max-width: 968px) {
  .charts {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 640px) {
  .charts {
    gap: 16px;
  }

  .chart-card {
    padding: 20px;
  }

  .bar-group {
    grid-template-columns: 90px 1fr;
    gap: 8px;
  }

  .bar-label {
    font-size: 0.8125rem;
  }

  .bar-container {
    height: 28px;
  }

  .bar {
    min-width: 50px;
    padding: 0 8px;
  }
}
</file>

<file path="components/Charts.tsx">
import { useMemo } from 'react';
import { Property } from '../types';
import './Charts.css';

interface ChartsProps {
  properties: Property[];
}

function Charts({ properties }: ChartsProps) {
  const valueDistribution = useMemo(() => {
    const ranges = [
      { label: '$0-100k', min: 0, max: 100000, count: 0 },
      { label: '$100k-250k', min: 100000, max: 250000, count: 0 },
      { label: '$250k-500k', min: 250000, max: 500000, count: 0 },
      { label: '$500k-1M', min: 500000, max: 1000000, count: 0 },
      { label: '$1M+', min: 1000000, max: Infinity, count: 0 },
    ];

    properties.forEach(p => {
      const range = ranges.find(r => p.appraised_value >= r.min && p.appraised_value < r.max);
      if (range) range.count++;
    });

    const maxCount = Math.max(...ranges.map(r => r.count));

    return ranges.map(r => ({
      ...r,
      percentage: maxCount > 0 ? (r.count / maxCount) * 100 : 0,
    }));
  }, [properties]);

  const propertyTypeDistribution = useMemo(() => {
    const types: Record<string, number> = {};

    properties.forEach(p => {
      types[p.prop_type] = (types[p.prop_type] || 0) + 1;
    });

    const sorted = Object.entries(types)
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 8);

    const maxCount = Math.max(...sorted.map(t => t.count));

    return sorted.map(t => ({
      ...t,
      percentage: maxCount > 0 ? (t.count / maxCount) * 100 : 0,
    }));
  }, [properties]);

  const cityDistribution = useMemo(() => {
    const cities: Record<string, { count: number; totalValue: number }> = {};

    properties.forEach(p => {
      if (p.city) {
        if (!cities[p.city]) {
          cities[p.city] = { count: 0, totalValue: 0 };
        }
        cities[p.city].count++;
        cities[p.city].totalValue += p.appraised_value;
      }
    });

    const sorted = Object.entries(cities)
      .map(([city, data]) => ({
        city,
        count: data.count,
        avgValue: data.totalValue / data.count,
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    const maxCount = Math.max(...sorted.map(c => c.count));

    return sorted.map(c => ({
      ...c,
      percentage: maxCount > 0 ? (c.count / maxCount) * 100 : 0,
    }));
  }, [properties]);

  return (
    <div className="charts">
      <div className="chart-card">
        <h3>Property Value Distribution</h3>
        <div className="chart-content">
          {valueDistribution.map(range => (
            <div key={range.label} className="bar-group">
              <div className="bar-label">{range.label}</div>
              <div className="bar-container">
                <div
                  className="bar"
                  style={{ width: `${range.percentage}%` }}
                >
                  <span className="bar-value">{range.count}</span>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="chart-card">
        <h3>Top Property Types</h3>
        <div className="chart-content">
          {propertyTypeDistribution.map(type => (
            <div key={type.type} className="bar-group">
              <div className="bar-label">{type.type}</div>
              <div className="bar-container">
                <div
                  className="bar secondary"
                  style={{ width: `${type.percentage}%` }}
                >
                  <span className="bar-value">{type.count}</span>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="chart-card full-width">
        <h3>Properties by City</h3>
        <div className="chart-content">
          {cityDistribution.map(city => (
            <div key={city.city} className="bar-group">
              <div className="bar-label">{city.city}</div>
              <div className="bar-container">
                <div
                  className="bar accent"
                  style={{ width: `${city.percentage}%` }}
                >
                  <span className="bar-value">{city.count}</span>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

export default Charts;
</file>

<file path="components/ErrorBoundary.tsx">
import { Component, ReactNode, ErrorInfo } from 'react';
import { trackError } from '../lib/analytics';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Track error to analytics
    trackError(error.message, 'error_boundary', {
      componentStack: errorInfo.componentStack,
      errorName: error.name,
    });

    // Log to console in development
    if (import.meta.env.DEV) {
      console.error('ErrorBoundary caught error:', error, errorInfo);
    }
  }

  render(): ReactNode {
    if (this.state.hasError) {
      // Show custom fallback UI if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return (
        <div
          style={{
            padding: '2rem',
            textAlign: 'center',
            maxWidth: '600px',
            margin: '4rem auto',
          }}
        >
          <h1 style={{ fontSize: '1.5rem', marginBottom: '1rem' }}>
            Something went wrong
          </h1>
          <p style={{ color: '#666', marginBottom: '1.5rem' }}>
            We've been notified about this error and will fix it as soon as
            possible.
          </p>
          <button
            onClick={() => window.location.reload()}
            style={{
              padding: '0.75rem 1.5rem',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '1rem',
            }}
          >
            Reload Page
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="components/Filters.css">
.filters {
  max-width: 1200px;
  margin: 0 auto 32px;
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}

.filters-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.filters-header h2 {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--neutral-800);
}

.reset-btn {
  padding: 8px 16px;
  background-color: var(--neutral-100);
  color: var(--neutral-700);
  border: none;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.reset-btn:hover {
  background-color: var(--neutral-200);
}

.filters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.filter-group label {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--neutral-700);
}

.filter-group input,
.filter-group select {
  padding: 10px 12px;
  border: 1px solid var(--neutral-300);
  border-radius: 6px;
  font-size: 0.875rem;
  color: var(--neutral-900);
  background-color: white;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.filter-group input:focus,
.filter-group select:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.filter-group input::placeholder {
  color: var(--neutral-400);
}

@media (max-width: 768px) {
  .filters {
    padding: 20px;
    margin-bottom: 24px;
  }

  .filters-grid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="components/Filters.tsx">
import { useState, useMemo } from 'react';
import { Property } from '../types';
import './Filters.css';

interface FiltersProps {
  properties: Property[];
  onFilterChange: (filtered: Property[]) => void;
}

interface FilterState {
  searchTerm: string;
  selectedCity: string;
  selectedType: string;
  minValue: string;
  maxValue: string;
}

const initialFilterState: FilterState = {
  searchTerm: '',
  selectedCity: '',
  selectedType: '',
  minValue: '',
  maxValue: '',
};

function applyFilters(properties: Property[], filters: FilterState): Property[] {
  return properties.filter(property => {
    // Search filter
    if (filters.searchTerm) {
      const term = filters.searchTerm.toLowerCase();
      const matchesSearch =
        property.name.toLowerCase().includes(term) ||
        property.property_address.toLowerCase().includes(term) ||
        property.property_id.toLowerCase().includes(term) ||
        (property.description && property.description.toLowerCase().includes(term));

      if (!matchesSearch) return false;
    }

    // City filter
    if (filters.selectedCity && property.city !== filters.selectedCity) {
      return false;
    }

    // Property type filter
    if (filters.selectedType && property.prop_type !== filters.selectedType) {
      return false;
    }

    // Min value filter
    if (filters.minValue) {
      const min = parseFloat(filters.minValue);
      if (property.appraised_value < min) return false;
    }

    // Max value filter
    if (filters.maxValue) {
      const max = parseFloat(filters.maxValue);
      if (property.appraised_value > max) return false;
    }

    return true;
  });
}

function Filters({ properties, onFilterChange }: FiltersProps) {
  const [filters, setFilters] = useState<FilterState>(initialFilterState);

  const cities = useMemo(() => {
    const citySet = new Set(properties.map(p => p.city).filter(Boolean));
    return Array.from(citySet).sort();
  }, [properties]);

  const propertyTypes = useMemo(() => {
    const typeSet = new Set(properties.map(p => p.prop_type).filter(Boolean));
    return Array.from(typeSet).sort();
  }, [properties]);

  const filteredProperties = useMemo(() => {
    const filtered = applyFilters(properties, filters);
    onFilterChange(filtered);
    return filtered;
  }, [properties, filters, onFilterChange]);

  const updateFilter = <K extends keyof FilterState>(key: K, value: FilterState[K]) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };

  const handleReset = () => {
    setFilters(initialFilterState);
  };

  const hasActiveFilters = Object.values(filters).some(value => value !== '');

  return (
    <div className="filters">
      <div className="filters-header">
        <h2>Filter & Search</h2>
        {hasActiveFilters && (
          <button className="reset-btn" onClick={handleReset}>
            Reset All
          </button>
        )}
      </div>

      <div className="filters-grid">
        <div className="filter-group">
          <label htmlFor="search">Search</label>
          <input
            id="search"
            type="text"
            placeholder="Search by name, address, or property ID..."
            value={filters.searchTerm}
            onChange={(e) => updateFilter('searchTerm', e.target.value)}
          />
        </div>

        <div className="filter-group">
          <label htmlFor="city">City</label>
          <select
            id="city"
            value={filters.selectedCity}
            onChange={(e) => updateFilter('selectedCity', e.target.value)}
          >
            <option value="">All Cities</option>
            {cities.map(city => (
              <option key={city} value={city}>{city}</option>
            ))}
          </select>
        </div>

        <div className="filter-group">
          <label htmlFor="type">Property Type</label>
          <select
            id="type"
            value={filters.selectedType}
            onChange={(e) => updateFilter('selectedType', e.target.value)}
          >
            <option value="">All Types</option>
            {propertyTypes.map(type => (
              <option key={type} value={type}>{type}</option>
            ))}
          </select>
        </div>

        <div className="filter-group">
          <label htmlFor="minValue">Min Appraised Value</label>
          <input
            id="minValue"
            type="number"
            placeholder="0"
            value={filters.minValue}
            onChange={(e) => updateFilter('minValue', e.target.value)}
          />
        </div>

        <div className="filter-group">
          <label htmlFor="maxValue">Max Appraised Value</label>
          <input
            id="maxValue"
            type="number"
            placeholder="No limit"
            value={filters.maxValue}
            onChange={(e) => updateFilter('maxValue', e.target.value)}
          />
        </div>
      </div>
    </div>
  );
}

export default Filters;
</file>

<file path="components/PropertySearch.css">
.property-search {
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.search-hero {
  padding: 4rem 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

.search-header {
  text-align: center;
  margin-bottom: 3rem;
}

.search-header h1 {
  font-size: 3.5rem;
  font-weight: 800;
  color: white;
  margin: 0 0 1rem 0;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.subtitle {
  font-size: 1.25rem;
  color: rgba(255, 255, 255, 0.9);
  margin: 0;
}

.search-container {
  max-width: 800px;
  margin: 0 auto;
}

.search-box {
  display: flex;
  align-items: center;
  background: white;
  border-radius: 16px;
  padding: 8px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.search-box:focus-within {
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
  transform: translateY(-2px);
}

.search-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 1rem;
  color: #667eea;
}

.search-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 1.125rem;
  padding: 1rem 0.5rem;
  color: #1a202c;
}

.search-input::placeholder {
  color: #a0aec0;
}

.search-button {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 1rem 2rem;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  white-space: nowrap;
}

.search-button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
}

.search-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.example-queries {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  margin-top: 1.5rem;
  align-items: center;
}

.example-label {
  color: rgba(255, 255, 255, 0.9);
  font-weight: 500;
  margin-right: 0.5rem;
}

.example-chip {
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.example-chip:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.example-chip:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.search-explanation {
  background: white;
  padding: 1rem 1.5rem;
  border-radius: 12px;
  margin: 2rem auto;
  max-width: 1200px;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.explanation-icon {
  color: #667eea;
  display: flex;
}

.result-count {
  margin-left: auto;
  color: #718096;
  font-weight: 500;
}

.error-message {
  background: #fed7d7;
  color: #c53030;
  padding: 1rem 1.5rem;
  border-radius: 12px;
  margin: 2rem auto;
  max-width: 1200px;
}

.results-section {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem 4rem;
}

.results-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.property-card {
  background: white;
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.property-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.property-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
  margin-bottom: 1rem;
}

.property-owner {
  font-size: 1.25rem;
  font-weight: 700;
  color: #1a202c;
  margin: 0;
  flex: 1;
}

.property-type-badge {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
  white-space: nowrap;
}

.property-address {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: #718096;
  font-size: 0.9375rem;
  margin-bottom: 1.25rem;
}

.property-details {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.detail-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  background: #f7fafc;
  border-radius: 8px;
}

.detail-label {
  font-size: 0.875rem;
  color: #718096;
  font-weight: 500;
}

.detail-value {
  font-weight: 700;
  color: #1a202c;
}

.detail-value.mono {
  font-family: 'Courier New', monospace;
  font-size: 0.875rem;
}

.load-more {
  text-align: center;
  padding: 2rem 0;
}

.load-more p {
  color: white;
  margin-bottom: 1rem;
}

.load-more-button {
  background: white;
  color: #667eea;
  border: none;
  padding: 0.875rem 2rem;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.load-more-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 16px rgba(255, 255, 255, 0.2);
}

.no-results {
  text-align: center;
  padding: 4rem 2rem;
  color: white;
}

.no-results svg {
  opacity: 0.5;
  margin-bottom: 1rem;
}

.no-results h3 {
  font-size: 1.5rem;
  margin: 0 0 0.5rem 0;
}

.no-results p {
  color: rgba(255, 255, 255, 0.8);
  margin: 0;
}

@media (max-width: 768px) {
  .search-header h1 {
    font-size: 2.5rem;
  }

  .search-box {
    flex-direction: column;
    gap: 0.5rem;
  }

  .search-input {
    width: 100%;
  }

  .search-button {
    width: 100%;
  }

  .results-grid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="components/PropertySearch.tsx">
import { useState, useMemo } from 'react';
import { Property } from '../types';
import { getApiBaseUrl } from '../lib/api-config';
import './PropertySearch.css';

interface SearchResult {
  data: Property[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  };
  query?: {
    original: string;
    explanation: string;
  };
}

export default function PropertySearch() {
  // Load API URL from secure server-passed configuration
  const apiBaseUrl = useMemo(() => getApiBaseUrl(), []);

  const [searchQuery, setSearchQuery] = useState('');
  const [results, setResults] = useState<Property[]>([]);
  const [loading, setLoading] = useState(false);
  const [explanation, setExplanation] = useState('');
  const [error, setError] = useState('');
  const [totalResults, setTotalResults] = useState(0);

  const exampleQueries = [
    'properties in Austin worth over $500k',
    'commercial properties owned by Smith',
    'show me the most expensive residential properties',
    'properties on Congress Ave',
    'find properties appraised between $300k and $600k',
  ];

  const handleSearch = async (query?: string) => {
    const searchText = query || searchQuery;
    if (!searchText.trim()) return;

    setLoading(true);
    setError('');

    try {
      const response = await fetch(`${apiBaseUrl}/properties/search`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query: searchText, limit: 50 }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: 'Search failed' }));
        throw new Error(errorData.message || 'Search failed');
      }

      const data: SearchResult = await response.json();

      if (!data || !data.data || !data.pagination) {
        throw new Error('Received invalid data from server');
      }

      setResults(data.data);
      setTotalResults(data.pagination.total);
      setExplanation(data.query?.explanation || '');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      setResults([]);
    } finally {
      setLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };

  return (
    <div className="property-search">
      <div className="search-hero">
        <div className="search-header">
          <h1>TCAD Property Explorer</h1>
          <p className="subtitle">Search 122,000+ Travis County properties using natural language</p>
        </div>

        <div className="search-container">
          <div className="search-box">
            <div className="search-icon">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <circle cx="11" cy="11" r="8" />
                <path d="m21 21-4.35-4.35" />
              </svg>
            </div>
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Ask anything... e.g., 'properties in Austin worth over $500k'"
              className="search-input"
              disabled={loading}
            />
            <button
              onClick={() => handleSearch()}
              disabled={loading || !searchQuery.trim()}
              className="search-button"
            >
              {loading ? 'Searching...' : 'Search'}
            </button>
          </div>

          <div className="example-queries">
            <span className="example-label">Try:</span>
            {exampleQueries.map((example, idx) => (
              <button
                key={idx}
                onClick={() => {
                  setSearchQuery(example);
                  handleSearch(example);
                }}
                className="example-chip"
                disabled={loading}
              >
                {example}
              </button>
            ))}
          </div>
        </div>
      </div>

      {explanation && (
        <div className="search-explanation">
          <div className="explanation-icon">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M9 18l6-6-6-6" />
            </svg>
          </div>
          <span>{explanation}</span>
          <span className="result-count">({totalResults} results)</span>
        </div>
      )}

      {error && (
        <div className="error-message">
          <strong>Error:</strong> {error}
        </div>
      )}

      {results.length > 0 && (
        <div className="results-section">
          <div className="results-grid">
            {results.map((property) => (
              <div key={property.id} className="property-card">
                <div className="property-header">
                  <h3 className="property-owner">{property.name}</h3>
                  <span className="property-type-badge">{property.prop_type}</span>
                </div>
                <div className="property-address">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" />
                    <circle cx="12" cy="10" r="3" />
                  </svg>
                  {property.property_address}
                  {property.city && `, ${property.city}`}
                </div>
                <div className="property-details">
                  <div className="detail-item">
                    <span className="detail-label">Appraised Value</span>
                    <span className="detail-value">{formatCurrency(property.appraised_value)}</span>
                  </div>
                  {property.assessed_value && (
                    <div className="detail-item">
                      <span className="detail-label">Assessed Value</span>
                      <span className="detail-value">{formatCurrency(property.assessed_value)}</span>
                    </div>
                  )}
                  <div className="detail-item">
                    <span className="detail-label">Property ID</span>
                    <span className="detail-value mono">{property.property_id}</span>
                  </div>
                </div>
              </div>
            ))}
          </div>

          {results.length < totalResults && (
            <div className="load-more">
              <p>Showing {results.length} of {totalResults} results</p>
              <button className="load-more-button">Load More</button>
            </div>
          )}
        </div>
      )}

      {!loading && !error && results.length === 0 && searchQuery && (
        <div className="no-results">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <circle cx="11" cy="11" r="8" />
            <path d="m21 21-4.35-4.35" />
          </svg>
          <h3>No properties found</h3>
          <p>Try adjusting your search query or using one of the examples above</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/PropertyTable.css">
.property-table-container {
  max-width: 1200px;
  margin: 0 auto;
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}

.table-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  flex-wrap: wrap;
  gap: 16px;
}

.table-header h2 {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--neutral-800);
}

.table-controls {
  display: flex;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
}

.page-size-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.page-size-control label {
  font-size: 0.875rem;
  color: var(--neutral-600);
  font-weight: 500;
}

.page-size-control select {
  padding: 6px 32px 6px 10px;
  border: 1px solid var(--neutral-300);
  border-radius: 6px;
  font-size: 0.875rem;
  color: var(--neutral-900);
  background-color: white;
  cursor: pointer;
  transition: border-color 0.2s;
}

.page-size-control select:focus {
  outline: none;
  border-color: var(--primary);
}

.results-info {
  font-size: 0.875rem;
  color: var(--neutral-600);
}

.table-wrapper {
  overflow-x: auto;
  margin-bottom: 24px;
  border: 1px solid var(--neutral-200);
  border-radius: 8px;
}

.property-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
}

.property-table thead {
  background-color: var(--neutral-50);
  border-bottom: 2px solid var(--neutral-200);
}

.property-table th {
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: var(--neutral-700);
  white-space: nowrap;
  user-select: none;
}

.property-table th.sortable {
  cursor: pointer;
  transition: background-color 0.2s;
}

.property-table th.sortable:hover {
  background-color: var(--neutral-100);
}

.property-table th.numeric {
  text-align: right;
}

.sort-icon {
  margin-left: 4px;
  color: var(--neutral-400);
  font-size: 0.75rem;
}

.sort-icon.active {
  color: var(--primary);
}

.property-table tbody tr {
  border-bottom: 1px solid var(--neutral-100);
  transition: background-color 0.2s;
}

.property-table tbody tr:hover {
  background-color: var(--neutral-50);
}

.property-table td {
  padding: 16px;
  color: var(--neutral-800);
}

.property-table td.numeric {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

.property-table td.no-data {
  text-align: center;
  padding: 48px 16px;
  color: var(--neutral-500);
  font-style: italic;
}

.owner-name {
  font-weight: 500;
}

.property-type-badge {
  display: inline-block;
  padding: 4px 8px;
  background-color: var(--neutral-100);
  color: var(--neutral-700);
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.property-id {
  font-family: 'Courier New', monospace;
  font-size: 0.8125rem;
  color: var(--neutral-600);
}

.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.page-numbers {
  display: flex;
  gap: 4px;
}

.page-btn {
  padding: 8px 12px;
  border: 1px solid var(--neutral-300);
  background-color: white;
  color: var(--neutral-700);
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 40px;
}

.page-btn:hover:not(:disabled) {
  background-color: var(--neutral-50);
  border-color: var(--neutral-400);
}

.page-btn.active {
  background-color: var(--primary);
  color: white;
  border-color: var(--primary);
}

.page-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@media (max-width: 768px) {
  .property-table-container {
    padding: 16px;
  }

  .table-header {
    flex-direction: column;
    align-items: flex-start;
  }

  .table-controls {
    width: 100%;
    justify-content: space-between;
  }

  .property-table {
    font-size: 0.8125rem;
  }

  .property-table th,
  .property-table td {
    padding: 10px 12px;
  }

  .pagination {
    gap: 4px;
  }

  .page-btn {
    padding: 6px 10px;
    font-size: 0.8125rem;
    min-width: 36px;
  }
}
</file>

<file path="components/PropertyTable.tsx">
import { useState, useMemo } from 'react';
import { Property } from '../types';
import './PropertyTable.css';

interface PropertyTableProps {
  properties: Property[];
}

type SortField = 'name' | 'property_address' | 'city' | 'appraised_value' | 'assessed_value' | 'prop_type';
type SortDirection = 'asc' | 'desc';

function PropertyTable({ properties }: PropertyTableProps) {
  const [sortField, setSortField] = useState<SortField>('appraised_value');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(25);

  const sortedProperties = useMemo(() => {
    const sorted = [...properties].sort((a, b) => {
      let aVal: string | number = a[sortField] ?? '';
      let bVal: string | number = b[sortField] ?? '';

      if (typeof aVal === 'string') aVal = aVal.toLowerCase();
      if (typeof bVal === 'string') bVal = bVal.toLowerCase();

      if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
      if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });

    return sorted;
  }, [properties, sortField, sortDirection]);

  const paginatedProperties = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return sortedProperties.slice(startIndex, startIndex + pageSize);
  }, [sortedProperties, currentPage, pageSize]);

  const totalPages = Math.ceil(sortedProperties.length / pageSize);

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
    setCurrentPage(1);
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const SortIcon = ({ field }: { field: SortField }) => {
    if (sortField !== field) {
      return <span className="sort-icon"></span>;
    }
    return <span className="sort-icon active">{sortDirection === 'asc' ? '' : ''}</span>;
  };

  return (
    <div className="property-table-container">
      <div className="table-header">
        <h2>Property Records</h2>
        <div className="table-controls">
          <div className="page-size-control">
            <label htmlFor="pageSize">Show:</label>
            <select
              id="pageSize"
              value={pageSize}
              onChange={(e) => {
                setPageSize(Number(e.target.value));
                setCurrentPage(1);
              }}
            >
              <option value={10}>10</option>
              <option value={25}>25</option>
              <option value={50}>50</option>
              <option value={100}>100</option>
            </select>
          </div>
          <div className="results-info">
            Showing {paginatedProperties.length > 0 ? (currentPage - 1) * pageSize + 1 : 0} - {Math.min(currentPage * pageSize, sortedProperties.length)} of {sortedProperties.length} properties
          </div>
        </div>
      </div>

      <div className="table-wrapper">
        <table className="property-table">
          <thead>
            <tr>
              <th onClick={() => handleSort('name')} className="sortable">
                Owner Name <SortIcon field="name" />
              </th>
              <th onClick={() => handleSort('property_address')} className="sortable">
                Address <SortIcon field="property_address" />
              </th>
              <th onClick={() => handleSort('city')} className="sortable">
                City <SortIcon field="city" />
              </th>
              <th onClick={() => handleSort('prop_type')} className="sortable">
                Type <SortIcon field="prop_type" />
              </th>
              <th onClick={() => handleSort('appraised_value')} className="sortable numeric">
                Appraised Value <SortIcon field="appraised_value" />
              </th>
              <th onClick={() => handleSort('assessed_value')} className="sortable numeric">
                Assessed Value <SortIcon field="assessed_value" />
              </th>
              <th>Property ID</th>
            </tr>
          </thead>
          <tbody>
            {paginatedProperties.length === 0 ? (
              <tr>
                <td colSpan={7} className="no-data">
                  No properties found matching your filters
                </td>
              </tr>
            ) : (
              paginatedProperties.map((property) => (
                <tr key={property.id}>
                  <td className="owner-name">{property.name}</td>
                  <td>{property.property_address}</td>
                  <td>{property.city || '-'}</td>
                  <td>
                    <span className="property-type-badge">{property.prop_type}</span>
                  </td>
                  <td className="numeric">{formatCurrency(property.appraised_value)}</td>
                  <td className="numeric">{formatCurrency(property.assessed_value)}</td>
                  <td className="property-id">{property.property_id}</td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {totalPages > 1 && (
        <div className="pagination">
          <button
            onClick={() => setCurrentPage(1)}
            disabled={currentPage === 1}
            className="page-btn"
          >
            First
          </button>
          <button
            onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
            disabled={currentPage === 1}
            className="page-btn"
          >
            Previous
          </button>

          <div className="page-numbers">
            {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              let pageNum: number;
              if (totalPages <= 5) {
                pageNum = i + 1;
              } else if (currentPage <= 3) {
                pageNum = i + 1;
              } else if (currentPage >= totalPages - 2) {
                pageNum = totalPages - 4 + i;
              } else {
                pageNum = currentPage - 2 + i;
              }

              return (
                <button
                  key={pageNum}
                  onClick={() => setCurrentPage(pageNum)}
                  className={`page-btn ${currentPage === pageNum ? 'active' : ''}`}
                >
                  {pageNum}
                </button>
              );
            })}
          </div>

          <button
            onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
            disabled={currentPage === totalPages}
            className="page-btn"
          >
            Next
          </button>
          <button
            onClick={() => setCurrentPage(totalPages)}
            disabled={currentPage === totalPages}
            className="page-btn"
          >
            Last
          </button>
        </div>
      )}
    </div>
  );
}

export default PropertyTable;
</file>

<file path="components/README.md">
# components

## Overview

This directory contains 5 code file(s) with extracted schemas.

## Files and Schemas

### `Analytics.tsx` (typescript)

**Classes:**
- `AnalyticsProps` - Line 5

**Functions:**
- `Analytics({ properties })` - Line 9

**Key Imports:** `../types`, `react`

### `Charts.tsx` (typescript)

**Classes:**
- `ChartsProps` - Line 5

**Functions:**
- `Charts({ properties })` - Line 9

**Key Imports:** `../types`, `react`

### `Filters.tsx` (typescript)

**Classes:**
- `FiltersProps` - Line 5

**Functions:**
- `Filters({ properties, onFilterChange })` - Line 10

**Key Imports:** `../types`, `react`

### `PropertyTable.tsx` (typescript)

**Classes:**
- `PropertyTableProps` - Line 5

**Functions:**
- `PropertyTable({ properties })` - Line 12

**Key Imports:** `../types`, `react`

### `ScrapeManager.tsx` (typescript)

**Classes:**
- `ScrapeManagerProps` - Line 5

**Key Imports:** `../services/api.service`, `react`

---
*Generated by Schema Generator*
</file>

<file path="components/ScrapeManager.css">
.scrape-manager {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.scrape-input-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  margin-bottom: 24px;
}

.scrape-input-section h2 {
  margin: 0 0 20px 0;
  color: #1f2937;
  font-size: 24px;
}

.search-controls {
  display: flex;
  gap: 12px;
  align-items: center;
}

.search-input {
  flex: 1;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.2s;
}

.search-input:focus {
  outline: none;
  border-color: #3b82f6;
}

.search-input:disabled {
  background-color: #f3f4f6;
  cursor: not-allowed;
}

.scrape-button {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.scrape-button.primary {
  background: #3b82f6;
  color: white;
}

.scrape-button.primary:hover:not(:disabled) {
  background: #2563eb;
}

.scrape-button.secondary {
  background: #10b981;
  color: white;
}

.scrape-button.secondary:hover:not(:disabled) {
  background: #059669;
}

.scrape-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.error-message {
  margin-top: 12px;
  padding: 12px;
  background: #fee2e2;
  color: #dc2626;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.job-status-card {
  margin-top: 20px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}

.job-status-card h3 {
  margin: 0 0 12px 0;
  font-size: 18px;
  color: #374151;
}

.status-info {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.status-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 16px;
  color: white;
  font-size: 12px;
  font-weight: 600;
  text-align: center;
  width: fit-content;
}

.status-badge.small {
  padding: 2px 8px;
  font-size: 11px;
}

.progress-bar-container {
  position: relative;
  height: 24px;
  background: #e5e7eb;
  border-radius: 12px;
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6, #2563eb);
  transition: width 0.3s ease;
}

.progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: 600;
  color: #1f2937;
}

.result-count {
  font-size: 16px;
  color: #059669;
  font-weight: 600;
}

.job-error {
  padding: 8px 12px;
  background: #fee2e2;
  color: #dc2626;
  border-radius: 6px;
  font-size: 14px;
}

.scrape-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
}

.tab-button {
  padding: 10px 20px;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s;
}

.tab-button:hover {
  border-color: #3b82f6;
  color: #3b82f6;
}

.tab-button.active {
  background: #3b82f6;
  color: white;
  border-color: #3b82f6;
}

.history-section,
.monitored-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.history-section h3,
.monitored-section h3 {
  margin: 0 0 20px 0;
  color: #1f2937;
  font-size: 20px;
}

.no-data {
  text-align: center;
  color: #9ca3af;
  padding: 40px;
  font-size: 16px;
}

.history-list,
.monitored-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.history-item,
.monitored-item {
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}

.history-header,
.monitored-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.search-term {
  font-weight: 600;
  color: #1f2937;
  font-size: 16px;
}

.frequency-badge {
  padding: 4px 12px;
  background: #6366f1;
  color: white;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 600;
}

.history-details,
.monitored-details {
  display: flex;
  gap: 16px;
  font-size: 14px;
  color: #6b7280;
}

.history-error {
  margin-top: 8px;
  padding: 8px;
  background: #fee2e2;
  color: #dc2626;
  border-radius: 4px;
  font-size: 13px;
}

@media (max-width: 768px) {
  .search-controls {
    flex-direction: column;
  }

  .search-input {
    width: 100%;
  }

  .scrape-button {
    width: 100%;
  }

  .history-details,
  .monitored-details {
    flex-direction: column;
    gap: 4px;
  }
}
</file>

<file path="components/ScrapeManager.tsx">
import React, { useState, useEffect } from 'react';
import { propertyAPI, JobStatus, ScrapeHistory, MonitoredSearch } from '../services/api.service';
import './ScrapeManager.css';
import logger from '../lib/logger';

interface ScrapeManagerProps {
  onScrapeComplete?: () => void;
}

export const ScrapeManager: React.FC<ScrapeManagerProps> = ({ onScrapeComplete }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [currentJob, setCurrentJob] = useState<JobStatus | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [scrapeHistory, setScrapeHistory] = useState<ScrapeHistory[]>([]);
  const [monitoredSearches, setMonitoredSearches] = useState<MonitoredSearch[]>([]);
  const [showHistory, setShowHistory] = useState(false);
  const [showMonitored, setShowMonitored] = useState(false);

  useEffect(() => {
    loadScrapeHistory();
    loadMonitoredSearches();
  }, []);

  const loadScrapeHistory = async () => {
    try {
      const response = await propertyAPI.getScrapeHistory(10, 0);
      setScrapeHistory(response.data);
    } catch (err) {
      logger.error('Failed to load scrape history:', err);
    }
  };

  const loadMonitoredSearches = async () => {
    try {
      const searches = await propertyAPI.getMonitoredSearches();
      setMonitoredSearches(searches);
    } catch (err) {
      logger.error('Failed to load monitored searches:', err);
    }
  };

  const handleScrape = async () => {
    if (!searchTerm.trim()) {
      setError('Please enter a search term');
      return;
    }

    setLoading(true);
    setError(null);
    setCurrentJob(null);

    try {
      // Trigger the scrape job
      const { jobId } = await propertyAPI.triggerScrape(searchTerm);

      // Poll for job status
      const finalStatus = await propertyAPI.pollJobStatus(
        jobId,
        (status) => {
          setCurrentJob(status);
        }
      );

      if (finalStatus.status === 'completed') {
        setError(null);
        if (onScrapeComplete) {
          onScrapeComplete();
        }
        // Reload history
        await loadScrapeHistory();
      } else if (finalStatus.status === 'failed') {
        setError(finalStatus.error || 'Scraping failed');
      }
    } catch (err: any) {
      setError(err.response?.data?.error || err.message || 'Failed to start scraping');
    } finally {
      setLoading(false);
    }
  };

  const handleAddMonitored = async () => {
    if (!searchTerm.trim()) {
      setError('Please enter a search term');
      return;
    }

    try {
      await propertyAPI.addMonitoredSearch(searchTerm, 'daily');
      await loadMonitoredSearches();
      setSearchTerm('');
      setError(null);
    } catch (err: any) {
      setError(err.response?.data?.error || 'Failed to add monitored search');
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed':
        return '#10b981';
      case 'failed':
        return '#ef4444';
      case 'processing':
      case 'active':
        return '#3b82f6';
      default:
        return '#6b7280';
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };

  return (
    <div className="scrape-manager">
      <div className="scrape-input-section">
        <h2>Property Search & Scraping</h2>
        <div className="search-controls">
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleScrape()}
            placeholder="Enter search term (e.g., owner name, address)"
            className="search-input"
            disabled={loading}
          />
          <button
            onClick={handleScrape}
            disabled={loading || !searchTerm.trim()}
            className="scrape-button primary"
          >
            {loading ? 'Scraping...' : 'Start Scraping'}
          </button>
          <button
            onClick={handleAddMonitored}
            disabled={loading || !searchTerm.trim()}
            className="scrape-button secondary"
            title="Add to daily monitoring"
          >
            Monitor Daily
          </button>
        </div>

        {error && (
          <div className="error-message">
            <span> {error}</span>
          </div>
        )}

        {currentJob && (
          <div className="job-status-card">
            <h3>Current Job Status</h3>
            <div className="status-info">
              <div className="status-badge" style={{ backgroundColor: getStatusColor(currentJob.status) }}>
                {currentJob.status.toUpperCase()}
              </div>
              {currentJob.progress !== undefined && currentJob.progress > 0 && (
                <div className="progress-bar-container">
                  <div
                    className="progress-bar-fill"
                    style={{ width: `${currentJob.progress}%` }}
                  />
                  <span className="progress-text">{currentJob.progress}%</span>
                </div>
              )}
              {currentJob.resultCount !== undefined && (
                <div className="result-count">
                  Found {currentJob.resultCount} properties
                </div>
              )}
              {currentJob.error && (
                <div className="job-error">
                  Error: {currentJob.error}
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      <div className="scrape-tabs">
        <button
          className={`tab-button ${showHistory ? 'active' : ''}`}
          onClick={() => {
            setShowHistory(!showHistory);
            setShowMonitored(false);
          }}
        >
          Recent Scrapes ({scrapeHistory.length})
        </button>
        <button
          className={`tab-button ${showMonitored ? 'active' : ''}`}
          onClick={() => {
            setShowMonitored(!showMonitored);
            setShowHistory(false);
          }}
        >
          Monitored Searches ({monitoredSearches.length})
        </button>
      </div>

      {showHistory && (
        <div className="history-section">
          <h3>Recent Scrape History</h3>
          {scrapeHistory.length === 0 ? (
            <p className="no-data">No scraping history yet</p>
          ) : (
            <div className="history-list">
              {scrapeHistory.map((job) => (
                <div key={job.id} className="history-item">
                  <div className="history-header">
                    <span className="search-term">{job.searchTerm}</span>
                    <span
                      className="status-badge small"
                      style={{ backgroundColor: getStatusColor(job.status) }}
                    >
                      {job.status}
                    </span>
                  </div>
                  <div className="history-details">
                    <span>Started: {formatDate(job.startedAt)}</span>
                    {job.resultCount !== null && (
                      <span>Results: {job.resultCount}</span>
                    )}
                    {job.completedAt && (
                      <span>Completed: {formatDate(job.completedAt)}</span>
                    )}
                  </div>
                  {job.error && (
                    <div className="history-error">Error: {job.error}</div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      {showMonitored && (
        <div className="monitored-section">
          <h3>Monitored Searches</h3>
          {monitoredSearches.length === 0 ? (
            <p className="no-data">No monitored searches configured</p>
          ) : (
            <div className="monitored-list">
              {monitoredSearches.map((search) => (
                <div key={search.id} className="monitored-item">
                  <div className="monitored-header">
                    <span className="search-term">{search.searchTerm}</span>
                    <span className="frequency-badge">{search.frequency}</span>
                  </div>
                  <div className="monitored-details">
                    {search.lastRun && (
                      <span>Last run: {formatDate(search.lastRun)}</span>
                    )}
                    <span>Added: {formatDate(search.createdAt)}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default ScrapeManager;
</file>

<file path="hooks/index.ts">
export { useFormatting } from './useFormatting';
export { usePropertySearch } from './usePropertySearch';
export { usePagination } from './usePagination';
export { useDebounce } from './useDebounce';
export { useAnalytics } from './useAnalytics';
</file>

<file path="hooks/README_ENHANCED.md">
# hooks

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "hooks",
  "description": "Directory containing 4 code files with 4 classes and 2 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions",
    "2 function definitions"
  ]
}
</script>

## Overview

This directory contains 4 code file(s) with extracted schemas.

## Files and Schemas

### `useAnalytics.ts` (typescript)

**Functions:**
- `useAnalytics()` - Line 16

### `useFormatting.ts` (typescript)

**Functions:**
- `useFormatting()` - Line 13

### `usePagination.ts` (typescript)

**Classes:**
- `UsePaginationProps` - Line 2
- `UsePaginationReturn` - Line 8

### `usePropertySearch.ts` (typescript)

**Classes:**
- `SearchResult` - Line 4
- `UsePropertySearchReturn` - Line 18

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="hooks/useAnalytics.ts">
/**
 * React hook for analytics tracking
 */
import { useCallback } from 'react';
import {
  trackEvent,
  trackSearch,
  trackExampleQueryClick,
  trackSearchResults,
  trackPropertyView,
  trackPageView,
  trackError,
  trackConversion,
  type AnalyticsEvent,
} from '../lib/analytics';

export const useAnalytics = () => {
  const track = useCallback((event: AnalyticsEvent) => {
    trackEvent(event);
  }, []);

  const logSearch = useCallback((query: string, resultsCount?: number) => {
    trackSearch(query, resultsCount);
  }, []);

  const logExampleQueryClick = useCallback((query: string) => {
    trackExampleQueryClick(query);
  }, []);

  const logSearchResults = useCallback(
    (query: string, resultsCount: number, hasExplanation: boolean) => {
      trackSearchResults(query, resultsCount, hasExplanation);
    },
    []
  );

  const logPropertyView = useCallback((propertyId: string, propertyAddress?: string) => {
    trackPropertyView(propertyId, propertyAddress);
  }, []);

  const logError = useCallback((errorMessage: string, errorContext?: string) => {
    trackError(errorMessage, errorContext);
  }, []);

  const logConversion = useCallback((conversionType: string, value?: number) => {
    trackConversion(conversionType, value);
  }, []);

  const logPageView = useCallback((path: string, title?: string) => {
    trackPageView(path, title);
  }, []);

  return {
    track,
    logSearch,
    logExampleQueryClick,
    logSearchResults,
    logPropertyView,
    logPageView,
    logError,
    logConversion,
  };
};
</file>

<file path="hooks/useDebounce.ts">
import { useEffect, useState } from 'react';

/**
 * Hook to debounce a value
 * Useful for search inputs to reduce API calls
 */
export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
</file>

<file path="hooks/useFormatting.ts">
import { useMemo } from 'react';
import {
  formatCurrency,
  formatNumber,
  formatDate,
  formatPropertyType,
  truncateText,
} from '../utils/formatters';

/**
 * Hook providing formatting utilities
 * Consolidates all formatting logic in one place
 */
export const useFormatting = () => {
  return useMemo(
    () => ({
      formatCurrency,
      formatNumber,
      formatDate,
      formatPropertyType,
      truncateText,
    }),
    []
  );
};
</file>

<file path="hooks/usePagination.ts">
import { useState, useMemo, useCallback } from 'react';

interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  initialPage?: number;
}

interface UsePaginationReturn {
  currentPage: number;
  totalPages: number;
  itemsPerPage: number;
  startIndex: number;
  endIndex: number;
  canGoNext: boolean;
  canGoPrev: boolean;
  goToPage: (page: number) => void;
  goToNextPage: () => void;
  goToPrevPage: () => void;
  goToFirstPage: () => void;
  goToLastPage: () => void;
}

/**
 * Hook for pagination logic
 * Handles page navigation and calculations
 */
export const usePagination = ({
  totalItems,
  itemsPerPage,
  initialPage = 1,
}: UsePaginationProps): UsePaginationReturn => {
  const [currentPage, setCurrentPage] = useState(initialPage);

  const totalPages = useMemo(
    () => Math.ceil(totalItems / itemsPerPage),
    [totalItems, itemsPerPage]
  );

  const startIndex = useMemo(
    () => (currentPage - 1) * itemsPerPage,
    [currentPage, itemsPerPage]
  );

  const endIndex = useMemo(
    () => Math.min(startIndex + itemsPerPage, totalItems),
    [startIndex, itemsPerPage, totalItems]
  );

  const canGoNext = useMemo(
    () => currentPage < totalPages,
    [currentPage, totalPages]
  );

  const canGoPrev = useMemo(() => currentPage > 1, [currentPage]);

  const goToPage = useCallback(
    (page: number) => {
      const pageNumber = Math.max(1, Math.min(page, totalPages));
      setCurrentPage(pageNumber);
    },
    [totalPages]
  );

  const goToNextPage = useCallback(() => {
    if (canGoNext) {
      setCurrentPage((prev) => prev + 1);
    }
  }, [canGoNext]);

  const goToPrevPage = useCallback(() => {
    if (canGoPrev) {
      setCurrentPage((prev) => prev - 1);
    }
  }, [canGoPrev]);

  const goToFirstPage = useCallback(() => {
    setCurrentPage(1);
  }, []);

  const goToLastPage = useCallback(() => {
    setCurrentPage(totalPages);
  }, [totalPages]);

  return {
    currentPage,
    totalPages,
    itemsPerPage,
    startIndex,
    endIndex,
    canGoNext,
    canGoPrev,
    goToPage,
    goToNextPage,
    goToPrevPage,
    goToFirstPage,
    goToLastPage,
  };
};
</file>

<file path="hooks/usePropertySearch.ts">
import { useState, useCallback } from 'react';
import { Property } from '../types';
import { getApiBaseUrl } from '../lib/api-config';

interface SearchResult {
  data: Property[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  };
  query?: {
    original: string;
    explanation: string;
  };
}

interface UsePropertySearchReturn {
  results: Property[];
  loading: boolean;
  error: string;
  totalResults: number;
  explanation: string;
  search: (query: string, limit?: number) => Promise<void>;
  clearResults: () => void;
}

/**
 * Hook for property search functionality
 * Handles API calls, loading states, and error handling
 */
export const usePropertySearch = (): UsePropertySearchReturn => {
  const [results, setResults] = useState<Property[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [totalResults, setTotalResults] = useState(0);
  const [explanation, setExplanation] = useState('');

  const search = useCallback(async (query: string, limit = 50) => {
    if (!query.trim()) return;

    setLoading(true);
    setError('');

    try {
      const apiBaseUrl = getApiBaseUrl();
      const response = await fetch(`${apiBaseUrl}/properties/search`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query, limit }),
      });

      if (!response.ok) {
        const errorData = await response
          .json()
          .catch(() => ({ message: 'Search failed' }));
        throw new Error(errorData.message || 'Search failed');
      }

      const data: SearchResult = await response.json();

      if (!data || !data.data || !data.pagination) {
        throw new Error('Received invalid data from server');
      }

      setResults(data.data);
      setTotalResults(data.pagination.total);
      setExplanation(data.query?.explanation || '');
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An error occurred';
      setError(errorMessage);
      setResults([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const clearResults = useCallback(() => {
    setResults([]);
    setError('');
    setExplanation('');
    setTotalResults(0);
  }, []);

  return {
    results,
    loading,
    error,
    totalResults,
    explanation,
    search,
    clearResults,
  };
};
</file>

<file path="lib/__tests__/api-config.test.ts">
/**
 * API Configuration Tests
 * Tests the API URL resolution fallback chain to prevent production errors
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { getApiBaseUrl } from '../api-config';
import { DataController } from '../xcontroller.client';
import logger from './logger';

// Mock the xcontroller module
jest.mock('../xcontroller.client', () => ({
  dataController: {
    loadData: jest.fn(),
  },
}));

describe('API Configuration', () => {
  let mockLoadData: jest.MockedFunction<typeof DataController.prototype.loadData>;
  let originalEnv: any;

  beforeEach(() => {
    // Store original import.meta.env
    originalEnv = { ...import.meta.env };

    // Get mocked loadData
    mockLoadData = (require('../xcontroller.client').dataController.loadData as jest.MockedFunction<typeof DataController.prototype.loadData>);

    // Reset all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Restore original environment
    Object.assign(import.meta.env, originalEnv);
  });

  describe('getApiBaseUrl', () => {
    test('should prioritize VITE_API_URL (for static deployments)', () => {
      // Mock VITE_API_URL environment variable
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      // Mock xcontroller returning server config (should be ignored)
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Should use VITE_API_URL, not xcontroller
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should NOT call loadData when VITE_API_URL is available
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should fall back to server-passed config when VITE_API_URL is unavailable', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning server config
      mockLoadData.mockReturnValue({
        apiUrl: 'https://api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should fall back to /api for local development when both sources are unavailable', () => {
      // Mock xcontroller returning null
      mockLoadData.mockReturnValue(null);

      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should handle empty string from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data with empty apiUrl
      mockLoadData.mockReturnValue({
        apiUrl: '',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      // Empty string is falsy, should fall back to /api
      expect(apiUrl).toBe('/api');
    });

    test('should handle undefined apiUrl from xcontroller when VITE_API_URL is not set', () => {
      // Ensure VITE_API_URL is not set
      delete (import.meta.env as any).VITE_API_URL;

      // Mock xcontroller returning data without apiUrl property
      mockLoadData.mockReturnValue({
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      } as any);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
    });

    test('should use production API URL from environment variable', () => {
      // This test simulates GitHub Pages deployment
      mockLoadData.mockReturnValue(null);
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
    });

    test('should preserve URL format from xcontroller', () => {
      // Test with various URL formats
      const testUrls = [
        'https://api.example.com',
        'https://api.example.com:8080',
        'https://api.example.com/v1',
        'http://localhost:3001',
        '/api',
      ];

      testUrls.forEach(url => {
        mockLoadData.mockReturnValue({
          apiUrl: url,
          environment: 'test',
          features: { search: true, analytics: true, monitoring: true },
          version: '1.0.0',
        });

        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });

    test('should preserve URL format from VITE_API_URL', () => {
      mockLoadData.mockReturnValue(null);

      const testUrls = [
        'https://api.example.com',
        'http://localhost:3001/api',
        '/api',
      ];

      testUrls.forEach(url => {
        (import.meta.env as any).VITE_API_URL = url;
        const apiUrl = getApiBaseUrl();
        expect(apiUrl).toBe(url);
      });
    });
  });

  describe('Error Prevention', () => {
    test('REGRESSION: should not return relative /api when VITE_API_URL is set', () => {
      // This is the bug that caused the production issue
      // The component was falling back to '/api' instead of using VITE_API_URL

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Must NOT be '/api' when VITE_API_URL is available
      expect(apiUrl).not.toBe('/api');
      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not even call loadData when VITE_API_URL is set
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should work in GitHub Pages deployment scenario', () => {
      // Simulates exact production environment:
      // - No xcontroller data (static HTML)
      // - VITE_API_URL set during build

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Should resolve to production API, not relative path
      expect(apiUrl).toBe('https://api.alephatx.info');
      expect(apiUrl).toMatch(/^https:\/\//);
      // Should not call loadData to avoid console errors
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('REGRESSION: should not log console errors in static builds', () => {
      // This test ensures we don't call loadData when VITE_API_URL is available
      // Previously caused "[DataController] Script tag with id 'initial-data' not found" error

      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      // Verify the xcontroller was never called (preventing logger.error)
      expect(mockLoadData).not.toHaveBeenCalled();
      expect(apiUrl).toBe('https://api.alephatx.info');
    });
  });

  describe('Integration Scenarios', () => {
    test('should work in server-side rendered scenario (no VITE_API_URL)', () => {
      // SSR scenarios don't set VITE_API_URL
      delete (import.meta.env as any).VITE_API_URL;

      mockLoadData.mockReturnValue({
        apiUrl: 'https://ssr-api.example.com',
        environment: 'production',
        features: { search: true, analytics: true, monitoring: true },
        version: '1.0.0',
      });

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://ssr-api.example.com');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });

    test('should work in static site scenario (GitHub Pages)', () => {
      (import.meta.env as any).VITE_API_URL = 'https://api.alephatx.info';

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('https://api.alephatx.info');
      // Should not call loadData in static builds
      expect(mockLoadData).not.toHaveBeenCalled();
    });

    test('should work in local development scenario', () => {
      delete (import.meta.env as any).VITE_API_URL;
      mockLoadData.mockReturnValue(null);

      const apiUrl = getApiBaseUrl();

      expect(apiUrl).toBe('/api');
      expect(mockLoadData).toHaveBeenCalledWith('initial-data');
    });
  });
});
</file>

<file path="lib/__tests__/README_ENHANCED.md">
# __tests__

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "__tests__",
  "description": "Directory containing 1 code files with 1 classes and 1 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions",
    "1 function definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `xcontroller.client.test.ts` (typescript)

**Classes:**
- `AppConfig` - Line 294

**Functions:**
- `createScript()` - Line 230

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="lib/__tests__/xcontroller.client.test.ts">
/**
 * XController Client Tests
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { DataController } from '../xcontroller.client';

describe('DataController', () => {
  let controller: DataController;
  let scriptElement: HTMLScriptElement;

  beforeEach(() => {
    controller = new DataController(true); // debug mode
    // Clean up any existing test elements
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  afterEach(() => {
    // Clean up after each test
    document.querySelectorAll('[id^="test-"]').forEach(el => el.remove());
  });

  describe('loadData', () => {
    test('should load data from valid JSON script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-data';
      scriptElement.textContent = JSON.stringify({ test: 'value', number: 123 });
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ test: string; number: number }>('test-data');

      expect(data).not.toBeNull();
      expect(data?.test).toBe('value');
      expect(data?.number).toBe(123);
    });

    test('should return null for non-existent script tag', () => {
      const data = controller.loadData('non-existent');
      expect(data).toBeNull();
    });

    test('should return null for wrong type attribute', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'text/javascript';
      scriptElement.id = 'test-wrong-type';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-wrong-type');
      expect(data).toBeNull();
    });

    test('should return null for invalid JSON', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-invalid';
      scriptElement.textContent = 'not valid json {]';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-invalid');
      expect(data).toBeNull();
    });

    test('should cache loaded data', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-cache';
      scriptElement.textContent = JSON.stringify({ cached: true });
      document.body.appendChild(scriptElement);

      const data1 = controller.loadData('test-cache');
      const data2 = controller.loadData('test-cache');

      expect(data1).toBe(data2); // Same reference = cached
      expect(controller.getCacheSize()).toBe(1);
    });

    test('should handle empty script tag', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-empty';
      scriptElement.textContent = '';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-empty');
      expect(data).toBeNull();
    });

    test('should handle null values', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-null';
      scriptElement.textContent = 'null';
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-null');
      expect(data).toBeNull(); // null is not valid (fails validation)
    });

    test('should handle arrays', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-array';
      scriptElement.textContent = JSON.stringify([1, 2, 3]);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<number[]>('test-array');
      expect(Array.isArray(data)).toBe(true);
      expect(data).toEqual([1, 2, 3]);
    });

    test('should handle complex nested objects', () => {
      const complexData = {
        user: { id: 1, name: 'John', roles: ['admin', 'user'] },
        config: { theme: 'dark', features: { analytics: true } },
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-complex';
      scriptElement.textContent = JSON.stringify(complexData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof complexData>('test-complex');
      expect(data).toEqual(complexData);
    });

    test('should handle unicode and special characters', () => {
      const unicodeData = {
        text: 'Hello ',
        emoji: '',
        escaped: 'Line 1\nLine 2',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-unicode';
      scriptElement.textContent = JSON.stringify(unicodeData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof unicodeData>('test-unicode');
      expect(data).toEqual(unicodeData);
    });
  });

  describe('loadDataWithFallback', () => {
    beforeEach(() => {
      // Mock fetch
      global.fetch = jest.fn();
    });

    test('should use script tag data first', async () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-fallback';
      scriptElement.textContent = JSON.stringify({ source: 'script' });
      document.body.appendChild(scriptElement);

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'test-fallback',
        '/api/fallback'
      );

      expect(data?.source).toBe('script');
      expect(global.fetch).not.toHaveBeenCalled();
    });

    test('should fallback to API when script tag missing', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ source: 'api' }),
      });

      const data = await controller.loadDataWithFallback<{ source: string }>(
        'non-existent',
        '/api/fallback'
      );

      expect(data?.source).toBe('api');
      expect(global.fetch).toHaveBeenCalledWith('/api/fallback');
    });

    test('should cache API fallback data', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ cached: true }),
      });

      await controller.loadDataWithFallback('test-api-cache', '/api/data');
      await controller.loadDataWithFallback('test-api-cache', '/api/data');

      expect(global.fetch).toHaveBeenCalledTimes(1); // Only called once
    });

    test('should return null on API error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const data = await controller.loadDataWithFallback('missing', '/api/error');
      expect(data).toBeNull();
    });

    test('should return null on network error', async () => {
      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const data = await controller.loadDataWithFallback('missing', '/api/network-error');
      expect(data).toBeNull();
    });
  });

  describe('cache management', () => {
    test('should clear cache', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-clear';
      scriptElement.textContent = JSON.stringify({ test: 'value' });
      document.body.appendChild(scriptElement);

      controller.loadData('test-clear');
      expect(controller.getCacheSize()).toBe(1);

      controller.clearCache();
      expect(controller.getCacheSize()).toBe(0);
    });

    test('should report correct cache size', () => {
      const createScript = (id: string) => {
        const script = document.createElement('script');
        script.type = 'application/json';
        script.id = id;
        script.textContent = JSON.stringify({ test: id });
        document.body.appendChild(script);
      };

      createScript('test-1');
      createScript('test-2');
      createScript('test-3');

      controller.loadData('test-1');
      expect(controller.getCacheSize()).toBe(1);

      controller.loadData('test-2');
      expect(controller.getCacheSize()).toBe(2);

      controller.loadData('test-3');
      expect(controller.getCacheSize()).toBe(3);
    });
  });

  describe('XSS Prevention', () => {
    test('should safely parse data with script tags', () => {
      const xssData = {
        payload: '<script>alert("xss")</script>',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-xss';
      scriptElement.textContent = JSON.stringify(xssData);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<typeof xssData>('test-xss');

      // Data should be parsed, but not executed
      expect(data?.payload).toBe('<script>alert("xss")</script>');

      // No actual script execution should occur
      const scripts = document.querySelectorAll('script[src*="alert"]');
      expect(scripts.length).toBe(0);
    });

    test('should handle encoded dangerous characters', () => {
      // Data as it would come from server with proper encoding
      const encodedData = '{"html":"\\u003Cscript\\u003Ealert(\\"xss\\")\\u003C/script\\u003E"}';

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-encoded';
      scriptElement.textContent = encodedData;
      document.body.appendChild(scriptElement);

      const data = controller.loadData<{ html: string }>('test-encoded');

      // Should decode properly
      expect(data?.html).toBe('<script>alert("xss")</script>');
    });
  });

  describe('Type Safety', () => {
    test('should preserve type information', () => {
      interface AppConfig {
        apiUrl: string;
        features: {
          analytics: boolean;
          search: boolean;
        };
        version: string;
      }

      const config: AppConfig = {
        apiUrl: '/api',
        features: { analytics: true, search: true },
        version: '1.0.0',
      };

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-typed';
      scriptElement.textContent = JSON.stringify(config);
      document.body.appendChild(scriptElement);

      const data = controller.loadData<AppConfig>('test-typed');

      expect(data).toBeTruthy();
      expect(data!.apiUrl).toBe('/api');
      expect(data!.features.analytics).toBe(true);
      expect(typeof data!.version).toBe('string');
    });
  });

  describe('Error Handling', () => {
    test('should log errors in debug mode', () => {
      const consoleError = jest.spyOn(console, 'error').mockImplementation();

      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-error';
      scriptElement.textContent = 'invalid json';
      document.body.appendChild(scriptElement);

      controller.loadData('test-error');

      expect(consoleError).toHaveBeenCalled();
      consoleError.mockRestore();
    });

    test('should handle missing textContent', () => {
      scriptElement = document.createElement('script');
      scriptElement.type = 'application/json';
      scriptElement.id = 'test-no-content';
      // No textContent set
      document.body.appendChild(scriptElement);

      const data = controller.loadData('test-no-content');
      expect(data).toBeNull();
    });
  });
});
</file>

<file path="lib/analytics.ts">
/**
 * Analytics utility functions for tracking user events
 * Integrates with Google Analytics and Meta Pixel
 */

// Extend the Window interface to include tracking functions
declare global {
  interface Window {
    gtag?: (...args: any[]) => void;
    fbq?: (...args: any[]) => void;
    dataLayer?: any[];
  }
}

export type EventCategory =
  | 'search'
  | 'navigation'
  | 'engagement'
  | 'conversion';

export interface AnalyticsEvent {
  category: EventCategory;
  action: string;
  label?: string;
  value?: number;
  metadata?: Record<string, any>;
}

/**
 * Track a custom event to both GA and Meta Pixel
 */
export const trackEvent = (event: AnalyticsEvent): void => {
  const { category, action, label, value, metadata } = event;

  // Google Analytics 4 event
  if (window.gtag) {
    window.gtag('event', action, {
      event_category: category,
      event_label: label,
      value: value,
      ...metadata,
    });
  }

  // Meta Pixel custom event
  if (window.fbq) {
    window.fbq('trackCustom', action, {
      category,
      label,
      value,
      ...metadata,
    });
  }

  // Console log in development
  if (import.meta.env.DEV) {
    console.log('Analytics Event:', { category, action, label, value, metadata });
  }
};

/**
 * Track a search event
 */
export const trackSearch = (query: string, resultsCount?: number): void => {
  trackEvent({
    category: 'search',
    action: 'property_search',
    label: query,
    value: resultsCount,
    metadata: {
      search_term: query,
      results_count: resultsCount,
    },
  });

  // GA search event
  if (window.gtag) {
    window.gtag('event', 'search', {
      search_term: query,
    });
  }

  // Meta Pixel search event
  if (window.fbq) {
    window.fbq('track', 'Search', {
      search_string: query,
      content_category: 'property',
    });
  }
};

/**
 * Track when a user clicks an example query
 */
export const trackExampleQueryClick = (query: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'example_query_clicked',
    label: query,
    metadata: {
      query_text: query,
    },
  });
};

/**
 * Track when search results are displayed
 */
export const trackSearchResults = (
  query: string,
  resultsCount: number,
  hasExplanation: boolean
): void => {
  trackEvent({
    category: 'search',
    action: 'search_results_displayed',
    label: query,
    value: resultsCount,
    metadata: {
      query: query,
      results_count: resultsCount,
      has_explanation: hasExplanation,
    },
  });
};

/**
 * Track when a user views property details
 */
export const trackPropertyView = (propertyId: string, propertyAddress?: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'property_viewed',
    label: propertyAddress || propertyId,
    metadata: {
      property_id: propertyId,
      property_address: propertyAddress,
    },
  });

  // Meta Pixel content view
  if (window.fbq) {
    window.fbq('track', 'ViewContent', {
      content_name: propertyAddress || propertyId,
      content_category: 'property',
      content_ids: [propertyId],
      content_type: 'product',
    });
  }
};

/**
 * Track page view (automatically called on route change)
 */
export const trackPageView = (path: string, title?: string): void => {
  if (window.gtag) {
    window.gtag('config', 'G-J7TL7PQH7S', {
      page_path: path,
      page_title: title,
    });
  }

  if (window.fbq) {
    window.fbq('track', 'PageView');
  }
};

/**
 * Track errors
 */
export const trackError = (errorMessage: string, errorContext?: string): void => {
  trackEvent({
    category: 'engagement',
    action: 'error_occurred',
    label: errorMessage,
    metadata: {
      error_message: errorMessage,
      error_context: errorContext,
    },
  });
};

/**
 * Track custom conversion events
 */
export const trackConversion = (conversionType: string, value?: number): void => {
  trackEvent({
    category: 'conversion',
    action: conversionType,
    value: value,
  });

  // Meta Pixel conversion
  if (window.fbq) {
    window.fbq('track', 'Lead', {
      content_name: conversionType,
      value: value,
      currency: 'USD',
    });
  }
};
</file>

<file path="lib/api-config.ts">
/**
 * API Configuration Utility
 * Handles API URL resolution with proper fallback chain:
 * 1. Server-passed config (xcontroller)
 * 2. Build-time environment variable (VITE_API_URL)
 * 3. Local development fallback (/api)
 */

import { dataController } from './xcontroller.client';

interface InitialAppData {
  apiUrl: string;
  environment: string;
  features: {
    search: boolean;
    analytics: boolean;
    monitoring: boolean;
  };
  version: string;
}

/**
 * Get the API base URL for making requests
 * @returns The API base URL to use for API calls
 */
export function getApiBaseUrl(): string {
  // Priority 1: Build-time environment variable (for static deployments)
  // VITE_API_URL is set in .github/workflows/deploy.yml for GitHub Pages
  // Check this first to avoid console errors in static builds where no script tag exists
  const viteApiUrl = import.meta.env.VITE_API_URL;
  if (viteApiUrl) {
    return viteApiUrl;
  }

  // Priority 2: Server-passed configuration (for SSR scenarios)
  // Only check this if VITE_API_URL isn't set (to avoid console errors in static builds)
  const initialData = dataController.loadData<InitialAppData>('initial-data');
  if (initialData?.apiUrl) {
    return initialData.apiUrl;
  }

  // Priority 3: Local development fallback
  // Uses relative path for local dev server proxy configuration
  return '/api';
}
</file>

<file path="lib/logger.ts">
/**
 * Client-side logger
 *
 * Simple wrapper around console for consistent logging in the browser
 * Can be enhanced later with remote logging, log levels, etc.
 */

const isDevelopment = import.meta.env.DEV;

const logger = {
  info: (...args: any[]) => {
    if (isDevelopment) {
      console.log('[INFO]', ...args);
    }
  },

  error: (...args: any[]) => {
    console.error('[ERROR]', ...args);
  },

  warn: (...args: any[]) => {
    if (isDevelopment) {
      console.warn('[WARN]', ...args);
    }
  },

  debug: (...args: any[]) => {
    if (isDevelopment) {
      console.debug('[DEBUG]', ...args);
    }
  },

  log: (...args: any[]) => {
    if (isDevelopment) {
      console.log(...args);
    }
  }
};

export default logger;
</file>

<file path="lib/README_ENHANCED.md">
# lib

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "lib",
  "description": "Directory containing 3 code files with 4 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions"
  ]
}
</script>

## Overview

This directory contains 3 code file(s) with extracted schemas.

## Subdirectories

- `__tests__/`

## Files and Schemas

### `analytics.ts` (typescript)

**Classes:**
- `Window` - Line 7
- `AnalyticsEvent` - Line 20

### `api-config.ts` (typescript)

**Classes:**
- `InitialAppData` - Line 10

### `xcontroller.client.ts` (typescript)

**Classes:**
- `DataController` - Line 5

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="lib/xcontroller.client.ts">
/**
 * XController Client - Data Controller for loading server-passed data
 * Safely loads and caches JSON data from script tags in the DOM
 */

export class DataController {
  private cache: Map<string, any> = new Map();
  private debug: boolean;

  constructor(debug = false) {
    this.debug = debug;
  }

  /**
   * Load data from a JSON script tag in the DOM
   * @param id - The ID of the script tag containing JSON data
   * @returns The parsed data or null if not found/invalid
   */
  loadData<T = any>(id: string): T | null {
    // Check cache first
    if (this.cache.has(id)) {
      return this.cache.get(id) as T;
    }

    try {
      const scriptElement = document.getElementById(id);

      if (!scriptElement) {
        if (this.debug) {
          console.error(`[DataController] Script tag with id="${id}" not found`);
        }
        return null;
      }

      if (scriptElement.getAttribute('type') !== 'application/json') {
        if (this.debug) {
          console.error(
            `[DataController] Script tag with id="${id}" has wrong type attribute`
          );
        }
        return null;
      }

      const content = scriptElement.textContent;
      if (!content || content.trim() === '') {
        if (this.debug) {
          console.error(`[DataController] Script tag with id="${id}" is empty`);
        }
        return null;
      }

      const data = JSON.parse(content);

      // Validate that data is not null (null is not considered valid)
      if (data === null) {
        if (this.debug) {
          console.error(`[DataController] Data in script tag id="${id}" is null`);
        }
        return null;
      }

      // Cache the parsed data
      this.cache.set(id, data);

      return data as T;
    } catch (error) {
      if (this.debug) {
        console.error(`[DataController] Error loading data from id="${id}":`, error);
      }
      return null;
    }
  }

  /**
   * Load data with API fallback
   * @param id - The ID of the script tag
   * @param fallbackUrl - The API URL to fetch from if script tag is missing
   * @returns The data or null
   */
  async loadDataWithFallback<T = any>(
    id: string,
    fallbackUrl: string
  ): Promise<T | null> {
    // Try loading from script tag first
    const scriptData = this.loadData<T>(id);
    if (scriptData !== null) {
      return scriptData;
    }

    // Check if we already fetched this fallback
    const fallbackCacheKey = `__fallback__${fallbackUrl}`;
    if (this.cache.has(fallbackCacheKey)) {
      return this.cache.get(fallbackCacheKey) as T;
    }

    // Fallback to API
    try {
      const response = await fetch(fallbackUrl);

      if (!response.ok) {
        if (this.debug) {
          console.error(
            `[DataController] API fallback failed: ${response.status} ${response.statusText}`
          );
        }
        return null;
      }

      const data = await response.json();

      // Cache the API response
      this.cache.set(fallbackCacheKey, data);

      return data as T;
    } catch (error) {
      if (this.debug) {
        console.error(`[DataController] Error fetching fallback data:`, error);
      }
      return null;
    }
  }

  /**
   * Clear the cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get the cache size
   */
  getCacheSize(): number {
    return this.cache.size;
  }
}

// Export a singleton instance for convenience
export const dataController = new DataController(import.meta.env.DEV);
</file>

<file path="services/api.service.ts">
import axios, { AxiosInstance } from 'axios';
import { Property } from '../types';
import logger from '../lib/logger';

// API configuration
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';

// Create axios instance with default config
const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 30000,
});



// Request interceptor for auth token (if needed in future)
apiClient.interceptors.request.use(
  (config) => {
    // Add auth token if available
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response) {
      // Handle specific error statuses
      switch (error.response.status) {
        case 401:
          // Handle unauthorized
          localStorage.removeItem('authToken');
          window.location.href = '/login';
          break;
        case 429:
          // Handle rate limiting
          logger.error('Rate limit exceeded:', error.response.data);
          break;
        default:
          logger.error('API Error:', error.response.data);
      }
    } else if (error.request) {
      logger.error('Network Error:', error.message);
    }
    return Promise.reject(error);
  }
);

// Types for API responses
export interface ScrapeJobResponse {
  jobId: string;
  message: string;
}

export interface JobStatus {
  id: string;
  status: 'pending' | 'active' | 'completed' | 'failed' | 'delayed' | 'waiting';
  progress?: number;
  resultCount?: number;
  error?: string;
  createdAt: string;
  completedAt?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  };
}

export interface PropertyFilters {
  searchTerm?: string;
  city?: string;
  propType?: string;
  minValue?: number;
  maxValue?: number;
  limit?: number;
  offset?: number;
}

export interface ScrapeHistory {
  id: string;
  searchTerm: string;
  status: string;
  resultCount: number | null;
  error: string | null;
  startedAt: string;
  completedAt: string | null;
}

export interface PropertyStats {
  totalProperties: number;
  totalJobs: number;
  recentJobs: number;
  cityDistribution: Array<{
    city: string;
    _count: number;
  }>;
  propertyTypeDistribution: Array<{
    propType: string;
    _count: number;
    _avg: {
      appraisedValue: number;
    };
  }>;
}

export interface MonitoredSearch {
  id: string;
  searchTerm: string;
  active: boolean;
  frequency: 'daily' | 'weekly' | 'monthly';
  lastRun: string | null;
  createdAt: string;
  updatedAt: string;
}

// API service methods
export const propertyAPI = {
  // Trigger a new scrape job
  async triggerScrape(searchTerm: string): Promise<ScrapeJobResponse> {
    const response = await apiClient.post<ScrapeJobResponse>('/properties/scrape', {
      searchTerm,
    });
    return response.data;
  },

  // Check job status
  async getJobStatus(jobId: string): Promise<JobStatus> {
    const response = await apiClient.get<JobStatus>(`/properties/jobs/${jobId}`);
    return response.data;
  },

  // Poll job status until completion
  async pollJobStatus(
    jobId: string,
    onProgress?: (status: JobStatus) => void,
    pollInterval: number = 2000
  ): Promise<JobStatus> {
    return new Promise((resolve, reject) => {
      const checkStatus = async () => {
        try {
          const status = await this.getJobStatus(jobId);

          if (onProgress) {
            onProgress(status);
          }

          if (status.status === 'completed' || status.status === 'failed') {
            resolve(status);
          } else {
            setTimeout(checkStatus, pollInterval);
          }
        } catch (error) {
          reject(error);
        }
      };

      checkStatus();
    });
  },

  // Get properties from database
  async getProperties(filters?: PropertyFilters): Promise<PaginatedResponse<Property>> {
    const response = await apiClient.get<PaginatedResponse<Property>>('/properties', {
      params: filters,
    });
    return response.data;
  },

  // Get all properties (handle pagination automatically)
  async getAllProperties(filters?: Omit<PropertyFilters, 'limit' | 'offset'>): Promise<Property[]> {
    const allProperties: Property[] = [];
    let offset = 0;
    const limit = 100;
    let hasMore = true;

    while (hasMore) {
      const response = await this.getProperties({
        ...filters,
        limit,
        offset,
      });

      allProperties.push(...response.data);
      hasMore = response.pagination.hasMore;
      offset += limit;
    }

    return allProperties;
  },

  // Get scrape history
  async getScrapeHistory(limit: number = 20, offset: number = 0): Promise<PaginatedResponse<ScrapeHistory>> {
    const response = await apiClient.get<PaginatedResponse<ScrapeHistory>>('/properties/history', {
      params: { limit, offset },
    });
    return response.data;
  },

  // Get statistics
  async getStats(): Promise<PropertyStats> {
    const response = await apiClient.get<PropertyStats>('/properties/stats');
    return response.data;
  },

  // Add monitored search
  async addMonitoredSearch(searchTerm: string, frequency: 'daily' | 'weekly' | 'monthly' = 'daily'): Promise<MonitoredSearch> {
    const response = await apiClient.post<{ message: string; data: MonitoredSearch }>('/properties/monitor', {
      searchTerm,
      frequency,
    });
    return response.data.data;
  },

  // Get monitored searches
  async getMonitoredSearches(): Promise<MonitoredSearch[]> {
    const response = await apiClient.get<{ data: MonitoredSearch[] }>('/properties/monitor');
    return response.data.data;
  },
};

// Health check service
export const healthAPI = {
  async checkHealth(): Promise<boolean> {
    try {
      const response = await apiClient.get('/health');
      return response.status === 200;
    } catch {
      return false;
    }
  },

  async checkQueueHealth(): Promise<any> {
    const response = await apiClient.get('/health/queue');
    return response.data;
  },
};

export default propertyAPI;
</file>

<file path="services/README_ENHANCED.md">
# services

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "services",
  "description": "Directory containing 1 code files with 6 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "6 class definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `api.service.ts` (typescript)

**Classes:**
- `ScrapeJobResponse` - Line 60
- `JobStatus` - Line 65
- `PropertyFilters` - Line 85
- `ScrapeHistory` - Line 95
- `PropertyStats` - Line 105
- `MonitoredSearch` - Line 122

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="services/README.md">
# services

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `api.service.ts` (typescript)

**Classes:**
- `ScrapeJobResponse` - Line 58
- `JobStatus` - Line 63
- `PropertyFilters` - Line 83
- `ScrapeHistory` - Line 93
- `PropertyStats` - Line 103
- `MonitoredSearch` - Line 120

**Key Imports:** `../types`, `axios`

---
*Generated by Schema Generator*
</file>

<file path="types/index.ts">
export interface Property {
  id: string;
  property_id: string;
  name: string;
  prop_type: string;
  city: string | null;
  property_address: string;
  assessed_value: number | null;  // Can be null per Prisma schema
  appraised_value: number;
  geo_id: string | null;
  description: string | null;
  search_term: string | null;
  scraped_at: string;
  created_at: string;
  updated_at: string;
}
</file>

<file path="types/README_ENHANCED.md">
# types

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "types",
  "description": "Directory containing 1 code files with 1 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `index.ts` (typescript)

**Classes:**
- `Property` - Line 0

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="types/README.md">
# types

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `index.ts` (typescript)

**Classes:**
- `Property` - Line 1

---
*Generated by Schema Generator*
</file>

<file path="utils/__tests__/formatters.test.ts">
import { describe, it, expect } from 'vitest';
import { formatCurrency, formatNumber, formatDate, formatPropertyType, truncateText } from '../formatters';

describe('formatCurrency', () => {
  describe('valid numbers', () => {
    it('should format positive numbers correctly', () => {
      expect(formatCurrency(1000)).toBe('$1,000');
      expect(formatCurrency(1234567)).toBe('$1,234,567');
      expect(formatCurrency(999)).toBe('$999');
    });

    it('should format zero correctly', () => {
      expect(formatCurrency(0)).toBe('$0');
    });

    it('should format negative numbers correctly', () => {
      expect(formatCurrency(-1000)).toBe('-$1,000');
      expect(formatCurrency(-500)).toBe('-$500');
    });

    it('should format decimal numbers and round to whole dollars', () => {
      expect(formatCurrency(1234.56)).toBe('$1,235');
      expect(formatCurrency(999.99)).toBe('$1,000');
      expect(formatCurrency(100.49)).toBe('$100');
    });

    it('should format very large numbers', () => {
      expect(formatCurrency(1000000000)).toBe('$1,000,000,000');
      expect(formatCurrency(3900000000)).toBe('$3,900,000,000');
    });

    it('should format very small numbers', () => {
      expect(formatCurrency(0.01)).toBe('$0');
      expect(formatCurrency(0.99)).toBe('$1');
    });
  });

  describe('edge cases that could cause $NaN', () => {
    it('should handle null values gracefully', () => {
      expect(formatCurrency(null)).toBe('-');
    });

    it('should handle undefined values gracefully', () => {
      expect(formatCurrency(undefined)).toBe('-');
    });

    it('should handle NaN values gracefully', () => {
      expect(formatCurrency(NaN)).toBe('-');
    });

    it('should handle Infinity gracefully', () => {
      expect(formatCurrency(Infinity)).toBe('-');
      expect(formatCurrency(-Infinity)).toBe('-');
    });

    it('should handle division by zero results', () => {
      const result = 10 / 0;
      expect(formatCurrency(result)).toBe('-');
    });

    it('should handle calculation that produces NaN', () => {
      const result = Math.sqrt(-1);
      expect(formatCurrency(result)).toBe('-');
    });

    it('should handle string to number conversion failures', () => {
      const invalidNumber = Number('not a number');
      expect(formatCurrency(invalidNumber)).toBe('-');
    });
  });

  describe('type safety', () => {
    it('should accept number type', () => {
      const value: number = 1000;
      expect(formatCurrency(value)).toBe('$1,000');
    });

    it('should accept null type', () => {
      const value: null = null;
      expect(formatCurrency(value)).toBe('-');
    });

    it('should accept undefined type', () => {
      const value: undefined = undefined;
      expect(formatCurrency(value)).toBe('-');
    });

    it('should handle optional number (number | undefined)', () => {
      const value: number | undefined = undefined;
      expect(formatCurrency(value)).toBe('-');
    });

    it('should handle nullable number (number | null)', () => {
      const value: number | null = null;
      expect(formatCurrency(value)).toBe('-');
    });
  });
});

describe('formatNumber', () => {
  it('should format numbers with thousands separators', () => {
    expect(formatNumber(1000)).toBe('1,000');
    expect(formatNumber(1234567)).toBe('1,234,567');
  });

  it('should format zero', () => {
    expect(formatNumber(0)).toBe('0');
  });

  it('should preserve decimals', () => {
    expect(formatNumber(1234.56)).toBe('1,234.56');
  });
});

describe('formatDate', () => {
  it('should format ISO date strings', () => {
    const result = formatDate('2024-01-15T10:30:00Z');
    expect(result).toMatch(/Jan 15, 2024/);
  });

  it('should include time in formatted output', () => {
    const result = formatDate('2024-01-15T10:30:00Z');
    expect(result).toMatch(/\d{2}:\d{2}/); // Should contain time like "10:30"
  });
});

describe('formatPropertyType', () => {
  it('should format single word types', () => {
    expect(formatPropertyType('RESIDENTIAL')).toBe('Residential');
  });

  it('should format multi-word types with underscores', () => {
    expect(formatPropertyType('COMMERCIAL_RETAIL')).toBe('Commercial Retail');
  });

  it('should handle empty strings', () => {
    expect(formatPropertyType('')).toBe('Unknown');
  });

  it('should handle mixed case', () => {
    expect(formatPropertyType('rEsIdEnTiAl')).toBe('Residential');
  });
});

describe('truncateText', () => {
  it('should not truncate text shorter than maxLength', () => {
    expect(truncateText('Hello', 10)).toBe('Hello');
  });

  it('should truncate text longer than maxLength', () => {
    expect(truncateText('Hello World', 8)).toBe('Hello...');
  });

  it('should handle exact length match', () => {
    expect(truncateText('Hello', 5)).toBe('Hello');
  });

  it('should handle empty strings', () => {
    expect(truncateText('', 10)).toBe('');
  });
});
</file>

<file path="utils/constants.ts">
/**
 * Application constants
 */

export const DEFAULT_PAGE_SIZE = 50;

export const PROPERTY_TYPES = [
  'Residential',
  'Commercial',
  'Industrial',
  'Agricultural',
  'Vacant Land',
  'Multi-Family',
] as const;

export const VALUE_RANGES = [
  { label: 'Under $100k', min: 0, max: 100000 },
  { label: '$100k - $300k', min: 100000, max: 300000 },
  { label: '$300k - $500k', min: 300000, max: 500000 },
  { label: '$500k - $1M', min: 500000, max: 1000000 },
  { label: 'Over $1M', min: 1000000, max: Infinity },
] as const;

export const EXAMPLE_QUERIES = [
  'properties in Austin worth over $500k',
  'commercial properties owned by Smith',
  'show me the most expensive residential properties',
  'properties on Congress Ave',
  'find properties appraised between $300k and $600k',
] as const;

export const STATUS_COLORS = {
  active: '#10b981',
  completed: '#3b82f6',
  failed: '#ef4444',
  pending: '#f59e0b',
} as const;

export const BREAKPOINTS = {
  mobile: '640px',
  tablet: '768px',
  desktop: '1024px',
  wide: '1280px',
} as const;
</file>

<file path="utils/formatters.ts">
/**
 * Formatting utilities for the application
 * Consolidates all formatting logic in one place
 */

/**
 * Format a number as US currency
 * Handles null, undefined, and NaN values gracefully
 */
export const formatCurrency = (value: number | null | undefined): string => {
  // Handle null, undefined, NaN, or invalid values
  if (value === null || value === undefined || !isFinite(value)) {
    return '-';
  }

  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
};

/**
 * Format a number with thousands separators
 */
export const formatNumber = (value: number): string => {
  return new Intl.NumberFormat('en-US').format(value);
};

/**
 * Format a date string to readable format
 */
export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
};

/**
 * Format property type for display
 */
export const formatPropertyType = (type: string): string => {
  if (!type) return 'Unknown';
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

/**
 * Truncate text with ellipsis
 */
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + '...';
};
</file>

<file path="utils/helpers.ts">
/**
 * Helper utility functions
 */

/**
 * Debounce a function call
 */
export const debounce = <T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): ((...args: Parameters<T>) => void) => {
  let timeoutId: NodeJS.Timeout;

  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};

/**
 * Throttle a function call
 */
export const throttle = <T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): ((...args: Parameters<T>) => void) => {
  let lastCall = 0;

  return (...args: Parameters<T>) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
    }
  };
};

/**
 * Group array items by a key
 */
export const groupBy = <T, K extends keyof T>(
  array: T[],
  key: K
): Record<string, T[]> => {
  return array.reduce((groups, item) => {
    const groupKey = String(item[key]);
    if (!groups[groupKey]) {
      groups[groupKey] = [];
    }
    groups[groupKey].push(item);
    return groups;
  }, {} as Record<string, T[]>);
};

/**
 * Check if a value is defined and not null
 */
export const isDefined = <T>(value: T | null | undefined): value is T => {
  return value !== null && value !== undefined;
};

/**
 * Safely parse JSON with fallback
 */
export const parseJSON = <T>(json: string, fallback: T): T => {
  try {
    return JSON.parse(json);
  } catch {
    return fallback;
  }
};
</file>

<file path="utils/index.ts">
// Utilities Barrel Export
export * from './formatters';
export * from './helpers';
export * from './constants';
</file>

<file path="App.css">
/* CSS Custom Properties - Global design tokens */
:root {
  /* Primary brand colors */
  --primary: #2563eb; /* Blue - main brand color for buttons and links */
  --primary-dark: #1e40af; /* Darker blue - hover states */
  --secondary: #10b981; /* Green - success states and accents */
  --error: #ef4444; /* Red - error messages and destructive actions */
  --warning: #f59e0b; /* Amber - warning states */

  /* Neutral color scale - lightest to darkest */
  --neutral-50: #f9fafb; /* Off-white - page backgrounds */
  --neutral-100: #f3f4f6; /* Very light gray - subtle backgrounds */
  --neutral-200: #e5e7eb; /* Light gray - borders and dividers */
  --neutral-300: #d1d5db; /* Gray - disabled states */
  --neutral-400: #9ca3af; /* Medium gray - placeholders */
  --neutral-500: #6b7280; /* Mid gray - secondary text */
  --neutral-600: #4b5563; /* Dark gray - body text */
  --neutral-700: #374151; /* Darker gray - headings */
  --neutral-800: #1f2937; /* Very dark gray - emphasis */
  --neutral-900: #111827; /* Near black - primary text */

  /* Shadow tokens - elevation levels */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* Subtle elevation */
  --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1); /* Default card shadow */
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* Medium elevation */
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); /* High elevation */
}

/* Global reset - ensures consistent spacing and box model */
* {
  margin: 0; /* Remove default margins */
  padding: 0; /* Remove default padding */
  box-sizing: border-box; /* Include padding and border in element width/height */
}

/* Base body styles - typography and colors */
body {
  /* System font stack - uses native fonts for optimal performance */
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased; /* Smooth fonts on macOS/iOS */
  -moz-osx-font-smoothing: grayscale; /* Smooth fonts on Firefox macOS */
  background-color: var(--neutral-50); /* Light gray background */
  color: var(--neutral-900); /* Near black text */
  line-height: 1.5; /* 150% line height for readability */
}

/* Main app container */
.app {
  min-height: 100vh; /* Ensure full viewport height */
  padding: 32px 16px; /* 32px top/bottom, 16px left/right */
}

/* App header - centered with max width */
.app-header {
  max-width: 1200px; /* Limit width for readability */
  margin: 0 auto 48px; /* Center horizontally, 48px bottom spacing */
  text-align: center; /* Center all text */

  /* Main heading */
  h1 {
    font-size: 2.5rem; /* 40px - large heading */
    font-weight: 700; /* Bold weight */
    color: var(--neutral-900); /* Dark text */
    margin-bottom: 8px; /* Small gap below heading */
    line-height: 1.2; /* Tight line height for large text */
  }

  /* Subtitle text */
  p {
    font-size: 1.125rem; /* 18px - slightly larger than body */
    color: var(--neutral-600); /* Muted gray */
    line-height: 1.5; /* Standard line height */
  }
}

/* Error banner - dismissible notification */
.error-banner {
  max-width: 1200px; /* Match content width */
  margin: 0 auto 24px; /* Center with bottom spacing */
  padding: 16px 24px; /* Internal spacing */
  background-color: #fef2f2; /* Light red background */
  border: 1px solid #fecaca; /* Red border */
  border-radius: 8px; /* Rounded corners */
  display: flex; /* Flexbox layout */
  justify-content: space-between; /* Space between text and button */
  align-items: center; /* Vertically center content */
  color: var(--error); /* Red text */

  /* Dismiss button */
  button {
    padding: 8px 16px; /* Button spacing */
    background-color: var(--error); /* Red background */
    color: white; /* White text */
    border: none; /* Remove default border */
    border-radius: 6px; /* Rounded corners */
    font-size: 0.875rem; /* 14px - small text */
    font-weight: 500; /* Medium weight */
    cursor: pointer; /* Show pointer on hover */
    transition: background-color 0.2s; /* Smooth color transition */

    /* Darker red on hover */
    &:hover {
      background-color: #dc2626; /* Darker red */
    }
  }
}

/* Loading state container - centered vertically */
.loading {
  display: flex; /* Flexbox layout */
  flex-direction: column; /* Stack items vertically */
  align-items: center; /* Center horizontally */
  justify-content: center; /* Center vertically */
  padding: 80px 16px; /* Large vertical padding */
  gap: 16px; /* Space between spinner and text */

  /* Loading text */
  p {
    color: var(--neutral-600); /* Muted gray */
    font-size: 1rem; /* 16px - standard text */
  }
}

/* Animated spinner */
.spinner {
  width: 48px; /* Spinner size */
  height: 48px; /* Spinner size */
  border: 4px solid var(--neutral-200); /* Gray border */
  border-top-color: var(--primary); /* Blue top border for spinning effect */
  border-radius: 50%; /* Perfect circle */
  animation: spin 0.8s linear infinite; /* Continuous rotation */
}

/* Spinner rotation animation */
@keyframes spin {
  to { transform: rotate(360deg); } /* Full rotation */
}

/* Mobile responsive styles - tablets and phones */
@media (max-width: 768px) {
  .app {
    padding: 24px 12px; /* Less padding for mobile */
  }

  .app-header {
    h1 {
      font-size: 1.875rem; /* 30px instead of 40px */
    }

    p {
      font-size: 1rem; /* 16px instead of 18px */
    }
  }
}
</file>

<file path="App.tsx">
import { useEffect } from 'react';
import { PropertySearchContainer } from './components/features/PropertySearch';
import { ErrorBoundary } from './components/ErrorBoundary';
import { useAnalytics } from './hooks';
import './App.css';

function App() {
  const { logPageView } = useAnalytics();

  // Track initial page view
  useEffect(() => {
    logPageView(window.location.pathname, document.title);
  }, [logPageView]);

  return (
    <ErrorBoundary>
      <div className="app">
        <PropertySearchContainer />
      </div>
    </ErrorBoundary>
  );
}

export default App;
</file>

<file path="database.ts">
import { Pool } from 'pg';
import logger from './lib/logger';

// Database connection configuration
if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is not set');
}
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
)};

export interface Property {
  name: string;
  propType: string;
  city: string | null | undefined;
  propertyAddress: string;
  assessedValue: string;
  propertyID: string;
  appraisedValue: string;
  geoID: string | null | undefined;
  description: string | null | undefined;
}

/**
 * Insert a single property into the database
 */
export async function insertProperty(property: Property): Promise<void> {
  const query = `
    INSERT INTO properties (
      property_id, owner_name, property_type, city,
      property_address, assessed_value, appraised_value,
      geo_id, legal_description
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    ON CONFLICT (property_id)
    DO UPDATE SET
      owner_name = EXCLUDED.owner_name,
      property_type = EXCLUDED.property_type,
      city = EXCLUDED.city,
      property_address = EXCLUDED.property_address,
      assessed_value = EXCLUDED.assessed_value,
      appraised_value = EXCLUDED.appraised_value,
      geo_id = EXCLUDED.geo_id,
      legal_description = EXCLUDED.legal_description,
      updated_at = CURRENT_TIMESTAMP
  `;

  const values = [
    property.propertyID,
    property.name,
    property.propType,
    property.city,
    property.propertyAddress,
    property.assessedValue,
    property.appraisedValue,
    property.geoID,
    property.description
  ];

  try {
    await pool.query(query, values);
    logger.info(` Saved property: ${property.propertyID}`);
  } catch (error) {
    logger.error(` Error saving property ${property.propertyID}:`, error);
    throw error;
  }
}

/**
 * Insert multiple properties at once
 */
export async function insertProperties(properties: Property[]): Promise<void> {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    for (const property of properties) {
      await insertProperty(property);
    }

    await client.query('COMMIT');
    logger.info(` Successfully saved ${properties.length} properties`);
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error(' Error saving properties:', error);
    throw error;
  } finally {
    client.release();
  }
}

/**
 * Query properties by city
 */
export async function getPropertiesByCity(city: string): Promise<Property[]> {
  const query = 'SELECT * FROM properties WHERE city = $1 ORDER BY appraised_value DESC';
  const result = await pool.query(query, [city]);
  return result.rows;
}

/**
 * Get total property count
 */
export async function getPropertyCount(): Promise<number> {
  const result = await pool.query('SELECT COUNT(*) FROM properties');
  return parseInt(result.rows[0].count);
}

/**
 * Close database connection pool
 */
export async function closePool(): Promise<void> {
  await pool.end();
}
</file>

<file path="main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');

if (!rootElement) {
  throw new Error('Root element not found');
}

createRoot(rootElement).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="query-db.ts">
import { Pool } from 'pg';
import { stdin, stdout } from 'process';
import * as readline from 'readline';
import logger from './lib/logger';


if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is not set');
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

async function displayStats() {
  logger.info('\n Database Statistics\n' + '='.repeat(50));

  const stats = await pool.query(`
    SELECT
      COUNT(*) as total_properties,
      COUNT(DISTINCT city) as unique_cities,
      MAX(scraped_at) as last_scraped
    FROM properties
  `);

  logger.info(`Total Properties: ${stats.rows[0].total_properties}`);
  logger.info(`Unique Cities: ${stats.rows[0].unique_cities}`);
  logger.info(`Last Scraped: ${stats.rows[0].last_scraped || 'Never'}`);
}

async function displayCitySummary() {
  logger.info('\n  Properties by City\n' + '='.repeat(50));

  const cities = await pool.query(`
    SELECT
      city,
      COUNT(*) as property_count,
      AVG(CAST(REPLACE(REPLACE(appraised_value, '$', ''), ',', '') AS NUMERIC)) as avg_value
    FROM properties
    WHERE city IS NOT NULL AND city != ''
    GROUP BY city
    ORDER BY property_count DESC
    LIMIT 10
  `);

  cities.rows.forEach(row => {
    const avgValue = row.avg_value ? `$${Math.round(row.avg_value).toLocaleString()}` : 'N/A';
    logger.info(`${row.city.padEnd(20)} | ${String(row.property_count).padStart(5)} properties | Avg: ${avgValue}`);
  });
}

async function displayRecentProperties(limit: number = 10) {
  logger.info(`\n Recent Properties (Last ${limit})\n` + '='.repeat(50));

  const properties = await pool.query(`
    SELECT
      property_id,
      owner_name,
      property_address,
      city,
      appraised_value,
      scraped_at
    FROM properties
    ORDER BY scraped_at DESC
    LIMIT $1
  `, [limit]);

  properties.rows.forEach((prop, idx) => {
    logger.info(`\n${idx + 1}. Property ID: ${prop.property_id}`);
    logger.info(`   Owner: ${prop.owner_name}`);
    logger.info(`   Address: ${prop.property_address}, ${prop.city || 'N/A'}`);
    logger.info(`   Value: ${prop.appraised_value || 'N/A'}`);
    logger.info(`   Scraped: ${prop.scraped_at}`);
  });
}

async function searchProperties(searchTerm: string) {
  logger.info(`\n Search Results for: "${searchTerm}"\n` + '='.repeat(50));

  const results = await pool.query(`
    SELECT
      property_id,
      owner_name,
      property_address,
      city,
      appraised_value
    FROM properties
    WHERE
      owner_name ILIKE $1 OR
      property_address ILIKE $1 OR
      city ILIKE $1
    LIMIT 20
  `, [`%${searchTerm}%`]);

  if (results.rows.length === 0) {
    logger.info('No results found.');
  } else {
    results.rows.forEach((prop, idx) => {
      logger.info(`\n${idx + 1}. ${prop.owner_name}`);
      logger.info(`   ${prop.property_address}, ${prop.city || 'N/A'}`);
      logger.info(`   Value: ${prop.appraised_value || 'N/A'} | ID: ${prop.property_id}`);
    });
  }
}

async function runCustomQuery(query: string) {
  try {
    const result = await pool.query(query);
    logger.info('\n Query executed successfully\n');
    console.table(result.rows);
    logger.info(`\nRows returned: ${result.rowCount}`);
  } catch (error) {
    logger.error(' Query error:', error);
  }
}

async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'stats':
        await displayStats();
        break;
      case 'cities':
        await displayCitySummary();
        break;
      case 'recent':
        const limit = parseInt(args[1]) || 10;
        await displayRecentProperties(limit);
        break;
      case 'search':
        if (!args[1]) {
          logger.error('Please provide a search term: npm run db:query search "term"');
          process.exit(1);
        }
        await searchProperties(args[1]);
        break;
      case 'query':
        if (!args[1]) {
          logger.error('Please provide a SQL query: npm run db:query query "SELECT * FROM properties LIMIT 5"');
          process.exit(1);
        }
        await runCustomQuery(args[1]);
        break;
      default:
        logger.info(`
  TCAD Property Database Query Tool

Usage: npm run db:query <command> [args]

Commands:
  stats              - Show database statistics
  cities             - Show properties grouped by city
  recent [N]         - Show N most recent properties (default: 10)
  search <term>      - Search properties by owner, address, or city
  query "<SQL>"      - Execute custom SQL query

Examples:
  npm run db:query stats
  npm run db:query cities
  npm run db:query recent 20
  npm run db:query search "Austin"
  npm run db:query query "SELECT * FROM properties WHERE city = 'Austin' LIMIT 5"

Or use: npm run db:stats for quick statistics
        `);
    }
  } catch (error) {
    logger.error('Error:', error);
  } finally {
    await pool.end();
  }
}

main();
</file>

<file path="README_ENHANCED.md">
# src

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "src",
  "description": "Directory containing 4 code files with 4 classes and 8 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions",
    "8 function definitions"
  ]
}
</script>

## Overview

This directory contains 4 code file(s) with extracted schemas.

## Subdirectories

- `components/`
- `hooks/`
- `lib/`
- `services/`
- `types/`
- `utils/`

## Files and Schemas

### `database.ts` (typescript)

**Classes:**
- `Property` - Line 11

### `query-db.ts` (typescript)

**Functions:**
- `async displayStats()` - Line 14
- `async displayCitySummary()` - Line 30
- `async displayRecentProperties()` - Line 51
- `async searchProperties()` - Line 76
- `async runCustomQuery()` - Line 105
- `async main()` - Line 116

### `test-api-direct.ts` (typescript)

**Classes:**
- `TCADAuthResponse` - Line 8

**Functions:**
- `async searchProperties()` - Line 29
- `async testTCADAPI()` - Line 87

### `vite-env.d.ts` (typescript)

**Classes:**
- `ImportMetaEnv` - Line 2
- `ImportMeta` - Line 6

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# src

## Overview

This directory contains 4 code file(s) with extracted schemas.

## Subdirectories

- `components/`
- `lib/`
- `services/`
- `types/`

## Files and Schemas

### `App.tsx` (typescript)

**Functions:**
- `App()` - Line 61

**Key Imports:** `./components/Analytics`, `./components/Charts`, `./components/Filters`, `./components/PropertyTable`, `./types` (+1 more)

### `database.ts` (typescript)

**Classes:**
- `Property` - Line 8

**Functions:**
- `insertProperty(property) -> Promise<void>` - Line 23
- `insertProperties(properties) -> Promise<void>` - Line 67
- `getPropertiesByCity(city) -> Promise<Property[]>` - Line 91
- `getPropertyCount() -> Promise<number>` - Line 100
- `closePool() -> Promise<void>` - Line 108

**Key Imports:** `pg`

### `query-db.ts` (typescript)

**Functions:**
- `displayStats()` - Line 9
- `displayCitySummary()` - Line 25
- `displayRecentProperties(limit)` - Line 46
- `searchProperties(searchTerm)` - Line 71
- `runCustomQuery(query)` - Line 100
- `main()` - Line 111

**Key Imports:** `pg`, `process`, `readline`

### `vite-env.d.ts` (typescript)

**Classes:**
- `ImportMetaEnv` - Line 3
- `ImportMeta` - Line 8

---
*Generated by Schema Generator*
</file>

<file path="test-api-direct.ts">
import logger from './lib/logger';
/**
 * Test script to directly call the TCAD API using the authentication token
 * This tests if we can use the API instead of web scraping
 */

const TCAD_API_BASE_URL = 'https://prod-container.trueprodigyapi.com/trueprodigy/cadpublic';

interface TCADAuthResponse {
  user: {
    token: string;
  };
}

async function getAuthToken(): Promise<string> {
  logger.info(' Getting authentication token...');

  const response = await fetch(`${TCAD_API_BASE_URL}/auth/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ office: 'Travis' })
  });

  const data = await response.json() as TCADAuthResponse;
  const token = data.user.token;
  logger.info(` Token received: ${token.substring(0, 50)}...`);
  return token;
}

async function searchProperties(token: string, searchTerm: string) {
  logger.info(`\n Searching for: "${searchTerm}"`);

  try {
    // Try different possible API endpoints
    const endpoints = [
      '/properties/search',
      '/property/search',
      '/search',
      '/properties',
      '/property',
    ];

    for (const endpoint of endpoints) {
      try {
        logger.info(`  Trying: ${TCAD_API_BASE_URL}${endpoint}`);

        // Try with different query parameter names
        const params = new URLSearchParams({
          search: searchTerm,
          q: searchTerm,
          query: searchTerm,
          term: searchTerm,
        });

        const response = await fetch(`${TCAD_API_BASE_URL}${endpoint}?${params}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          const data = await response.json();
          logger.info(`\n Success with endpoint: ${endpoint}`);
          logger.info('Response:', JSON.stringify(data, null, 2));
          return data;
        } else {
          logger.info(`   ${response.status}: ${response.statusText}`);
          if (response.status !== 404 && response.status !== 405) {
            const errorData = await response.text();
            logger.info('  Response data:', errorData);
          }
        }

      } catch (error: any) {
        logger.info(`   Error: ${error.message}`);
      }
    }

    logger.info('\n All endpoints failed');

  } catch (error) {
    logger.error('Error searching properties:', error);
  }
}

async function testTCADAPI() {
  logger.info('');
  logger.info('     TCAD API Direct Test                           ');
  logger.info('\n');

  try {
    // Step 1: Get auth token
    const token = await getAuthToken();

    // Step 2: Try to search for properties
    const testSearchTerms = ['Austin', '78701', 'downtown'];

    for (const searchTerm of testSearchTerms) {
      await searchProperties(token, searchTerm);
    }

    logger.info('\n');
    logger.info('     Test Complete                                  ');
    logger.info('');

  } catch (error) {
    logger.error('\n Test failed:', error);
  }
}

// Run the test
testTCADAPI();
</file>

<file path="vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

</files>
