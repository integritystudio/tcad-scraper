This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
index.ts
README_ENHANCED.md
useAnalytics.ts
useDebounce.ts
useFormatting.ts
usePagination.ts
usePropertySearch.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="index.ts">
export { useFormatting } from './useFormatting';
export { usePropertySearch } from './usePropertySearch';
export { usePagination } from './usePagination';
export { useDebounce } from './useDebounce';
export { useAnalytics } from './useAnalytics';
</file>

<file path="README_ENHANCED.md">
# hooks

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "hooks",
  "description": "Directory containing 4 code files with 4 classes and 2 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions",
    "2 function definitions"
  ]
}
</script>

## Overview

This directory contains 4 code file(s) with extracted schemas.

## Files and Schemas

### `useAnalytics.ts` (typescript)

**Functions:**
- `useAnalytics()` - Line 16

### `useFormatting.ts` (typescript)

**Functions:**
- `useFormatting()` - Line 13

### `usePagination.ts` (typescript)

**Classes:**
- `UsePaginationProps` - Line 2
- `UsePaginationReturn` - Line 8

### `usePropertySearch.ts` (typescript)

**Classes:**
- `SearchResult` - Line 4
- `UsePropertySearchReturn` - Line 18

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="useAnalytics.ts">
/**
 * React hook for analytics tracking
 */
import { useCallback } from 'react';
import {
  trackEvent,
  trackSearch,
  trackExampleQueryClick,
  trackSearchResults,
  trackPropertyView,
  trackPageView,
  trackError,
  trackConversion,
  type AnalyticsEvent,
} from '../lib/analytics';

export const useAnalytics = () => {
  const track = useCallback((event: AnalyticsEvent) => {
    trackEvent(event);
  }, []);

  const logSearch = useCallback((query: string, resultsCount?: number) => {
    trackSearch(query, resultsCount);
  }, []);

  const logExampleQueryClick = useCallback((query: string) => {
    trackExampleQueryClick(query);
  }, []);

  const logSearchResults = useCallback(
    (query: string, resultsCount: number, hasExplanation: boolean) => {
      trackSearchResults(query, resultsCount, hasExplanation);
    },
    []
  );

  const logPropertyView = useCallback((propertyId: string, propertyAddress?: string) => {
    trackPropertyView(propertyId, propertyAddress);
  }, []);

  const logError = useCallback((errorMessage: string, errorContext?: string) => {
    trackError(errorMessage, errorContext);
  }, []);

  const logConversion = useCallback((conversionType: string, value?: number) => {
    trackConversion(conversionType, value);
  }, []);

  const logPageView = useCallback((path: string, title?: string) => {
    trackPageView(path, title);
  }, []);

  return {
    track,
    logSearch,
    logExampleQueryClick,
    logSearchResults,
    logPropertyView,
    logPageView,
    logError,
    logConversion,
  };
};
</file>

<file path="useDebounce.ts">
import { useEffect, useState } from 'react';

/**
 * Hook to debounce a value
 * Useful for search inputs to reduce API calls
 */
export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
</file>

<file path="useFormatting.ts">
import { useMemo } from 'react';
import {
  formatCurrency,
  formatNumber,
  formatDate,
  formatPropertyType,
  truncateText,
} from '../utils/formatters';

/**
 * Hook providing formatting utilities
 * Consolidates all formatting logic in one place
 */
export const useFormatting = () => {
  return useMemo(
    () => ({
      formatCurrency,
      formatNumber,
      formatDate,
      formatPropertyType,
      truncateText,
    }),
    []
  );
};
</file>

<file path="usePagination.ts">
import { useState, useMemo, useCallback } from 'react';

interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  initialPage?: number;
}

interface UsePaginationReturn {
  currentPage: number;
  totalPages: number;
  itemsPerPage: number;
  startIndex: number;
  endIndex: number;
  canGoNext: boolean;
  canGoPrev: boolean;
  goToPage: (page: number) => void;
  goToNextPage: () => void;
  goToPrevPage: () => void;
  goToFirstPage: () => void;
  goToLastPage: () => void;
}

/**
 * Hook for pagination logic
 * Handles page navigation and calculations
 */
export const usePagination = ({
  totalItems,
  itemsPerPage,
  initialPage = 1,
}: UsePaginationProps): UsePaginationReturn => {
  const [currentPage, setCurrentPage] = useState(initialPage);

  const totalPages = useMemo(
    () => Math.ceil(totalItems / itemsPerPage),
    [totalItems, itemsPerPage]
  );

  const startIndex = useMemo(
    () => (currentPage - 1) * itemsPerPage,
    [currentPage, itemsPerPage]
  );

  const endIndex = useMemo(
    () => Math.min(startIndex + itemsPerPage, totalItems),
    [startIndex, itemsPerPage, totalItems]
  );

  const canGoNext = useMemo(
    () => currentPage < totalPages,
    [currentPage, totalPages]
  );

  const canGoPrev = useMemo(() => currentPage > 1, [currentPage]);

  const goToPage = useCallback(
    (page: number) => {
      const pageNumber = Math.max(1, Math.min(page, totalPages));
      setCurrentPage(pageNumber);
    },
    [totalPages]
  );

  const goToNextPage = useCallback(() => {
    if (canGoNext) {
      setCurrentPage((prev) => prev + 1);
    }
  }, [canGoNext]);

  const goToPrevPage = useCallback(() => {
    if (canGoPrev) {
      setCurrentPage((prev) => prev - 1);
    }
  }, [canGoPrev]);

  const goToFirstPage = useCallback(() => {
    setCurrentPage(1);
  }, []);

  const goToLastPage = useCallback(() => {
    setCurrentPage(totalPages);
  }, [totalPages]);

  return {
    currentPage,
    totalPages,
    itemsPerPage,
    startIndex,
    endIndex,
    canGoNext,
    canGoPrev,
    goToPage,
    goToNextPage,
    goToPrevPage,
    goToFirstPage,
    goToLastPage,
  };
};
</file>

<file path="usePropertySearch.ts">
import { useState, useCallback } from 'react';
import { Property } from '../types';
import { getApiBaseUrl } from '../lib/api-config';

interface SearchResult {
  data: Property[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  };
  query?: {
    original: string;
    explanation: string;
  };
}

interface UsePropertySearchReturn {
  results: Property[];
  loading: boolean;
  error: string;
  totalResults: number;
  explanation: string;
  search: (query: string, limit?: number) => Promise<void>;
  clearResults: () => void;
}

/**
 * Hook for property search functionality
 * Handles API calls, loading states, and error handling
 */
export const usePropertySearch = (): UsePropertySearchReturn => {
  const [results, setResults] = useState<Property[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [totalResults, setTotalResults] = useState(0);
  const [explanation, setExplanation] = useState('');

  const search = useCallback(async (query: string, limit = 50) => {
    if (!query.trim()) return;

    setLoading(true);
    setError('');

    try {
      const apiBaseUrl = getApiBaseUrl();
      const response = await fetch(`${apiBaseUrl}/properties/search`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query, limit }),
      });

      if (!response.ok) {
        const errorData = await response
          .json()
          .catch(() => ({ message: 'Search failed' }));
        throw new Error(errorData.message || 'Search failed');
      }

      const data: SearchResult = await response.json();

      if (!data || !data.data || !data.pagination) {
        throw new Error('Received invalid data from server');
      }

      setResults(data.data);
      setTotalResults(data.pagination.total);
      setExplanation(data.query?.explanation || '');
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An error occurred';
      setError(errorMessage);
      setResults([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const clearResults = useCallback(() => {
    setResults([]);
    setError('');
    setExplanation('');
    setTotalResults(0);
  }, []);

  return {
    results,
    loading,
    error,
    totalResults,
    explanation,
    search,
    clearResults,
  };
};
</file>

</files>
