This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
index.ts
json-ld.utils.ts
property.types.ts
README_ENHANCED.md
SCHEMA-DOCUMENTATION.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="index.ts">
/**
 * Shared Types - Barrel Export
 *
 * This file provides a single point of import for all shared types used across
 * the TCAD scraper application (frontend, backend, and utilities).
 *
 * Usage:
 *   import { PropertyAPI, PropertyDatabase } from '@shared/types';
 */

// Re-export all property types (includes Schema.org aligned types)
export * from './property.types';

// Re-export JSON-LD utilities
export * from './json-ld.utils';

// Type guards and utilities
export { transformPropertyToAPI, transformPropertyToDatabase } from './property.types';
</file>

<file path="json-ld.utils.ts">
/**
 * JSON-LD Structured Data Utilities for TCAD Properties
 *
 * This module provides utilities to generate Schema.org compliant JSON-LD
 * structured data for maximum SEO value. It supports various contexts including
 * individual property pages, property listings, and search results.
 *
 * @see https://schema.org/RealEstateListing
 * @see https://developers.google.com/search/docs/appearance/structured-data
 */

import { PropertyAPI, PropertyDatabase, PaginatedPropertyResponse } from '../types/property.types';

// ============================================================================
// Type Definitions for JSON-LD
// ============================================================================

interface JsonLdBase {
  '@context': 'https://schema.org';
  '@type': string | string[];
  '@id'?: string;
}

interface BreadcrumbItem {
  '@type': 'ListItem';
  position: number;
  name: string;
  item?: string;
}

interface SearchAction {
  '@type': 'SearchAction';
  target: {
    '@type': 'EntryPoint';
    urlTemplate: string;
  };
  'query-input': string;
}

// ============================================================================
// Individual Property JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a single property detail page
 * This provides the most comprehensive structured data for SEO
 */
export function generatePropertyJsonLd(
  property: PropertyAPI,
  organizationName = 'Travis County Appraisal District',
  websiteUrl = 'https://example.com'
): object {
  const jsonLd: any = {
    '@context': 'https://schema.org',
    '@type': property['@type'] || 'RealEstateListing',
    '@id': `${websiteUrl}/properties/${property.propertyId}`,

    // Core property information
    identifier: property.propertyId,
    name: `${property.address.formatted} - TCAD Property`,
    description: property.legalDescription ||
      `${property.propertyType} property located at ${property.address.formatted}`,

    // Address with full PostalAddress structure
    address: {
      '@type': 'PostalAddress',
      streetAddress: property.address.streetAddress,
      addressLocality: property.address.addressLocality,
      addressRegion: property.address.addressRegion,
      addressCountry: property.address.addressCountry,
      postalCode: property.address.postalCode
    },

    // Geographic coordinates if available
    ...(property.geography?.latitude && property.geography?.longitude && {
      geo: {
        '@type': 'GeoCoordinates',
        latitude: property.geography.latitude,
        longitude: property.geography.longitude
      }
    }),

    // Property type categorization
    additionalType: property.propertyType,

    // Owner/Seller information
    ...(property.owner && {
      seller: {
        '@type': property.owner['@type'] || 'Person',
        name: property.owner.name
      }
    }),

    // Pricing and valuation
    offers: {
      '@type': 'Offer',
      price: property.valuation.appraisedValue.value,
      priceCurrency: property.valuation.appraisedValue.currency,

      // Additional price specifications
      priceSpecification: [
        {
          '@type': 'PriceSpecification',
          price: property.valuation.appraisedValue.value,
          priceCurrency: property.valuation.appraisedValue.currency,
          name: 'Appraised Value',
          description: 'Market value as determined by TCAD'
        },
        ...(property.valuation.assessedValue ? [{
          '@type': 'PriceSpecification',
          price: property.valuation.assessedValue.value,
          priceCurrency: property.valuation.assessedValue.currency,
          name: 'Assessed Value',
          description: 'Tax assessed value for property tax calculations'
        }] : [])
      ],

      // Seller/offerer information
      seller: {
        '@type': 'Organization',
        name: organizationName,
        url: websiteUrl
      },

      // Validity dates based on data freshness
      validFrom: property.metadata.scrapedAt,
      ...(property.metadata.dataFreshness === 'stale' && {
        validThrough: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
      })
    },

    // Additional property details
    ...(property.geography?.neighborhood && {
      containedInPlace: {
        '@type': 'Place',
        name: property.geography.neighborhood
      }
    }),

    // Data provider information
    provider: {
      '@type': 'Organization',
      name: organizationName,
      url: websiteUrl,
      sameAs: [
        'https://www.traviscad.org'
      ]
    },

    // Metadata
    datePosted: property.metadata.createdAt,
    dateModified: property.metadata.updatedAt,

    // Potential actions
    potentialAction: [
      {
        '@type': 'ViewAction',
        target: `${websiteUrl}/properties/${property.propertyId}`,
        name: 'View Property Details'
      }
    ]
  };

  return jsonLd;
}

// ============================================================================
// Property Listing/Search Results JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a property listing or search results page
 * Implements ItemList for better search result presentation
 */
export function generatePropertyListJsonLd(
  response: PaginatedPropertyResponse,
  searchQuery?: string,
  websiteUrl = 'https://example.com'
): object {
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'ItemList',
    name: searchQuery
      ? `Property Search Results for "${searchQuery}"`
      : 'Travis County Properties',
    description: `Browse ${response.pagination.total} properties in Travis County`,
    numberOfItems: response.pagination.total,

    // Individual property items
    itemListElement: response.results.map((property, index) => ({
      '@type': 'ListItem',
      position: response.pagination.offset + index + 1,
      item: {
        '@type': property['@type'] || 'RealEstateListing',
        '@id': `${websiteUrl}/properties/${property.propertyId}`,
        identifier: property.propertyId,
        name: property.address.formatted,
        description: `${property.propertyType} - ${property.valuation.appraisedValue.formatted}`,

        address: {
          '@type': 'PostalAddress',
          streetAddress: property.address.streetAddress,
          addressLocality: property.address.addressLocality,
          addressRegion: property.address.addressRegion,
          addressCountry: property.address.addressCountry
        },

        offers: {
          '@type': 'Offer',
          price: property.valuation.appraisedValue.value,
          priceCurrency: property.valuation.appraisedValue.currency
        },

        url: `${websiteUrl}/properties/${property.propertyId}`
      }
    })),

    // Pagination information
    ...(response.pagination.hasMore && {
      nextItem: `${websiteUrl}/search?offset=${response.pagination.offset + response.pagination.limit}`
    }),

    // Search action for the listing
    potentialAction: {
      '@type': 'SearchAction',
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${websiteUrl}/search?q={search_term_string}`
      },
      'query-input': 'required name=search_term_string'
    }
  };

  return jsonLd;
}

// ============================================================================
// Website/Organization JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for the website/organization
 * Should be included on the homepage
 */
export function generateOrganizationJsonLd(
  websiteUrl = 'https://example.com',
  organizationName = 'TCAD Property Search'
): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    '@id': websiteUrl,
    name: organizationName,
    description: 'Search and browse Travis County Appraisal District property records',
    url: websiteUrl,

    // Publisher/operator
    publisher: {
      '@type': 'Organization',
      name: organizationName,
      url: websiteUrl,
      logo: {
        '@type': 'ImageObject',
        url: `${websiteUrl}/logo.png`,
        width: 600,
        height: 60
      }
    },

    // Site search box
    potentialAction: {
      '@type': 'SearchAction',
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${websiteUrl}/search?q={search_term_string}`
      },
      'query-input': 'required name=search_term_string'
    },

    // Related entities
    about: {
      '@type': 'Thing',
      name: 'Travis County Property Records',
      description: 'Official property appraisal and tax assessment records for Travis County, Texas'
    },

    // Geographic service area
    areaServed: {
      '@type': 'AdministrativeArea',
      name: 'Travis County',
      containedInPlace: {
        '@type': 'State',
        name: 'Texas',
        containedInPlace: {
          '@type': 'Country',
          name: 'United States'
        }
      }
    }
  };
}

// ============================================================================
// Breadcrumb JSON-LD
// ============================================================================

/**
 * Generate breadcrumb JSON-LD for navigation
 */
export function generateBreadcrumbJsonLd(
  items: Array<{ name: string; url?: string }>,
  websiteUrl = 'https://example.com'
): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: items.map((item, index) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: item.name,
      ...(item.url && {
        item: `${websiteUrl}${item.url}`
      })
    }))
  };
}

// ============================================================================
// Property Collection JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a collection of properties (e.g., by city or type)
 */
export function generatePropertyCollectionJsonLd(
  properties: PropertyAPI[],
  collectionName: string,
  collectionType: 'city' | 'type' | 'custom',
  websiteUrl = 'https://example.com'
): object {
  const totalValue = properties.reduce(
    (sum, p) => sum + p.valuation.appraisedValue.value,
    0
  );

  const avgValue = totalValue / properties.length;

  return {
    '@context': 'https://schema.org',
    '@type': 'CollectionPage',
    name: collectionName,
    description: `Collection of ${properties.length} properties`,

    // Main entity of the page
    mainEntity: {
      '@type': 'ItemList',
      numberOfItems: properties.length,
      itemListElement: properties.slice(0, 10).map((property, index) => ({
        '@type': 'ListItem',
        position: index + 1,
        item: {
          '@type': property['@type'] || 'RealEstateListing',
          identifier: property.propertyId,
          name: property.address.formatted,
          offers: {
            '@type': 'Offer',
            price: property.valuation.appraisedValue.value,
            priceCurrency: property.valuation.appraisedValue.currency
          },
          url: `${websiteUrl}/properties/${property.propertyId}`
        }
      }))
    },

    // Aggregate statistics
    aggregateRating: {
      '@type': 'AggregateOffer',
      lowPrice: Math.min(...properties.map(p => p.valuation.appraisedValue.value)),
      highPrice: Math.max(...properties.map(p => p.valuation.appraisedValue.value)),
      priceCurrency: 'USD',
      offerCount: properties.length,
      averagePrice: avgValue
    },

    // Collection metadata
    ...(collectionType === 'city' && {
      about: {
        '@type': 'City',
        name: collectionName
      }
    }),

    dateModified: new Date().toISOString()
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Inject JSON-LD script into HTML head
 */
export function injectJsonLdScript(jsonLd: object): string {
  return `<script type="application/ld+json">
${JSON.stringify(jsonLd, null, 2)}
</script>`;
}

/**
 * Generate multiple JSON-LD scripts for a page
 */
export function generatePageJsonLd(
  type: 'property' | 'listing' | 'home',
  data: any,
  websiteUrl = 'https://example.com'
): string[] {
  const scripts: string[] = [];

  switch (type) {
    case 'property':
      // Individual property page
      scripts.push(injectJsonLdScript(generatePropertyJsonLd(data, undefined, websiteUrl)));
      scripts.push(injectJsonLdScript(generateBreadcrumbJsonLd([
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' },
        { name: data.address.shortFormat }
      ], websiteUrl)));
      break;

    case 'listing':
      // Property listing/search results
      scripts.push(injectJsonLdScript(generatePropertyListJsonLd(data, undefined, websiteUrl)));
      scripts.push(injectJsonLdScript(generateBreadcrumbJsonLd([
        { name: 'Home', url: '/' },
        { name: 'Search Results' }
      ], websiteUrl)));
      break;

    case 'home':
      // Homepage
      scripts.push(injectJsonLdScript(generateOrganizationJsonLd(websiteUrl)));
      break;
  }

  return scripts;
}

/**
 * Validate JSON-LD structure
 * Returns validation errors if any
 */
export function validateJsonLd(jsonLd: any): string[] {
  const errors: string[] = [];

  // Check for required @context
  if (!jsonLd['@context']) {
    errors.push('Missing @context field');
  }

  // Check for required @type
  if (!jsonLd['@type']) {
    errors.push('Missing @type field');
  }

  // Validate RealEstateListing specific fields
  if (jsonLd['@type'] === 'RealEstateListing' ||
      (Array.isArray(jsonLd['@type']) && jsonLd['@type'].includes('RealEstateListing'))) {
    if (!jsonLd.address) {
      errors.push('RealEstateListing requires address field');
    }
    if (!jsonLd.offers && !jsonLd.price) {
      errors.push('RealEstateListing requires offers or price field');
    }
  }

  // Validate PostalAddress
  if (jsonLd.address && jsonLd.address['@type'] === 'PostalAddress') {
    if (!jsonLd.address.streetAddress) {
      errors.push('PostalAddress requires streetAddress');
    }
    if (!jsonLd.address.addressLocality && !jsonLd.address.addressRegion) {
      errors.push('PostalAddress requires addressLocality or addressRegion');
    }
  }

  return errors;
}

export default {
  generatePropertyJsonLd,
  generatePropertyListJsonLd,
  generateOrganizationJsonLd,
  generateBreadcrumbJsonLd,
  generatePropertyCollectionJsonLd,
  generatePageJsonLd,
  validateJsonLd,
  injectJsonLdScript
};
</file>

<file path="property.types.ts">
/**
 * TCAD Property Type Definitions with Schema.org Alignment
 *
 * This file provides TypeScript interfaces that align with Schema.org vocabulary
 * for maximum SEO value and semantic clarity. The types are designed to work
 * across frontend, backend, and provide excellent structured data for search engines.
 *
 * Schema.org Types Used:
 * - Place (https://schema.org/Place)
 * - RealEstateListing (https://schema.org/RealEstateListing)
 * - PropertyValue (https://schema.org/PropertyValue)
 * - PostalAddress (https://schema.org/PostalAddress)
 * - MonetaryAmount (https://schema.org/MonetaryAmount)
 * - GeoCoordinates (https://schema.org/GeoCoordinates)
 * - Organization (https://schema.org/Organization)
 * - Person (https://schema.org/Person)
 */

import { z } from 'zod';

// ============================================================================
// Database Level Types (Prisma/Backend)
// ============================================================================

/**
 * Database representation of a property matching Prisma schema
 * Maps to Schema.org: Place + RealEstateListing hybrid
 */
export interface PropertyDatabase {
  id: string;
  propertyId: string;           // TCAD unique identifier
  name: string;                 // Owner/taxpayer name
  propType: string;             // Property classification
  city: string | null;
  propertyAddress: string;
  assessedValue: number | null;  // Tax assessed value
  appraisedValue: number;        // Market appraised value
  geoId: string | null;          // Geographic identifier
  description: string | null;    // Legal description
  searchTerm: string | null;
  scrapedAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Property type enumeration based on common TCAD classifications
 * Maps to Schema.org: @type values for subtypes of Place/Residence
 */
export enum PropertyType {
  SINGLE_FAMILY = 'Single Family',
  CONDO = 'Condo',
  TOWNHOUSE = 'Townhouse',
  MULTI_FAMILY = 'Multi Family',
  COMMERCIAL = 'Commercial',
  INDUSTRIAL = 'Industrial',
  LAND = 'Land',
  AGRICULTURAL = 'Agricultural',
  MIXED_USE = 'Mixed Use'
}

// ============================================================================
// API Level Types (Frontend/API Response)
// ============================================================================

/**
 * API representation with Schema.org alignment
 * Enhanced with semantic annotations for structured data
 * Maps to Schema.org: RealEstateListing
 */
export interface PropertyAPI {
  // Core identification
  '@context'?: 'https://schema.org';
  '@type'?: 'RealEstateListing' | 'Place' | 'Residence';
  '@id'?: string;               // Unique URI for this property

  id: string;
  propertyId: string;           // Schema.org: identifier

  // Ownership (Schema.org: seller/owner)
  owner: PropertyOwner;

  // Property details (Schema.org: name, description)
  propertyType: string;         // Schema.org: additionalType
  legalDescription?: string;    // Schema.org: description

  // Location (Schema.org: address, geo)
  address: PropertyAddress;
  geography?: PropertyGeography;

  // Valuation (Schema.org: offers/priceSpecification)
  valuation: PropertyValuation;

  // Metadata
  metadata: PropertyMetadata;
}

/**
 * Property owner information
 * Maps to Schema.org: Person or Organization
 */
export interface PropertyOwner {
  '@type'?: 'Person' | 'Organization';
  name: string;                 // Schema.org: name
  type?: 'individual' | 'entity'; // Determines Person vs Organization
}

/**
 * Property address with full Schema.org PostalAddress alignment
 */
export interface PropertyAddress {
  '@type'?: 'PostalAddress';
  streetAddress: string;        // Schema.org: streetAddress
  addressLocality?: string;     // Schema.org: addressLocality (city)
  addressRegion: string;        // Schema.org: addressRegion (state)
  addressCountry: string;       // Schema.org: addressCountry
  postalCode?: string;          // Schema.org: postalCode

  // Formatted versions
  formatted: string;            // Full formatted address
  shortFormat?: string;         // Abbreviated format for display
}

/**
 * Geographic information for the property
 * Maps to Schema.org: GeoCoordinates + geo properties
 */
export interface PropertyGeography {
  '@type'?: 'GeoCoordinates';
  geoId?: string;               // TCAD geographic identifier
  latitude?: number;            // Schema.org: latitude
  longitude?: number;           // Schema.org: longitude
  elevation?: number;           // Schema.org: elevation

  // Additional geographic context
  neighborhood?: string;        // Schema.org: containedInPlace
  schoolDistrict?: string;
  taxDistrict?: string;
  censusTract?: string;
}

/**
 * Property valuation information
 * Maps to Schema.org: PriceSpecification / PropertyValue
 */
export interface PropertyValuation {
  '@type'?: 'PropertyValue';

  // Assessed value for tax purposes
  assessedValue?: MonetaryAmount;

  // Market appraisal value
  appraisedValue: MonetaryAmount;

  // Additional valuation details
  landValue?: MonetaryAmount;
  improvementValue?: MonetaryAmount;

  // Tax information
  taxableValue?: MonetaryAmount;
  exemptions?: TaxExemption[];

  // Valuation metadata
  valuationDate?: string;       // ISO 8601 date
  valuationMethod?: string;
}

/**
 * Monetary amount with currency
 * Maps to Schema.org: MonetaryAmount
 */
export interface MonetaryAmount {
  '@type'?: 'MonetaryAmount';
  value: number;                // Schema.org: value
  currency: string;             // Schema.org: currency (e.g., "USD")

  // Display helpers
  formatted?: string;           // e.g., "$450,000"
  abbreviated?: string;         // e.g., "$450K"
}

/**
 * Tax exemption information
 */
export interface TaxExemption {
  type: string;                 // e.g., "Homestead", "Senior", "Veteran"
  amount: MonetaryAmount;
  percentage?: number;          // If percentage-based exemption
}

/**
 * Property metadata for tracking and management
 */
export interface PropertyMetadata {
  searchTerm?: string;          // Search term that found this property
  dataSource: string;           // e.g., "TCAD"
  scrapedAt: string;           // ISO 8601 datetime
  createdAt: string;           // ISO 8601 datetime
  updatedAt: string;           // ISO 8601 datetime
  dataFreshness?: 'current' | 'stale' | 'historical';
  lastVerified?: string;        // ISO 8601 datetime
}

// ============================================================================
// Legacy Validation Schemas (Preserved for backward compatibility)
// ============================================================================

export const scrapeRequestSchema = z.object({
  searchTerm: z.string().min(4, 'Search term must be at least 4 characters').max(100),
  userId: z.string().optional(),
});

export const propertyFilterSchema = z.object({
  searchTerm: z.string().optional(),
  city: z.string().optional(),
  propType: z.string().optional(),
  minValue: z.coerce.number().optional(),
  maxValue: z.coerce.number().optional(),
  limit: z.coerce.number().min(1).max(1000).default(100),
  offset: z.coerce.number().min(0).default(0),
});

export const naturalLanguageSearchSchema = z.object({
  query: z.string().min(1),
  limit: z.number().min(1).max(1000).optional(),
  offset: z.number().min(0).optional(),
});

export const historyQuerySchema = z.object({
  limit: z.coerce.number().min(1).max(100).default(20),
  offset: z.coerce.number().min(0).default(0),
});

export const monitorRequestSchema = z.object({
  searchTerm: z.string().min(1),
  frequency: z.enum(['hourly', 'daily', 'weekly']).default('daily'),
});

// Legacy type exports
export type ScrapeRequestBody = z.infer<typeof scrapeRequestSchema>;
export type PropertyFilters = z.infer<typeof propertyFilterSchema>;
export type NaturalLanguageSearchBody = z.infer<typeof naturalLanguageSearchSchema>;
export type HistoryQueryParams = z.infer<typeof historyQuerySchema>;
export type MonitorRequestBody = z.infer<typeof monitorRequestSchema>;

// ============================================================================
// Enhanced Search and Filter Types
// ============================================================================

/**
 * Search parameters for querying properties
 */
export interface PropertySearchParams {
  query?: string;               // Full text search
  propertyTypes?: PropertyType[];
  cities?: string[];
  priceRange?: {
    min?: number;
    max?: number;
  };
  owner?: string;
  propertyId?: string;
  geoId?: string;

  // Pagination
  limit?: number;
  offset?: number;

  // Sorting
  sortBy?: 'appraisedValue' | 'assessedValue' | 'address' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

// ============================================================================
// Response Types
// ============================================================================

export interface PaginationMeta {
  total: number;
  limit: number;
  offset: number;
  hasMore: boolean;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: PaginationMeta;
}

/**
 * Paginated property response with Schema.org alignment
 */
export interface PaginatedPropertyResponse {
  '@context'?: 'https://schema.org';
  '@type'?: 'SearchResultsPage';

  results: PropertyAPI[];
  pagination: PaginationMeta;

  // Aggregations for filtering
  aggregations?: {
    propertyTypes: Array<{ type: string; count: number }>;
    cities: Array<{ city: string; count: number }>;
    priceRanges: Array<{ range: string; count: number }>;
  };
}

export interface JobStatusResponse {
  id: string;
  status: string;
  progress: number;
  resultCount?: number;
  error?: string | null;
  createdAt: Date;
  completedAt: Date | null;
}

export interface StatsResponse {
  totalProperties: number;
  totalJobs: number;
  recentJobs: number;
  cityDistribution: Array<{
    city: string;
    _count: number;
  }>;
  propertyTypeDistribution: Array<{
    propType: string;
    _count: number;
    _avg: {
      appraisedValue: number | null;
    };
  }>;
}

// ============================================================================
// Transformation Utilities
// ============================================================================

/**
 * Transform database property to API format with Schema.org alignment
 */
export function transformPropertyToAPI(
  dbProperty: PropertyDatabase,
  includeSchemaContext = true
): PropertyAPI {
  const [streetAddress, ...addressParts] = dbProperty.propertyAddress.split(',').map(s => s.trim());

  return {
    ...(includeSchemaContext && {
      '@context': 'https://schema.org',
      '@type': getSchemaType(dbProperty.propType),
      '@id': `/properties/${dbProperty.propertyId}`
    }),

    id: dbProperty.id,
    propertyId: dbProperty.propertyId,

    owner: {
      '@type': dbProperty.name.includes('LLC') || dbProperty.name.includes('INC')
        ? 'Organization'
        : 'Person',
      name: dbProperty.name,
      type: dbProperty.name.includes('LLC') || dbProperty.name.includes('INC')
        ? 'entity'
        : 'individual'
    },

    propertyType: dbProperty.propType,
    legalDescription: dbProperty.description || undefined,

    address: {
      '@type': 'PostalAddress',
      streetAddress,
      addressLocality: dbProperty.city || 'Austin',
      addressRegion: 'TX',
      addressCountry: 'US',
      formatted: dbProperty.propertyAddress,
      shortFormat: `${streetAddress}, ${dbProperty.city || 'Austin'}`
    },

    geography: dbProperty.geoId ? {
      '@type': 'GeoCoordinates',
      geoId: dbProperty.geoId
    } : undefined,

    valuation: {
      '@type': 'PropertyValue',
      assessedValue: dbProperty.assessedValue ? {
        '@type': 'MonetaryAmount',
        value: dbProperty.assessedValue,
        currency: 'USD',
        formatted: formatCurrency(dbProperty.assessedValue)
      } : undefined,
      appraisedValue: {
        '@type': 'MonetaryAmount',
        value: dbProperty.appraisedValue,
        currency: 'USD',
        formatted: formatCurrency(dbProperty.appraisedValue)
      }
    },

    metadata: {
      searchTerm: dbProperty.searchTerm || undefined,
      dataSource: 'TCAD',
      scrapedAt: dbProperty.scrapedAt.toISOString(),
      createdAt: dbProperty.createdAt.toISOString(),
      updatedAt: dbProperty.updatedAt.toISOString(),
      dataFreshness: getDataFreshness(dbProperty.scrapedAt)
    }
  };
}

/**
 * Get appropriate Schema.org type based on property type
 */
function getSchemaType(propType: string): 'RealEstateListing' | 'Place' | 'Residence' {
  const commercialTypes = ['Commercial', 'Industrial', 'Mixed Use'];
  const residentialTypes = ['Single Family', 'Condo', 'Townhouse', 'Multi Family'];

  if (commercialTypes.includes(propType)) {
    return 'Place';
  } else if (residentialTypes.includes(propType)) {
    return 'Residence';
  }
  return 'RealEstateListing';
}

/**
 * Format currency for display
 */
function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(value);
}

/**
 * Determine data freshness based on scrape date
 */
function getDataFreshness(scrapedAt: Date): 'current' | 'stale' | 'historical' {
  const daysSinceUpdate = (Date.now() - scrapedAt.getTime()) / (1000 * 60 * 60 * 24);

  if (daysSinceUpdate < 7) return 'current';
  if (daysSinceUpdate < 30) return 'stale';
  return 'historical';
}

// ============================================================================
// Type Guards
// ============================================================================

export function isPropertyDatabase(obj: any): obj is PropertyDatabase {
  return obj &&
    typeof obj.propertyId === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.propType === 'string' &&
    typeof obj.propertyAddress === 'string' &&
    typeof obj.appraisedValue === 'number';
}

export function isPropertyAPI(obj: any): obj is PropertyAPI {
  return obj &&
    typeof obj.propertyId === 'string' &&
    obj.owner &&
    obj.address &&
    obj.valuation;
}
</file>

<file path="README_ENHANCED.md">
# types

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "types",
  "description": "Directory containing 2 code files with 17 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "17 class definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Files and Schemas

### `json-ld.utils.ts` (typescript)

**Classes:**
- `JsonLdBase` - Line 17
- `BreadcrumbItem` - Line 23
- `SearchAction` - Line 30

### `property.types.ts` (typescript)

**Classes:**
- `PropertyDatabase` - Line 28
- `PropertyAPI` - Line 70
- `PropertyOwner` - Line 101
- `PropertyAddress` - Line 110
- `PropertyGeography` - Line 127
- `PropertyValuation` - Line 145
- `MonetaryAmount` - Line 171
- `TaxExemption` - Line 184
- `PropertyMetadata` - Line 193
- `PropertySearchParams` - Line 252
- `PaginationMeta` - Line 277
- `PaginatedPropertyResponse` - Line 292
- `JobStatusResponse` - Line 307
- `StatsResponse` - Line 317

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="SCHEMA-DOCUMENTATION.md">
# TCAD Property Schema.org Type System Documentation

## Overview

This document describes the comprehensive TypeScript type system designed for the Travis County Appraisal District (TCAD) property scraper application. The type system aligns with Schema.org vocabulary to provide maximum SEO value and semantic clarity.

## Architecture

### Three-Layer Type System

1. **Database Layer** (`PropertyDatabase`) - Matches Prisma schema exactly
2. **API Layer** (`PropertyAPI`) - Enhanced with Schema.org properties
3. **Presentation Layer** (JSON-LD) - Full Schema.org structured data

## Schema.org Type Mapping

### Primary Schema.org Types Used

| TCAD Property Type | Schema.org Type | Use Case |
|-------------------|-----------------|----------|
| Single Family | `Residence` | Residential homes |
| Condo | `Residence` | Condominiums |
| Townhouse | `Residence` | Townhomes |
| Multi Family | `Residence` | Apartments/Duplexes |
| Commercial | `Place` | Business properties |
| Industrial | `Place` | Industrial facilities |
| Land | `RealEstateListing` | Vacant land |
| Agricultural | `Place` | Farms/Ranches |
| Mixed Use | `Place` | Mixed-use buildings |

### Property Components Schema Mapping

| Component | Schema.org Type | Properties |
|-----------|-----------------|------------|
| Address | `PostalAddress` | streetAddress, addressLocality, addressRegion, postalCode |
| Location | `GeoCoordinates` | latitude, longitude, elevation |
| Owner | `Person` / `Organization` | name, type |
| Valuation | `PropertyValue` / `MonetaryAmount` | value, currency |
| Tax Info | `PriceSpecification` | price, name, description |

## Type Definitions

### Core Types

```typescript
// Database representation (Prisma)
PropertyDatabase

// API representation (Frontend/Backend)
PropertyAPI

// Search/Filter types
PropertySearchParams
PaginatedPropertyResponse

// Supporting types
PropertyOwner
PropertyAddress
PropertyGeography
PropertyValuation
MonetaryAmount
TaxExemption
```

## Implementation Examples

### 1. Transform Database to API Format

```typescript
import { transformPropertyToAPI } from './types/property.types';

const dbProperty = await prisma.property.findUnique({
  where: { propertyId: 'TCAD-123456' }
});

const apiProperty = transformPropertyToAPI(dbProperty);
```

### 2. Generate JSON-LD for SEO

```typescript
import { generatePropertyJsonLd } from './utils/json-ld.utils';

const jsonLd = generatePropertyJsonLd(
  apiProperty,
  'Travis County Appraisal District',
  'https://example.com'
);

// Inject into HTML
const script = `<script type="application/ld+json">
${JSON.stringify(jsonLd, null, 2)}
</script>`;
```

### 3. API Response with Schema.org

```typescript
app.get('/api/properties/:id', async (req, res) => {
  const property = await getProperty(req.params.id);
  const apiProperty = transformPropertyToAPI(property);

  res.json({
    '@context': 'https://schema.org',
    ...apiProperty
  });
});
```

### 4. Property Listing Page

```typescript
app.get('/api/properties', async (req, res) => {
  const properties = await searchProperties(req.query);

  const response: PaginatedPropertyResponse = {
    '@context': 'https://schema.org',
    '@type': 'SearchResultsPage',
    results: properties.map(p => transformPropertyToAPI(p)),
    pagination: {
      total: totalCount,
      limit: 20,
      offset: 0,
      hasMore: true
    }
  };

  res.json(response);
});
```

## SEO Benefits

### Rich Results Eligibility

The Schema.org implementation enables:

1. **Property Rich Cards** - Enhanced search results with images, prices, and details
2. **Breadcrumb Navigation** - Clear site hierarchy in search results
3. **Site Search Box** - Direct search from Google results
4. **Knowledge Graph** - Entity recognition for properties and locations
5. **Local Search** - Enhanced local business/property listings

### Structured Data Features

- **Price Range Display** - Shows min/max prices in search results
- **Location Mapping** - Geographic coordinates for map integration
- **Owner Information** - Clear entity attribution
- **Tax Information** - Detailed financial breakdowns
- **Property Classifications** - Clear categorization for filtering

## JSON-LD Examples

### Individual Property

```json
{
  "@context": "https://schema.org",
  "@type": "RealEstateListing",
  "@id": "https://example.com/properties/TCAD-123456",
  "identifier": "TCAD-123456",
  "name": "123 Main St, Austin TX",
  "address": {
    "@type": "PostalAddress",
    "streetAddress": "123 Main St",
    "addressLocality": "Austin",
    "addressRegion": "TX",
    "addressCountry": "US",
    "postalCode": "78701"
  },
  "offers": {
    "@type": "Offer",
    "price": 450000,
    "priceCurrency": "USD"
  }
}
```

### Property Collection

```json
{
  "@context": "https://schema.org",
  "@type": "ItemList",
  "name": "Austin Properties",
  "numberOfItems": 100,
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "item": {
        "@type": "RealEstateListing",
        "identifier": "TCAD-123456",
        "name": "123 Main St"
      }
    }
  ]
}
```

## Validation

### Schema.org Validation Tools

1. **Google Rich Results Test**: https://search.google.com/test/rich-results
2. **Schema.org Validator**: https://validator.schema.org/
3. **Google Search Console**: Monitor rich results performance

### TypeScript Type Validation

```typescript
import { isPropertyAPI, isPropertyDatabase } from './types/property.types';

// Runtime type guards
if (isPropertyAPI(data)) {
  // Safe to use as PropertyAPI
}

// Compile-time validation with Zod
import { propertyFilterSchema } from './types/property.types';

const filters = propertyFilterSchema.parse(req.query);
```

## Best Practices

### 1. Always Include Context

```typescript
// Good
const property: PropertyAPI = {
  '@context': 'https://schema.org',
  '@type': 'RealEstateListing',
  // ...
};

// Bad - missing context
const property = {
  propertyId: '123',
  // ...
};
```

### 2. Use Specific Schema Types

```typescript
// Good - specific type
'@type': 'Residence'  // for residential properties

// Bad - generic type
'@type': 'Thing'
```

### 3. Include All Recommended Properties

Essential properties for rich results:
- `name` - Property title
- `address` - Full postal address
- `offers.price` - Current value
- `geo` - Coordinates when available
- `image` - Property photos (when available)

### 4. Maintain Data Consistency

```typescript
// Ensure consistency between visible content and structured data
<h1>{property.address.formatted}</h1>  // Visible
"name": "123 Main St, Austin TX"       // Structured data matches
```

### 5. Update Timestamps

```typescript
metadata: {
  scrapedAt: new Date().toISOString(),
  dataFreshness: getDataFreshness(scrapedAt),
  lastVerified: new Date().toISOString()
}
```

## Migration Guide

### From Legacy Types to Schema.org Types

```typescript
// Legacy
interface OldProperty {
  property_id: string;
  owner_name: string;
  value: number;
}

// New Schema.org aligned
interface PropertyAPI {
  propertyId: string;
  owner: {
    '@type': 'Person',
    name: string;
  };
  valuation: {
    appraisedValue: {
      '@type': 'MonetaryAmount',
      value: number;
      currency: 'USD';
    };
  };
}
```

## Testing

### Unit Tests

```typescript
describe('Property Type Transformations', () => {
  it('should transform database property to API format', () => {
    const dbProperty: PropertyDatabase = mockDbProperty();
    const apiProperty = transformPropertyToAPI(dbProperty);

    expect(apiProperty['@context']).toBe('https://schema.org');
    expect(apiProperty['@type']).toMatch(/RealEstateListing|Residence|Place/);
    expect(apiProperty.address['@type']).toBe('PostalAddress');
  });
});
```

### Validation Tests

```typescript
describe('JSON-LD Validation', () => {
  it('should generate valid structured data', () => {
    const jsonLd = generatePropertyJsonLd(mockProperty);
    const errors = validateJsonLd(jsonLd);

    expect(errors).toHaveLength(0);
  });
});
```

## Performance Considerations

1. **Lazy Loading** - Include full Schema.org context only when needed
2. **Caching** - Cache transformed API responses
3. **Selective Fields** - Use `includeSchemaContext` parameter
4. **Batch Processing** - Transform multiple properties efficiently

## Future Enhancements

1. **Additional Schema Types**
   - `ApartmentComplex` for multi-family
   - `Office` for commercial properties
   - `Store` for retail properties

2. **Enhanced Geographic Data**
   - School district boundaries
   - Neighborhood polygons
   - Transit accessibility

3. **Historical Data**
   - `PriceSpecification` with date ranges
   - Value trend graphs
   - Tax history

4. **Images and Media**
   - `ImageObject` for property photos
   - `VideoObject` for virtual tours
   - `3DModel` for interactive views

## Resources

- [Schema.org Documentation](https://schema.org/)
- [Google Structured Data Guide](https://developers.google.com/search/docs/appearance/structured-data)
- [JSON-LD Specification](https://json-ld.org/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
</file>

</files>
