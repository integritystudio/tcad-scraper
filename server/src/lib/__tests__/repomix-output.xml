This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
claude.service.test.ts
metrics.service.test.ts
prisma.test.ts
redis-cache.service.test.ts
search-term-deduplicator.test.ts
tcad-scraper.test.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="claude.service.test.ts">
/**
 * Claude Search Service Tests
 */

import { describe, test, expect, jest, beforeEach, afterEach } from '@jest/globals';

// Mock the config module before importing claude.service
jest.mock('../../config', () => ({
  config: {
    claude: {
      apiKey: 'test-api-key',
      model: 'claude-3-haiku-20240307',
      maxTokens: 1024,
    },
  },
}));

// Mock Anthropic SDK
const mockCreate = jest.fn();
jest.mock('@anthropic-ai/sdk', () => {
  return jest.fn().mockImplementation(() => ({
    messages: {
      create: mockCreate,
    },
  }));
});

// Import after mocks are set up
import { ClaudeSearchService } from '../claude.service';

describe('ClaudeSearchService', () => {
  let service: ClaudeSearchService;

  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
    service = new ClaudeSearchService();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('parseNaturalLanguageQuery', () => {
    describe('Successful Claude API Responses', () => {
      test('should parse city-based query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                city: { contains: 'Austin', mode: 'insensitive' }
              },
              explanation: 'Searching for properties in Austin'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties in Austin');

        expect(result.whereClause).toEqual({
          city: { contains: 'Austin', mode: 'insensitive' }
        });
        expect(result.explanation).toBe('Searching for properties in Austin');
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should parse value-based query with range', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                appraisedValue: { gte: 300000, lte: 600000 }
              },
              orderBy: { appraisedValue: 'asc' },
              explanation: 'Searching for properties with appraised value between $300,000 and $600,000'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties appraised between 300k and 600k');

        expect(result.whereClause).toEqual({
          appraisedValue: { gte: 300000, lte: 600000 }
        });
        expect(result.orderBy).toEqual({ appraisedValue: 'asc' });
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should parse owner name query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                name: { contains: 'Smith', mode: 'insensitive' }
              },
              explanation: 'Searching for properties owned by Smith'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties owned by Smith');

        expect(result.whereClause).toEqual({
          name: { contains: 'Smith', mode: 'insensitive' }
        });
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should parse property type query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                propType: { contains: 'Commercial', mode: 'insensitive' }
              },
              explanation: 'Searching for commercial properties'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('commercial properties');

        expect(result.whereClause).toEqual({
          propType: { contains: 'Commercial', mode: 'insensitive' }
        });
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should parse address-based query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                propertyAddress: { contains: 'Congress', mode: 'insensitive' }
              },
              explanation: "Searching for properties with 'Congress' in the address"
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties on Congress Ave');

        expect(result.whereClause).toEqual({
          propertyAddress: { contains: 'Congress', mode: 'insensitive' }
        });
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should parse complex combined query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                city: 'Austin',
                propType: { contains: 'Residential', mode: 'insensitive' },
                appraisedValue: { gte: 500000 }
              },
              orderBy: { appraisedValue: 'desc' },
              explanation: 'Searching for residential properties in Austin with appraised value over $500,000, sorted by value (highest first)'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('residential properties in Austin worth over 500k');

        expect(result.whereClause).toEqual({
          city: 'Austin',
          propType: { contains: 'Residential', mode: 'insensitive' },
          appraisedValue: { gte: 500000 }
        });
        expect(result.orderBy).toEqual({ appraisedValue: 'desc' });
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should handle orderBy being optional', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                city: { contains: 'Austin', mode: 'insensitive' }
              },
              explanation: 'Searching for properties in Austin'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties in Austin');

        expect(result.whereClause).toBeDefined();
        expect(result.orderBy).toBeUndefined();
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });
    });

    describe('Error Handling and Fallback', () => {
      test('should fallback to simple text search on API error', async () => {
        mockCreate.mockRejectedValue(new Error('API Error'));

        const result = await service.parseNaturalLanguageQuery('test query');

        expect(result.whereClause).toEqual({
          OR: [
            { name: { contains: 'test query', mode: 'insensitive' } },
            { propertyAddress: { contains: 'test query', mode: 'insensitive' } },
            { city: { contains: 'test query', mode: 'insensitive' } },
            { description: { contains: 'test query', mode: 'insensitive' } },
          ]
        });
        expect(result.explanation).toBe('Searching for "test query" across property names, addresses, cities, and descriptions');
      });

      test('should fallback on authentication error', async () => {
        mockCreate.mockRejectedValue(new Error('401 authentication_error: invalid x-api-key'));

        const result = await service.parseNaturalLanguageQuery('Austin properties');

        expect(result.whereClause.OR).toBeDefined();
        expect(result.whereClause.OR).toHaveLength(4);
      });

      test('should fallback on model not found error', async () => {
        mockCreate.mockRejectedValue(new Error('404 not_found_error: model: claude-3-5-sonnet-20241022'));

        const result = await service.parseNaturalLanguageQuery('Austin properties');

        expect(result.whereClause.OR).toBeDefined();
        expect(result.explanation).toContain('Austin properties');
      });

      test('should fallback on invalid JSON response', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: 'Invalid JSON response'
          }]
        });

        const result = await service.parseNaturalLanguageQuery('test query');

        expect(result.whereClause.OR).toBeDefined();
      });

      test('should fallback on empty response', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: ''
          }]
        });

        const result = await service.parseNaturalLanguageQuery('test query');

        expect(result.whereClause.OR).toBeDefined();
      });

      test('should handle missing whereClause in response', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              explanation: 'Some explanation'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('test query');

        expect(result.whereClause).toEqual({});
        expect(result.explanation).toBe('Some explanation');
      });

      test('should provide default explanation when missing', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: { city: 'Austin' }
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('test query');

        expect(result.explanation).toBe('Searching properties based on your query');
      });
    });

    describe('API Request Parameters', () => {
      test('should use correct model', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({ whereClause: {}, explanation: 'Test' })
          }]
        });

        await service.parseNaturalLanguageQuery('test');

        expect(mockCreate).toHaveBeenCalledWith(
          expect.objectContaining({
            model: 'claude-3-haiku-20240307'
          })
        );
      });

      test('should set appropriate max_tokens', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({ whereClause: {}, explanation: 'Test' })
          }]
        });

        await service.parseNaturalLanguageQuery('test');

        expect(mockCreate).toHaveBeenCalledWith(
          expect.objectContaining({
            max_tokens: 1024
          })
        );
      });

      test('should include user query in prompt', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({ whereClause: {}, explanation: 'Test' })
          }]
        });

        await service.parseNaturalLanguageQuery('find expensive homes');

        const callArgs = mockCreate.mock.calls[0][0];
        expect(callArgs.messages[0].content).toContain('find expensive homes');
      });
    });

    describe('Edge Cases', () => {
      test('should handle empty query string', async () => {
        mockCreate.mockRejectedValue(new Error('Empty query'));

        const result = await service.parseNaturalLanguageQuery('');

        expect(result.whereClause.OR).toBeDefined();
      });

      test('should handle very long query', async () => {
        const longQuery = 'properties '.repeat(100);
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: { city: 'Austin' },
              explanation: 'Processed long query'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery(longQuery);

        expect(result.whereClause).toBeDefined();
        expect(mockCreate).toHaveBeenCalledTimes(1);
      });

      test('should handle special characters in query', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: { propertyAddress: { contains: "O'Connor", mode: 'insensitive' } },
              explanation: 'Searching for properties on O\'Connor'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery("properties on O'Connor St");

        expect(result.whereClause).toBeDefined();
      });

      test('should handle Unicode characters', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: { city: { contains: 'São Paulo', mode: 'insensitive' } },
              explanation: 'Searching for properties in São Paulo'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties in São Paulo');

        expect(result.whereClause).toBeDefined();
      });
    });

    describe('Schema Field Names', () => {
      test('should use searchTerm field (camelCase) not search_term', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                searchTerm: { contains: 'Smith', mode: 'insensitive' }
              },
              explanation: 'Searching for properties found via Smith search term'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties from Smith search');

        expect(result.whereClause).toEqual({
          searchTerm: { contains: 'Smith', mode: 'insensitive' }
        });
        expect(result.explanation).toBe('Searching for properties found via Smith search term');
      });

      test('should use propType field (camelCase) not prop_type', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                propType: { contains: 'Residential', mode: 'insensitive' }
              },
              explanation: 'Searching for residential properties'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('residential properties');

        expect(result.whereClause).toHaveProperty('propType');
        expect(result.whereClause).not.toHaveProperty('prop_type');
      });

      test('should use propertyAddress field (camelCase) not property_address', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                propertyAddress: { contains: 'Main St', mode: 'insensitive' }
              },
              explanation: 'Searching for properties on Main St'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties on Main St');

        expect(result.whereClause).toHaveProperty('propertyAddress');
        expect(result.whereClause).not.toHaveProperty('property_address');
      });

      test('should use appraisedValue field (camelCase) not appraised_value', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({
              whereClause: {
                appraisedValue: { gte: 500000 }
              },
              orderBy: { appraisedValue: 'desc' },
              explanation: 'Searching for properties appraised over $500,000'
            })
          }]
        });

        const result = await service.parseNaturalLanguageQuery('properties worth over 500k');

        expect(result.whereClause).toHaveProperty('appraisedValue');
        expect(result.whereClause).not.toHaveProperty('appraised_value');
        expect(result.orderBy).toHaveProperty('appraisedValue');
      });

      test('should verify prompt includes correct Prisma field names', async () => {
        mockCreate.mockResolvedValue({
          content: [{
            type: 'text',
            text: JSON.stringify({ whereClause: {}, explanation: 'Test' })
          }]
        });

        await service.parseNaturalLanguageQuery('test');

        const callArgs = mockCreate.mock.calls[0][0];
        const prompt = callArgs.messages[0].content;

        // Verify the prompt uses camelCase Prisma field names, not snake_case DB names
        expect(prompt).toContain('searchTerm');
        expect(prompt).toContain('propType');
        expect(prompt).toContain('propertyAddress');
        expect(prompt).toContain('appraisedValue');
        expect(prompt).toContain('assessedValue');
        expect(prompt).toContain('geoId');
        expect(prompt).toContain('scrapedAt');
        expect(prompt).toContain('createdAt');
        expect(prompt).toContain('updatedAt');

        // Should NOT contain snake_case versions
        expect(prompt).not.toContain('search_term');
        expect(prompt).not.toContain('prop_type');
        expect(prompt).not.toContain('property_address');
        expect(prompt).not.toContain('appraised_value');
        expect(prompt).not.toContain('assessed_value');
      });
    });
  });
});
</file>

<file path="metrics.service.test.ts">
import {
  getMetrics,
  getRegistry,
  resetMetrics,
  updateQueueMetrics,
  updateCacheMetrics,
  recordHttpRequest,
  recordScrapeJob,
  recordDbQuery,
  recordCacheOperation,
  recordError,
  updateCodeComplexityMetrics,
  httpRequestsTotal,
  httpRequestDuration,
  scrapeJobsTotal,
  scrapeJobDuration,
  propertiesScrapedTotal,
  activeScrapeJobs,
  queueSize,
  dbQueryDuration,
  dbQueriesTotal,
  cacheOperations,
  cacheHitRate,
  cacheSize,
  errorsTotal,
  codeComplexityCyclomatic,
  type CodeComplexityMetrics,
} from '../metrics.service';

describe('Metrics Service', () => {
  beforeEach(() => {
    // Reset all metrics before each test
    resetMetrics();
  });

  describe('Registry', () => {
    test('should return a valid registry', () => {
      const registry = getRegistry();
      expect(registry).toBeDefined();
      expect(typeof registry.metrics).toBe('function');
    });

    test('should return metrics in Prometheus format', async () => {
      const metrics = await getMetrics();
      expect(typeof metrics).toBe('string');
      expect(metrics).toContain('tcad_scraper_');
    });
  });

  describe('HTTP Metrics', () => {
    test('should record HTTP requests', async () => {
      recordHttpRequest('GET', '/api/properties', 200, 0.5);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_http_requests_total');
      expect(metrics).toContain('method="GET"');
      expect(metrics).toContain('route="/api/properties"');
      expect(metrics).toContain('status_code="200"');
    });

    test('should record multiple HTTP requests', async () => {
      recordHttpRequest('GET', '/api/properties', 200, 0.5);
      recordHttpRequest('GET', '/api/properties', 200, 0.3);
      recordHttpRequest('POST', '/api/search', 201, 1.2);

      const metrics = await getMetrics();
      expect(metrics).toContain('method="GET"');
      expect(metrics).toContain('method="POST"');
      expect(metrics).toContain('status_code="200"');
      expect(metrics).toContain('status_code="201"');
    });

    test('should record HTTP request durations', async () => {
      recordHttpRequest('GET', '/api/properties', 200, 1.5);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_http_request_duration_seconds');
      expect(metrics).toContain('method="GET"');
    });
  });

  describe('Scrape Job Metrics', () => {
    test('should record completed scrape job', async () => {
      recordScrapeJob('completed', 30.5, 10);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_jobs_total');
      expect(metrics).toContain('status="completed"');
      expect(metrics).toContain('tcad_scraper_properties_scraped_total');
    });

    test('should record failed scrape job', async () => {
      recordScrapeJob('failed', 15.2);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_jobs_total');
      expect(metrics).toContain('status="failed"');
    });

    test('should record job durations', async () => {
      recordScrapeJob('completed', 45.3, 20);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_job_duration_seconds');
      expect(metrics).toContain('status="completed"');
    });

    test('should not increment properties for completed job without count', async () => {
      resetMetrics();
      recordScrapeJob('completed', 30.5);

      const metrics = await getMetrics();
      // Should not contain properties_scraped metric if no count provided
      const lines = metrics.split('\n');
      const propertiesLines = lines.filter(l => l.includes('tcad_scraper_properties_scraped_total') && !l.startsWith('#'));
      expect(propertiesLines.length).toBe(0);
    });
  });

  describe('Queue Metrics', () => {
    test('should update queue metrics', async () => {
      await updateQueueMetrics(5, 2, 100, 3);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_queue_size');
      expect(metrics).toContain('status="waiting"');
      expect(metrics).toContain('status="active"');
      expect(metrics).toContain('tcad_scraper_active_jobs');
    });

    test('should update queue metrics to zero', async () => {
      await updateQueueMetrics(0, 0, 50, 0);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_queue_size');
      expect(metrics).toContain('tcad_scraper_active_jobs');
    });
  });

  describe('Database Metrics', () => {
    test('should record successful database query', async () => {
      recordDbQuery('select', 'properties', 'success', 0.05);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_db_queries_total');
      expect(metrics).toContain('operation="select"');
      expect(metrics).toContain('table="properties"');
      expect(metrics).toContain('status="success"');
      expect(metrics).toContain('tcad_scraper_db_query_duration_seconds');
    });

    test('should record failed database query', async () => {
      recordDbQuery('insert', 'properties', 'error', 0.02);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_db_queries_total');
      expect(metrics).toContain('operation="insert"');
      expect(metrics).toContain('status="error"');
    });

    test('should track different database operations', async () => {
      recordDbQuery('select', 'properties', 'success', 0.01);
      recordDbQuery('insert', 'properties', 'success', 0.03);
      recordDbQuery('update', 'properties', 'success', 0.02);
      recordDbQuery('delete', 'properties', 'success', 0.01);

      const metrics = await getMetrics();
      expect(metrics).toContain('operation="select"');
      expect(metrics).toContain('operation="insert"');
      expect(metrics).toContain('operation="update"');
      expect(metrics).toContain('operation="delete"');
    });
  });

  describe('Cache Metrics', () => {
    test('should record cache hit', async () => {
      recordCacheOperation('get', 'hit');

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_cache_operations_total');
      expect(metrics).toContain('operation="get"');
      expect(metrics).toContain('status="hit"');
    });

    test('should record cache miss', async () => {
      recordCacheOperation('get', 'miss');

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_cache_operations_total');
      expect(metrics).toContain('status="miss"');
    });

    test('should record cache set operations', async () => {
      recordCacheOperation('set', 'success');

      const metrics = await getMetrics();
      expect(metrics).toContain('operation="set"');
      expect(metrics).toContain('status="success"');
    });

    test('should record cache delete operations', async () => {
      recordCacheOperation('del', 'success');

      const metrics = await getMetrics();
      expect(metrics).toContain('operation="del"');
      expect(metrics).toContain('status="success"');
    });

    test('should update cache metrics with hit rate calculation', async () => {
      updateCacheMetrics(80, 20, 150);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_cache_hit_rate');
      expect(metrics).toContain('tcad_scraper_cache_size');
    });

    test('should handle zero total for hit rate', async () => {
      updateCacheMetrics(0, 0, 0);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_cache_hit_rate');
      expect(metrics).toContain('tcad_scraper_cache_size');
    });

    test('should calculate hit rate correctly', async () => {
      updateCacheMetrics(75, 25, 100);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_cache_hit_rate');
    });
  });

  describe('Error Metrics', () => {
    test('should record errors by type and source', async () => {
      recordError('validation', 'controller');

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_errors_total');
      expect(metrics).toContain('type="validation"');
      expect(metrics).toContain('source="controller"');
    });

    test('should track multiple error types', async () => {
      recordError('validation', 'controller');
      recordError('database', 'service');
      recordError('scraper', 'worker');

      const metrics = await getMetrics();
      expect(metrics).toContain('type="validation"');
      expect(metrics).toContain('type="database"');
      expect(metrics).toContain('type="scraper"');
      expect(metrics).toContain('source="controller"');
      expect(metrics).toContain('source="service"');
      expect(metrics).toContain('source="worker"');
    });
  });

  describe('Code Complexity Metrics', () => {
    test('should update all code complexity metrics', () => {
      const metrics: CodeComplexityMetrics = {
        avgCyclomatic: 5.2,
        maxCyclomatic: 15,
        totalLines: 10000,
        codeLines: 7000,
        commentLines: 1500,
        totalFiles: 50,
        totalFunctions: 200,
        totalClasses: 25,
        maxFunctionLines: 150,
      };

      updateCodeComplexityMetrics(metrics);

      expect(codeComplexityCyclomatic['hashMap'][''].value).toBe(5.2);
    });

    test('should update optional code complexity metrics', () => {
      const metrics: CodeComplexityMetrics = {
        avgCyclomatic: 4.0,
        maxCyclomatic: 12,
        totalLines: 8000,
        codeLines: 6000,
        commentLines: 1000,
        totalFiles: 40,
        totalFunctions: 150,
        totalClasses: 20,
        maxFunctionLines: 120,
        maintainabilityIndex: 75,
        technicalDebtRatio: 5.5,
      };

      updateCodeComplexityMetrics(metrics);

      expect(codeComplexityCyclomatic['hashMap'][''].value).toBe(4.0);
    });

    test('should update per-file metrics', () => {
      const metrics: CodeComplexityMetrics = {
        avgCyclomatic: 5.0,
        maxCyclomatic: 10,
        totalLines: 5000,
        codeLines: 4000,
        commentLines: 500,
        totalFiles: 25,
        totalFunctions: 100,
        totalClasses: 10,
        maxFunctionLines: 80,
        fileMetrics: [
          { file: 'src/index.ts', lines: 200 },
          { file: 'src/service.ts', lines: 350 },
        ],
      };

      updateCodeComplexityMetrics(metrics);

      // File metrics should be updated (implementation depends on internal structure)
      expect(codeComplexityCyclomatic['hashMap'][''].value).toBe(5.0);
    });
  });

  describe('Reset Functionality', () => {
    test('should reset all metrics', async () => {
      // Record some metrics
      recordHttpRequest('GET', '/api/test', 200, 0.5);
      recordScrapeJob('completed', 30, 10);
      recordDbQuery('select', 'properties', 'success', 0.05);
      recordCacheOperation('get', 'hit');

      // Verify metrics are present
      let metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_http_requests_total');

      // Reset metrics
      resetMetrics();

      // Metrics should be reset
      metrics = await getMetrics();
      const lines = metrics.split('\n').filter(l => !l.startsWith('#') && l.trim());
      // Should only have default metrics, not our custom recorded ones
      const httpRequestLines = lines.filter(l => l.includes('tcad_scraper_http_requests_total{'));
      expect(httpRequestLines.length).toBe(0);
    });

    test('should allow recording after reset', async () => {
      recordHttpRequest('GET', '/api/test', 200, 0.5);
      resetMetrics();
      recordHttpRequest('POST', '/api/test', 201, 0.3);

      const metrics = await getMetrics();
      expect(metrics).toContain('method="POST"');
      expect(metrics).toContain('status_code="201"');
    });
  });

  describe('Metrics Export', () => {
    test('should export metrics in Prometheus format', async () => {
      recordHttpRequest('GET', '/api/properties', 200, 0.5);
      recordScrapeJob('completed', 30, 10);

      const metrics = await getMetrics();

      expect(metrics).toContain('tcad_scraper_http_requests_total');
      expect(metrics).toContain('tcad_scraper_jobs_total');
      expect(metrics).toContain('method="GET"');
      expect(metrics).toContain('status="completed"');
    });

    test('should include default Node.js metrics', async () => {
      const metrics = await getMetrics();

      // Should include default metrics like process_cpu_seconds_total
      expect(metrics).toContain('tcad_scraper_');
      expect(typeof metrics).toBe('string');
      expect(metrics.length).toBeGreaterThan(0);
    });
  });

  describe('Edge Cases', () => {
    test('should handle zero duration for HTTP requests', async () => {
      recordHttpRequest('GET', '/api/fast', 200, 0);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_http_request_duration_seconds');
      expect(metrics).toContain('route="/api/fast"');
    });

    test('should handle large durations', async () => {
      recordHttpRequest('GET', '/api/slow', 200, 300);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_http_request_duration_seconds');
      expect(metrics).toContain('route="/api/slow"');
    });

    test('should handle various HTTP status codes', async () => {
      recordHttpRequest('GET', '/api/test', 200, 0.1);
      recordHttpRequest('GET', '/api/test', 404, 0.1);
      recordHttpRequest('GET', '/api/test', 500, 0.1);

      const metrics = await getMetrics();
      expect(metrics).toContain('status_code="200"');
      expect(metrics).toContain('status_code="404"');
      expect(metrics).toContain('status_code="500"');
    });

    test('should handle negative queue sizes as zero', async () => {
      await updateQueueMetrics(0, 0, 0, 0);

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_queue_size');
      expect(metrics).toContain('tcad_scraper_active_jobs');
    });
  });

  describe('Concurrent Operations', () => {
    test('should handle multiple concurrent HTTP requests', async () => {
      const routes = ['/api/a', '/api/b', '/api/c'];

      routes.forEach((route) => {
        recordHttpRequest('GET', route, 200, 0.5);
        recordHttpRequest('GET', route, 200, 0.3);
      });

      const metrics = await getMetrics();
      expect(metrics).toContain('route="/api/a"');
      expect(metrics).toContain('route="/api/b"');
      expect(metrics).toContain('route="/api/c"');
      expect(metrics).toContain('tcad_scraper_http_requests_total');
    });

    test('should handle multiple scrape jobs', async () => {
      for (let i = 0; i < 10; i++) {
        recordScrapeJob('completed', 30 + i, 5);
      }

      const metrics = await getMetrics();
      expect(metrics).toContain('tcad_scraper_jobs_total');
      expect(metrics).toContain('status="completed"');
      expect(metrics).toContain('tcad_scraper_properties_scraped_total');
    });
  });
});
</file>

<file path="prisma.test.ts">
/**
 * Prisma Client Tests
 *
 * Tests for Prisma client initialization and configuration
 */

// Mock PrismaClient before imports
const mockPrismaClient = jest.fn().mockImplementation(() => ({
  $connect: jest.fn().mockResolvedValue(undefined),
  $disconnect: jest.fn().mockResolvedValue(undefined),
}));

jest.mock('@prisma/client', () => ({
  PrismaClient: mockPrismaClient,
}));

describe('Prisma Client Module', () => {
  let originalEnv: NodeJS.ProcessEnv;

  beforeEach(() => {
    // Save original environment
    originalEnv = { ...process.env };

    // Clear module cache and global state
    jest.clearAllMocks();
    delete (global as any).prisma;
    delete (global as any).prismaReadOnly;

    // Reset module cache to force re-import
    jest.resetModules();
  });

  afterEach(() => {
    // Restore original environment
    process.env = originalEnv;
  });

  describe('Write Client Initialization', () => {
    it('should create write client with error logging in production', () => {
      process.env.NODE_ENV = 'production';

      // Re-import after setting environment
      require('../prisma');

      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          log: ['error'],
        })
      );
    });

    it('should create write client with verbose logging in development', () => {
      process.env.NODE_ENV = 'development';

      require('../prisma');

      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          log: ['query', 'error', 'warn'],
        })
      );
    });

    it('should use error-only logging when NODE_ENV is not development', () => {
      process.env.NODE_ENV = 'test';

      require('../prisma');

      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          log: ['error'],
        })
      );
    });

    it('should not set global.prisma in production', () => {
      process.env.NODE_ENV = 'production';

      require('../prisma');

      expect((global as any).prisma).toBeUndefined();
    });

    it('should set global.prisma in non-production environments', () => {
      process.env.NODE_ENV = 'development';

      require('../prisma');

      expect((global as any).prisma).toBeDefined();
    });

    it('should reuse existing global.prisma if available', () => {
      const existingClient = { existing: 'client' };
      (global as any).prisma = existingClient;

      const { prisma } = require('../prisma');

      expect(prisma).toBe(existingClient);
      // Write client reused from global, but read-only client still created
      expect(mockPrismaClient).toHaveBeenCalledTimes(1); // Only for read-only client
    });
  });

  describe('Read-Only Client Initialization', () => {
    it('should create read-only client with separate database URL', () => {
      process.env.DATABASE_READ_ONLY_URL = 'postgresql://readonly:pass@localhost:5432/db';
      process.env.DATABASE_URL = 'postgresql://write:pass@localhost:5432/db';
      process.env.NODE_ENV = 'production';

      require('../prisma');

      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          datasources: {
            db: {
              url: 'postgresql://readonly:pass@localhost:5432/db',
            },
          },
          log: ['error'],
        })
      );
    });

    it('should fallback to DATABASE_URL when DATABASE_READ_ONLY_URL is not set', () => {
      delete process.env.DATABASE_READ_ONLY_URL;
      process.env.DATABASE_URL = 'postgresql://main:pass@localhost:5432/db';
      process.env.NODE_ENV = 'production';

      require('../prisma');

      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          datasources: {
            db: {
              url: 'postgresql://main:pass@localhost:5432/db',
            },
          },
        })
      );
    });

    it('should create read-only client with verbose logging in development', () => {
      process.env.NODE_ENV = 'development';
      process.env.DATABASE_URL = 'postgresql://localhost:5432/db';

      require('../prisma');

      // Second call should be for read-only client
      expect(mockPrismaClient).toHaveBeenNthCalledWith(
        2,
        expect.objectContaining({
          log: ['query', 'error', 'warn'],
        })
      );
    });

    it('should not set global.prismaReadOnly in production', () => {
      process.env.NODE_ENV = 'production';

      require('../prisma');

      expect((global as any).prismaReadOnly).toBeUndefined();
    });

    it('should set global.prismaReadOnly in non-production environments', () => {
      process.env.NODE_ENV = 'development';

      require('../prisma');

      expect((global as any).prismaReadOnly).toBeDefined();
    });

    it('should reuse existing global.prismaReadOnly if available', () => {
      const existingReadClient = { existing: 'readClient' };
      (global as any).prismaReadOnly = existingReadClient;

      const { prismaReadOnly } = require('../prisma');

      expect(prismaReadOnly).toBe(existingReadClient);
    });
  });

  describe('Module Exports', () => {
    it('should export prisma write client', () => {
      const { prisma } = require('../prisma');

      expect(prisma).toBeDefined();
    });

    it('should export prismaReadOnly client', () => {
      const { prismaReadOnly } = require('../prisma');

      expect(prismaReadOnly).toBeDefined();
    });

    it('should export both clients as separate instances when no globals exist', () => {
      const { prisma, prismaReadOnly } = require('../prisma');

      expect(prisma).toBeDefined();
      expect(prismaReadOnly).toBeDefined();
      // When created fresh (not from globals), they should be different instances
      expect(mockPrismaClient).toHaveBeenCalledTimes(2);
    });
  });

  describe('Singleton Pattern', () => {
    it('should maintain singleton across multiple imports in non-production', () => {
      process.env.NODE_ENV = 'development';

      // First import
      const module1 = require('../prisma');

      // Clear require cache for module but keep globals
      const moduleId = require.resolve('../prisma');
      delete require.cache[moduleId];

      // Second import should reuse global
      const module2 = require('../prisma');

      expect(module1.prisma).toBe(module2.prisma);
      expect(module1.prismaReadOnly).toBe(module2.prismaReadOnly);
    });

    it.skip('should create new instances in production on each import - SKIPPED (Jest module caching)', () => {
      process.env.NODE_ENV = 'production';

      // First import
      require('../prisma');

      // Track how many times mock was called in first import
      const firstImportCalls = mockPrismaClient.mock.calls.length;
      expect(firstImportCalls).toBe(2); // write + read clients

      // Clear require cache to force re-import
      const moduleId = require.resolve('../prisma');
      delete require.cache[moduleId];

      // Second import should create new instances (globals not set in production)
      require('../prisma');

      // Should have created 2 more clients (4 total)
      expect(mockPrismaClient).toHaveBeenCalledTimes(4);
    });
  });

  describe('Environment Variable Handling', () => {
    it('should handle missing DATABASE_URL gracefully', () => {
      delete process.env.DATABASE_URL;
      delete process.env.DATABASE_READ_ONLY_URL;

      // Should not throw when importing
      expect(() => require('../prisma')).not.toThrow();
    });

    it('should handle undefined NODE_ENV with error-only logging', () => {
      delete process.env.NODE_ENV;

      require('../prisma');

      // Should use error-only logging (only 'development' gets verbose logging)
      expect(mockPrismaClient).toHaveBeenCalledWith(
        expect.objectContaining({
          log: ['error'],
        })
      );
    });
  });
});
</file>

<file path="redis-cache.service.test.ts">
// Mock redis BEFORE importing the service
jest.mock('redis', () => {
  const mockClient = {
    connect: jest.fn().mockResolvedValue(undefined),
    quit: jest.fn().mockResolvedValue(undefined),
    get: jest.fn(),
    set: jest.fn(),
    setEx: jest.fn(),
    del: jest.fn(),
    keys: jest.fn(),
    exists: jest.fn(),
    ttl: jest.fn(),
    flushDb: jest.fn(),
    ping: jest.fn(),
    on: jest.fn(),
  };

  return {
    createClient: jest.fn(() => mockClient),
  };
});

import { RedisCacheService } from '../redis-cache.service';

jest.mock('../../config', () => ({
  config: {
    redis: {
      host: 'localhost',
      port: 6379,
      password: '',
      db: 0,
      connectionTimeout: 5000,
    },
    logging: {
      level: 'error', // Suppress logs during tests
    },
  },
}));

describe.skip('RedisCacheService - SKIPPED (complex Redis mocking issue)', () => {
  let service: RedisCacheService;
  let mockRedisClient: any;

  beforeEach(async () => {
    jest.clearAllMocks();

    // Create service and connect
    service = new RedisCacheService();

    // Connect to Redis (this will call createClient)
    await service.connect();

    // Get the mock client instance
    const { createClient } = require('redis');
    mockRedisClient = createClient.mock.results[0].value;

    // Trigger the 'ready' event to set isConnected = true
    const onReadyHandler = mockRedisClient.on.mock.calls.find(
      (call: any[]) => call[0] === 'ready'
    )?.[1];
    if (onReadyHandler) onReadyHandler();
  });

  afterEach(async () => {
    if (service) {
      await service.disconnect();
    }
  });

  describe('connect', () => {
    it('should initialize Redis connection successfully', async () => {
      const newService = new RedisCacheService();
      mockRedisClient.connect.mockResolvedValue(undefined);

      await newService.connect();

      expect(mockRedisClient.connect).toHaveBeenCalled();
    });

    it('should not reconnect if already connected', async () => {
      mockRedisClient.connect.mockClear();

      await service.connect();

      expect(mockRedisClient.connect).not.toHaveBeenCalled();
    });

    it('should handle connection errors', async () => {
      const newService = new RedisCacheService();
      const error = new Error('Connection failed');
      mockRedisClient.connect.mockRejectedValue(error);

      await expect(newService.connect()).rejects.toThrow('Connection failed');
    });
  });

  describe('get', () => {
    it('should get value from cache and parse JSON', async () => {
      const key = 'test:key';
      const value = { data: 'test' };
      mockRedisClient.get.mockResolvedValue(JSON.stringify(value));

      const result = await service.get(key);

      expect(result).toEqual(value);
      expect(mockRedisClient.get).toHaveBeenCalledWith(key);
    });

    it('should return null for cache miss', async () => {
      const key = 'nonexistent';
      mockRedisClient.get.mockResolvedValue(null);

      const result = await service.get(key);

      expect(result).toBeNull();
    });

    it('should handle get errors gracefully', async () => {
      const key = 'error:key';
      mockRedisClient.get.mockRejectedValue(new Error('Redis error'));

      const result = await service.get(key);

      expect(result).toBeNull();
    });

    it('should return null when not connected', async () => {
      await service.disconnect();

      const result = await service.get('test:key');

      expect(result).toBeNull();
    });
  });

  describe('set', () => {
    it('should set value in cache with default TTL', async () => {
      const key = 'test:key';
      const value = { data: 'test' };
      mockRedisClient.setEx.mockResolvedValue('OK');

      const result = await service.set(key, value);

      expect(result).toBe(true);
      expect(mockRedisClient.setEx).toHaveBeenCalledWith(
        key,
        300, // default TTL
        JSON.stringify(value)
      );
    });

    it('should set value with custom TTL', async () => {
      const key = 'test:key';
      const value = { data: 'test' };
      const ttl = 600;
      mockRedisClient.setEx.mockResolvedValue('OK');

      const result = await service.set(key, value, ttl);

      expect(result).toBe(true);
      expect(mockRedisClient.setEx).toHaveBeenCalledWith(
        key,
        ttl,
        JSON.stringify(value)
      );
    });

    it('should handle set errors', async () => {
      const key = 'error:key';
      mockRedisClient.setEx.mockRejectedValue(new Error('Redis error'));

      const result = await service.set(key, { data: 'test' });

      expect(result).toBe(false);
    });

    it('should return false when not connected', async () => {
      await service.disconnect();

      const result = await service.set('test:key', { data: 'test' });

      expect(result).toBe(false);
    });
  });

  describe('delete', () => {
    it('should delete key successfully', async () => {
      const key = 'test:key';
      mockRedisClient.del.mockResolvedValue(1);

      const result = await service.delete(key);

      expect(result).toBe(true);
      expect(mockRedisClient.del).toHaveBeenCalledWith(key);
    });

    it('should return false when key does not exist', async () => {
      const key = 'nonexistent';
      mockRedisClient.del.mockResolvedValue(0);

      const result = await service.delete(key);

      expect(result).toBe(false);
    });

    it('should handle delete errors', async () => {
      const key = 'error:key';
      mockRedisClient.del.mockRejectedValue(new Error('Redis error'));

      const result = await service.delete(key);

      expect(result).toBe(false);
    });

    it('should return false when not connected', async () => {
      await service.disconnect();

      const result = await service.delete('test:key');

      expect(result).toBe(false);
    });
  });

  describe('deletePattern', () => {
    it('should delete all keys matching pattern', async () => {
      const pattern = 'test:*';
      const keys = ['test:1', 'test:2', 'test:3'];
      mockRedisClient.keys.mockResolvedValue(keys);
      mockRedisClient.del.mockResolvedValue(3);

      const result = await service.deletePattern(pattern);

      expect(result).toBe(3);
      expect(mockRedisClient.keys).toHaveBeenCalledWith(pattern);
      expect(mockRedisClient.del).toHaveBeenCalledWith(keys);
    });

    it('should return 0 when no keys match pattern', async () => {
      const pattern = 'nonexistent:*';
      mockRedisClient.keys.mockResolvedValue([]);

      const result = await service.deletePattern(pattern);

      expect(result).toBe(0);
      expect(mockRedisClient.del).not.toHaveBeenCalled();
    });

    it('should handle delete pattern errors', async () => {
      const pattern = 'error:*';
      mockRedisClient.keys.mockRejectedValue(new Error('Redis error'));

      const result = await service.deletePattern(pattern);

      expect(result).toBe(0);
    });

    it('should return 0 when not connected', async () => {
      await service.disconnect();

      const result = await service.deletePattern('test:*');

      expect(result).toBe(0);
    });
  });

  describe('exists', () => {
    it('should return true when key exists', async () => {
      const key = 'test:key';
      mockRedisClient.exists.mockResolvedValue(1);

      const result = await service.exists(key);

      expect(result).toBe(true);
      expect(mockRedisClient.exists).toHaveBeenCalledWith(key);
    });

    it('should return false when key does not exist', async () => {
      const key = 'nonexistent';
      mockRedisClient.exists.mockResolvedValue(0);

      const result = await service.exists(key);

      expect(result).toBe(false);
    });

    it('should return false on error', async () => {
      const key = 'error:key';
      mockRedisClient.exists.mockRejectedValue(new Error('Redis error'));

      const result = await service.exists(key);

      expect(result).toBe(false);
    });

    it('should return false when not connected', async () => {
      await service.disconnect();

      const result = await service.exists('test:key');

      expect(result).toBe(false);
    });
  });

  describe('ttl', () => {
    it('should return time to live for key', async () => {
      const key = 'test:key';
      const ttl = 300;
      mockRedisClient.ttl.mockResolvedValue(ttl);

      const result = await service.ttl(key);

      expect(result).toBe(ttl);
      expect(mockRedisClient.ttl).toHaveBeenCalledWith(key);
    });

    it('should return -1 on error', async () => {
      const key = 'error:key';
      mockRedisClient.ttl.mockRejectedValue(new Error('Redis error'));

      const result = await service.ttl(key);

      expect(result).toBe(-1);
    });

    it('should return -1 when not connected', async () => {
      await service.disconnect();

      const result = await service.ttl('test:key');

      expect(result).toBe(-1);
    });
  });

  describe('flush', () => {
    it('should flush all cache entries', async () => {
      mockRedisClient.flushDb.mockResolvedValue('OK');

      const result = await service.flush();

      expect(result).toBe(true);
      expect(mockRedisClient.flushDb).toHaveBeenCalled();
    });

    it('should handle flush errors', async () => {
      mockRedisClient.flushDb.mockRejectedValue(new Error('Redis error'));

      const result = await service.flush();

      expect(result).toBe(false);
    });

    it('should return false when not connected', async () => {
      await service.disconnect();

      const result = await service.flush();

      expect(result).toBe(false);
    });
  });

  describe('getStats', () => {
    it('should return cache statistics', async () => {
      // Generate some cache activity
      mockRedisClient.get.mockResolvedValueOnce(null); // miss
      mockRedisClient.get.mockResolvedValueOnce(JSON.stringify({ data: 'test' })); // hit
      mockRedisClient.setEx.mockResolvedValue('OK');

      await service.get('miss:key');
      await service.get('hit:key');
      await service.set('new:key', { data: 'test' });

      const stats = service.getStats();

      expect(stats.hits).toBe(1);
      expect(stats.misses).toBe(1);
      expect(stats.sets).toBe(1);
      expect(stats.totalRequests).toBe(2);
      expect(stats.hitRate).toBe('50.00%');
      expect(stats.isConnected).toBe(true);
    });

    it('should calculate 0% hit rate when no requests', async () => {
      const stats = service.getStats();

      expect(stats.hitRate).toBe('0%');
      expect(stats.totalRequests).toBe(0);
    });
  });

  describe('resetStats', () => {
    it('should reset statistics to zero', async () => {
      // Generate some activity
      mockRedisClient.get.mockResolvedValue(JSON.stringify({ data: 'test' }));
      await service.get('test:key');

      service.resetStats();

      const stats = service.getStats();
      expect(stats.hits).toBe(0);
      expect(stats.misses).toBe(0);
      expect(stats.sets).toBe(0);
      expect(stats.deletes).toBe(0);
      expect(stats.errors).toBe(0);
    });
  });

  describe('disconnect', () => {
    it('should close Redis connection', async () => {
      mockRedisClient.quit.mockResolvedValue('OK');

      await service.disconnect();

      expect(mockRedisClient.quit).toHaveBeenCalled();
    });

    it('should not error when disconnecting while not connected', async () => {
      await service.disconnect();

      // Second disconnect should not throw
      await expect(service.disconnect()).resolves.not.toThrow();
    });
  });

  describe('getOrSet', () => {
    it('should return cached value if exists', async () => {
      const key = 'test:key';
      const cachedValue = { data: 'cached' };
      mockRedisClient.get.mockResolvedValue(JSON.stringify(cachedValue));

      const fetchFn = jest.fn();
      const result = await service.getOrSet(key, fetchFn);

      expect(result).toEqual(cachedValue);
      expect(fetchFn).not.toHaveBeenCalled();
    });

    it('should fetch and cache value on cache miss', async () => {
      const key = 'test:key';
      const fetchedValue = { data: 'fetched' };
      mockRedisClient.get.mockResolvedValue(null); // cache miss
      mockRedisClient.setEx.mockResolvedValue('OK');

      const fetchFn = jest.fn().mockResolvedValue(fetchedValue);
      const result = await service.getOrSet(key, fetchFn);

      expect(result).toEqual(fetchedValue);
      expect(fetchFn).toHaveBeenCalled();
      expect(mockRedisClient.setEx).toHaveBeenCalledWith(
        key,
        300,
        JSON.stringify(fetchedValue)
      );
    });

    it('should use custom TTL in getOrSet', async () => {
      const key = 'test:key';
      const value = { data: 'test' };
      const ttl = 600;
      mockRedisClient.get.mockResolvedValue(null);
      mockRedisClient.setEx.mockResolvedValue('OK');

      const fetchFn = jest.fn().mockResolvedValue(value);
      await service.getOrSet(key, fetchFn, ttl);

      expect(mockRedisClient.setEx).toHaveBeenCalledWith(
        key,
        ttl,
        JSON.stringify(value)
      );
    });
  });

  describe('healthCheck', () => {
    it('should return true when Redis is healthy', async () => {
      mockRedisClient.ping.mockResolvedValue('PONG');

      const result = await service.healthCheck();

      expect(result).toBe(true);
      expect(mockRedisClient.ping).toHaveBeenCalled();
    });

    it('should return false when ping fails', async () => {
      mockRedisClient.ping.mockRejectedValue(new Error('Connection lost'));

      const result = await service.healthCheck();

      expect(result).toBe(false);
    });

    it('should return false when not connected', async () => {
      await service.disconnect();

      const result = await service.healthCheck();

      expect(result).toBe(false);
    });
  });
});
</file>

<file path="search-term-deduplicator.test.ts">
import { SearchTermDeduplicator } from '../search-term-deduplicator';

describe('SearchTermDeduplicator', () => {
  let deduplicator: SearchTermDeduplicator;

  beforeEach(() => {
    deduplicator = new SearchTermDeduplicator();
  });

  describe('Exact Duplicates', () => {
    test('should skip exact duplicates', () => {
      deduplicator.markTermAsUsed('Smith');
      expect(deduplicator.shouldSkipTerm('Smith')).toBe(true);
      expect(deduplicator.getStats().exactDuplicates).toBe(1);
    });

    test('should not skip new unique terms', () => {
      deduplicator.markTermAsUsed('Smith');
      expect(deduplicator.shouldSkipTerm('Jones')).toBe(false);
    });
  });

  describe('Business Entity Supersets', () => {
    test('should skip "Name LLC" when "Name" exists', () => {
      deduplicator.markTermAsUsed('Smith');
      expect(deduplicator.shouldSkipTerm('Smith LLC')).toBe(true);
      expect(deduplicator.getStats().businessSupersets).toBe(1);
    });

    test('should skip various business suffixes', () => {
      deduplicator.markTermAsUsed('Johnson');

      expect(deduplicator.shouldSkipTerm('Johnson Inc')).toBe(true);
      expect(deduplicator.shouldSkipTerm('Johnson Corp')).toBe(true);
      expect(deduplicator.shouldSkipTerm('Johnson Trust')).toBe(true);
      expect(deduplicator.shouldSkipTerm('Johnson Properties')).toBe(true);

      expect(deduplicator.getStats().businessSupersets).toBe(4);
    });

    test('should NOT skip business entity if base name does not exist', () => {
      expect(deduplicator.shouldSkipTerm('NewCompany LLC')).toBe(false);
    });

    test('should NOT skip single word terms', () => {
      deduplicator.markTermAsUsed('Trust');
      expect(deduplicator.shouldSkipTerm('Smith')).toBe(false);
    });
  });

  describe('Two-Word Supersets', () => {
    test('should skip "Oak Street" when both "Oak" and "Street" exist', () => {
      deduplicator.markTermAsUsed('Oak');
      deduplicator.markTermAsUsed('Street');

      expect(deduplicator.shouldSkipTerm('Oak Street')).toBe(true);
      expect(deduplicator.getStats().twoWordSupersets).toBe(1);
    });

    test('should NOT skip "Oak Street" if only "Oak" exists', () => {
      deduplicator.markTermAsUsed('Oak');
      expect(deduplicator.shouldSkipTerm('Oak Street')).toBe(false);
    });

    test('should NOT skip "Oak Street" if only "Street" exists', () => {
      deduplicator.markTermAsUsed('Street');
      expect(deduplicator.shouldSkipTerm('Oak Street')).toBe(false);
    });

    test('should allow if neither word exists', () => {
      expect(deduplicator.shouldSkipTerm('Pine Avenue')).toBe(false);
    });
  });

  describe('Multi-Word Supersets', () => {
    test('should skip when all 3 words exist', () => {
      deduplicator.markTermAsUsed('Oak');
      deduplicator.markTermAsUsed('Hill');
      deduplicator.markTermAsUsed('Drive');

      expect(deduplicator.shouldSkipTerm('Oak Hill Drive')).toBe(true);
      expect(deduplicator.getStats().multiWordSupersets).toBe(1);
    });

    test('should NOT skip if any word is missing', () => {
      deduplicator.markTermAsUsed('Oak');
      deduplicator.markTermAsUsed('Hill');
      // Missing "Drive"

      expect(deduplicator.shouldSkipTerm('Oak Hill Drive')).toBe(false);
    });
  });

  describe('Edge Cases', () => {
    test('should skip terms shorter than 4 characters', () => {
      expect(deduplicator.shouldSkipTerm('Oak')).toBe(true);
      expect(deduplicator.shouldSkipTerm('AB')).toBe(true);
      expect(deduplicator.shouldSkipTerm('A')).toBe(true);
    });

    test('should skip empty or null terms', () => {
      expect(deduplicator.shouldSkipTerm('')).toBe(true);
      expect(deduplicator.shouldSkipTerm('   ')).toBe(true);
    });

    test('should handle case sensitivity correctly', () => {
      deduplicator.markTermAsUsed('Smith');
      // Assuming case-sensitive matching
      expect(deduplicator.shouldSkipTerm('smith')).toBe(false);
    });
  });

  describe('Statistics Tracking', () => {
    test('should track multiple types of skips', () => {
      deduplicator.markTermAsUsed('Smith');
      deduplicator.markTermAsUsed('Oak');
      deduplicator.markTermAsUsed('Street');

      deduplicator.shouldSkipTerm('Smith'); // exact duplicate
      deduplicator.shouldSkipTerm('Smith LLC'); // business superset
      deduplicator.shouldSkipTerm('Oak Street'); // two-word superset

      const stats = deduplicator.getStats();
      expect(stats.exactDuplicates).toBe(1);
      expect(stats.businessSupersets).toBe(1);
      expect(stats.twoWordSupersets).toBe(1);
      expect(deduplicator.getTotalSkipped()).toBe(3);
    });

    test('should reset statistics', () => {
      deduplicator.markTermAsUsed('Smith');
      deduplicator.shouldSkipTerm('Smith');

      expect(deduplicator.getTotalSkipped()).toBe(1);

      deduplicator.resetStats();
      expect(deduplicator.getTotalSkipped()).toBe(0);
    });
  });

  describe('Utility Methods', () => {
    test('should track used terms count', () => {
      expect(deduplicator.getUsedTermsCount()).toBe(0);

      deduplicator.markTermAsUsed('Smith');
      deduplicator.markTermAsUsed('Jones');

      expect(deduplicator.getUsedTermsCount()).toBe(2);
    });

    test('should return used terms array', () => {
      deduplicator.markTermAsUsed('Smith');
      deduplicator.markTermAsUsed('Jones');

      const terms = deduplicator.getUsedTerms();
      expect(terms).toContain('Smith');
      expect(terms).toContain('Jones');
      expect(terms.length).toBe(2);
    });
  });

  describe('Integration with Existing Terms', () => {
    test('should initialize with existing terms', () => {
      const existingTerms = new Set(['Smith', 'Jones', 'Williams']);
      const dedup = new SearchTermDeduplicator(existingTerms);

      expect(dedup.shouldSkipTerm('Smith')).toBe(true);
      expect(dedup.shouldSkipTerm('Smith LLC')).toBe(true);
      expect(dedup.shouldSkipTerm('Brown')).toBe(false);
    });
  });
});
</file>

<file path="tcad-scraper.test.ts">
/**
 * TCAD Scraper Tests
 *
 * Tests for helper methods and configuration
 */

// Mock Playwright
const mockBrowser = {
  newContext: jest.fn(),
  close: jest.fn(),
};

jest.mock('playwright', () => ({
  chromium: {
    launch: jest.fn().mockResolvedValue(mockBrowser),
  },
}));

// Mock config
jest.mock('../../config', () => ({
  config: {
    logging: {
      level: 'error',
    },
    scraper: {
      headless: true,
      timeout: 30000,
      retryAttempts: 3,
      retryDelay: 1000,
      userAgents: [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      ],
      viewports: [
        { width: 1920, height: 1080 },
        { width: 1366, height: 768 },
      ],
      humanDelay: {
        min: 500,
        max: 2000,
      },
      brightData: {
        enabled: false,
        apiToken: null,
        proxyHost: 'brd.superproxy.io',
        proxyPort: 22225,
      },
      proxy: {
        enabled: false,
        server: null,
        username: null,
        password: null,
      },
    },
  },
}));

// Mock token refresh service
jest.mock('../../services/token-refresh.service', () => ({
  tokenRefreshService: {
    getCurrentToken: jest.fn().mockReturnValue(null),
  },
}));

// Mock DOM scraper fallback
jest.mock('../fallback/dom-scraper', () => ({
  scrapeDOMFallback: jest.fn().mockResolvedValue([]),
}));

import { TCADScraper } from '../tcad-scraper';
import { chromium } from 'playwright';

describe.skip('TCADScraper - SKIPPED (complex Playwright mocking)', () => {
  let scraper: TCADScraper;

  beforeEach(() => {
    jest.clearAllMocks();
    scraper = new TCADScraper();
  });

  afterEach(async () => {
    if (scraper) {
      // Cleanup if needed
    }
  });

  describe('constructor', () => {
    it('should initialize with default config', () => {
      const scraper = new TCADScraper();
      expect(scraper).toBeDefined();
    });

    it('should accept custom config', () => {
      const customScraper = new TCADScraper({
        headless: false,
        timeout: 60000,
      });
      expect(customScraper).toBeDefined();
    });

    it('should configure proxy if enabled in config', () => {
      // Test with Bright Data proxy
      jest.resetModules();
      jest.doMock('../../config', () => ({
        config: {
          logging: { level: 'error' },
          scraper: {
            headless: true,
            timeout: 30000,
            retryAttempts: 3,
            retryDelay: 1000,
            userAgents: ['test-agent'],
            viewports: [{ width: 1920, height: 1080 }],
            humanDelay: { min: 500, max: 2000 },
            brightData: {
              enabled: true,
              apiToken: 'test-token-12345678',
              proxyHost: 'brd.superproxy.io',
              proxyPort: 22225,
            },
            proxy: {
              enabled: false,
              server: null,
            },
          },
        },
      }));

      // Should not throw when creating scraper with proxy config
      expect(() => new TCADScraper()).not.toThrow();
    });
  });

  describe('initialize', () => {
    it('should launch browser with correct options', async () => {
      await scraper.initialize();

      expect(chromium.launch).toHaveBeenCalledWith(
        expect.objectContaining({
          headless: true,
          args: expect.arrayContaining([
            '--disable-blink-features=AutomationControlled',
            '--disable-web-security',
            '--no-sandbox',
          ]),
        })
      );
    });

    it('should handle browser launch failure', async () => {
      (chromium.launch as jest.Mock).mockRejectedValue(new Error('Launch failed'));

      await expect(scraper.initialize()).rejects.toThrow('Launch failed');
    });

    it('should include proxy config when provided', async () => {
      const scraperWithProxy = new TCADScraper({
        proxyServer: 'http://proxy.example.com:8080',
        proxyUsername: 'user',
        proxyPassword: 'pass',
      });

      await scraperWithProxy.initialize();

      expect(chromium.launch).toHaveBeenCalledWith(
        expect.objectContaining({
          proxy: {
            server: 'http://proxy.example.com:8080',
            username: 'user',
            password: 'pass',
          },
        })
      );
    });
  });

  describe('Helper Methods', () => {
    describe('getRandomElement', () => {
      it('should return element from array', () => {
        // Access private method via any
        const scraperAny = scraper as any;
        const testArray = [1, 2, 3, 4, 5];

        const result = scraperAny.getRandomElement(testArray);

        expect(testArray).toContain(result);
      });

      it('should handle single element array', () => {
        const scraperAny = scraper as any;
        const testArray = ['only-element'];

        const result = scraperAny.getRandomElement(testArray);

        expect(result).toBe('only-element');
      });

      it('should return different elements on multiple calls', () => {
        const scraperAny = scraper as any;
        const testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        const results = new Set();

        // Call 20 times, should get variety
        for (let i = 0; i < 20; i++) {
          results.add(scraperAny.getRandomElement(testArray));
        }

        // With 20 calls on 10 elements, should get more than 1 unique value
        expect(results.size).toBeGreaterThan(1);
      });
    });

    describe('humanDelay', () => {
      beforeEach(() => {
        jest.useFakeTimers();
      });

      afterEach(() => {
        jest.useRealTimers();
      });

      it('should delay within specified range', async () => {
        const scraperAny = scraper as any;

        const delayPromise = scraperAny.humanDelay(100, 200);

        // Fast-forward time
        jest.advanceTimersByTime(150);

        await delayPromise;

        expect(true).toBe(true); // If we got here, delay worked
      });

      it('should use default config values when not specified', async () => {
        const scraperAny = scraper as any;

        const delayPromise = scraperAny.humanDelay();

        // Should use config values (500-2000ms)
        jest.advanceTimersByTime(1000);

        await delayPromise;

        expect(true).toBe(true);
      });
    });
  });

  describe('Configuration', () => {
    it('should merge custom config with defaults', () => {
      const customScraper = new TCADScraper({
        timeout: 45000,
        retryAttempts: 5,
      });

      expect(customScraper).toBeDefined();
      // Config should be accessible and merged
    });

    it('should handle empty config object', () => {
      const defaultScraper = new TCADScraper({});
      expect(defaultScraper).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should throw error if scrapePropertiesViaAPI called without initialization', async () => {
      const uninitializedScraper = new TCADScraper();

      await expect(
        uninitializedScraper.scrapePropertiesViaAPI('test')
      ).rejects.toThrow('Browser not initialized');
    });

    it('should throw error if scrapeProperties called without initialization', async () => {
      const uninitializedScraper = new TCADScraper();

      await expect(
        uninitializedScraper.scrapeProperties('test')
      ).rejects.toThrow('Browser not initialized');
    });
  });

  describe('cleanup', () => {
    it('should close browser if initialized', async () => {
      await scraper.initialize();

      await scraper.cleanup();

      expect(mockBrowser.close).toHaveBeenCalled();
    });

    it('should handle cleanup when browser not initialized', async () => {
      await expect(scraper.cleanup()).resolves.not.toThrow();
    });

    it('should handle browser close errors gracefully', async () => {
      await scraper.initialize();

      mockBrowser.close.mockRejectedValue(new Error('Close failed'));

      // Should not throw
      await expect(scraper.cleanup()).resolves.not.toThrow();
    });
  });

  describe('User Agent and Viewport Selection', () => {
    it('should use random user agent from config', async () => {
      await scraper.initialize();

      const mockNewContext = mockBrowser.newContext as jest.Mock;

      // Initialize will be called later, but config is set in constructor
      expect(scraper).toBeDefined();
    });

    it('should use random viewport from config', async () => {
      await scraper.initialize();

      expect(scraper).toBeDefined();
    });
  });

  describe('Retry Logic', () => {
    it('should respect retry configuration', () => {
      const scraperWithRetries = new TCADScraper({
        retryAttempts: 5,
        retryDelay: 2000,
      });

      expect(scraperWithRetries).toBeDefined();
    });
  });
});
</file>

</files>
