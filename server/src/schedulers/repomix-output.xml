This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  scrape-scheduler.test.ts
README_ENHANCED.md
README.md
scrape-scheduler.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/scrape-scheduler.test.ts">
/**
 * Scrape Scheduler Tests
 *
 * Tests for the cron-based scheduled job system
 */

// Mock dependencies before imports
jest.mock('node-cron', () => {
  const mockSchedule = jest.fn();
  // Set default implementation
  mockSchedule.mockImplementation(() => ({
    start: jest.fn(),
    stop: jest.fn(),
  }));

  return {
    schedule: mockSchedule,
  };
});

const mockScraperQueue = {
  add: jest.fn().mockResolvedValue(undefined),
  clean: jest.fn().mockResolvedValue(undefined),
};

jest.mock('../../queues/scraper.queue', () => ({
  scraperQueue: mockScraperQueue,
}));

const mockPrisma = {
  monitoredSearch: {
    findMany: jest.fn(),
    update: jest.fn(),
  },
  scrapeJob: {
    deleteMany: jest.fn(),
  },
};

jest.mock('../../lib/prisma', () => ({
  prisma: mockPrisma,
}));

// Mock winston to suppress logs during tests
jest.mock('winston', () => {
  const mockLogger = {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
  };

  return {
    createLogger: jest.fn(() => mockLogger),
    format: {
      json: jest.fn(),
      simple: jest.fn(),
    },
    transports: {
      Console: jest.fn(),
    },
  };
});

import cron from 'node-cron';
import { scheduledJobs } from '../scrape-scheduler';

describe('ScheduledJobs', () => {
  beforeEach(() => {
    jest.clearAllMocks();

    // Configure cron.schedule mock to return task objects
    (cron.schedule as jest.Mock).mockImplementation(() => ({
      start: jest.fn(),
      stop: jest.fn(),
    }));
  });

  describe('initialize', () => {
    it('should create four cron tasks', () => {
      scheduledJobs.initialize();

      // Should create 4 tasks: daily, weekly, monthly, cleanup
      expect(cron.schedule).toHaveBeenCalledTimes(4);
    });

    it('should create daily task with correct schedule', () => {
      scheduledJobs.initialize();

      expect(cron.schedule).toHaveBeenCalledWith(
        '0 2 * * *', // 2 AM daily
        expect.any(Function),
        expect.objectContaining({
          scheduled: false,
          timezone: 'America/Chicago',
        })
      );
    });

    it('should create weekly task with correct schedule', () => {
      scheduledJobs.initialize();

      expect(cron.schedule).toHaveBeenCalledWith(
        '0 3 * * 0', // 3 AM on Sundays
        expect.any(Function),
        expect.objectContaining({
          scheduled: false,
          timezone: 'America/Chicago',
        })
      );
    });

    it('should create monthly task with correct schedule', () => {
      scheduledJobs.initialize();

      expect(cron.schedule).toHaveBeenCalledWith(
        '0 4 1 * *', // 4 AM on the 1st
        expect.any(Function),
        expect.objectContaining({
          scheduled: false,
          timezone: 'America/Chicago',
        })
      );
    });

    it('should create cleanup task with correct schedule', () => {
      scheduledJobs.initialize();

      expect(cron.schedule).toHaveBeenCalledWith(
        '0 * * * *', // Every hour
        expect.any(Function),
        expect.objectContaining({
          scheduled: false,
        })
      );
    });

    it('should start all created tasks', () => {
      scheduledJobs.initialize();

      // Verify that 4 tasks were created and each has start called
      const scheduleMock = cron.schedule as jest.Mock;
      expect(scheduleMock).toHaveBeenCalledTimes(4);

      // Get all returned task mocks and verify start was called
      scheduleMock.mock.results.forEach((result: any) => {
        expect(result.value.start).toHaveBeenCalled();
      });
    });

    it('should handle multiple initializations', () => {
      scheduledJobs.initialize();
      jest.clearAllMocks();

      scheduledJobs.initialize();

      // Should create new tasks on second initialization
      expect(cron.schedule).toHaveBeenCalledTimes(4);
    });
  });

  describe('runScheduledScrapes', () => {
    beforeEach(() => {
      // Setup mock data
      mockPrisma.monitoredSearch.findMany.mockResolvedValue([
        {
          id: '1',
          searchTerm: 'John Smith',
          frequency: 'daily',
          active: true,
        },
        {
          id: '2',
          searchTerm: 'Jane Doe',
          frequency: 'daily',
          active: true,
        },
      ]);

      mockPrisma.monitoredSearch.update.mockResolvedValue({});
    });

    it('should query monitored searches with correct frequency', async () => {
      scheduledJobs.initialize();

      // Get the daily task callback
      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      await dailyTaskCallback();

      expect(mockPrisma.monitoredSearch.findMany).toHaveBeenCalledWith({
        where: {
          active: true,
          frequency: 'daily',
        },
      });
    });

    it('should add jobs to scraper queue for each search', async () => {
      scheduledJobs.initialize();

      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      await dailyTaskCallback();

      expect(mockScraperQueue.add).toHaveBeenCalledTimes(2);
      expect(mockScraperQueue.add).toHaveBeenCalledWith(
        'scrape-properties',
        expect.objectContaining({
          searchTerm: 'John Smith',
          scheduled: true,
        }),
        expect.objectContaining({
          delay: expect.any(Number),
          attempts: 5,
          backoff: {
            type: 'exponential',
            delay: 5000,
          },
        })
      );
    });

    it('should use random delay between 0-60 seconds', async () => {
      scheduledJobs.initialize();

      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      await dailyTaskCallback();

      const addCalls = mockScraperQueue.add.mock.calls;
      addCalls.forEach((call: any) => {
        const delay = call[2].delay;
        expect(delay).toBeGreaterThanOrEqual(0);
        expect(delay).toBeLessThan(60000);
      });
    });

    it('should update last run time for each search', async () => {
      scheduledJobs.initialize();

      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      await dailyTaskCallback();

      expect(mockPrisma.monitoredSearch.update).toHaveBeenCalledTimes(2);
      expect(mockPrisma.monitoredSearch.update).toHaveBeenCalledWith({
        where: { id: '1' },
        data: { lastRun: expect.any(Date) },
      });
    });

    it('should handle weekly frequency', async () => {
      mockPrisma.monitoredSearch.findMany.mockResolvedValue([
        {
          id: '3',
          searchTerm: 'Weekly Search',
          frequency: 'weekly',
          active: true,
        },
      ]);

      scheduledJobs.initialize();

      const weeklyTaskCallback = (cron.schedule as jest.Mock).mock.calls[1][1];

      await weeklyTaskCallback();

      expect(mockPrisma.monitoredSearch.findMany).toHaveBeenCalledWith({
        where: {
          active: true,
          frequency: 'weekly',
        },
      });
    });

    it('should handle monthly frequency', async () => {
      mockPrisma.monitoredSearch.findMany.mockResolvedValue([
        {
          id: '4',
          searchTerm: 'Monthly Search',
          frequency: 'monthly',
          active: true,
        },
      ]);

      scheduledJobs.initialize();

      const monthlyTaskCallback = (cron.schedule as jest.Mock).mock.calls[2][1];

      await monthlyTaskCallback();

      expect(mockPrisma.monitoredSearch.findMany).toHaveBeenCalledWith({
        where: {
          active: true,
          frequency: 'monthly',
        },
      });
    });

    it('should handle empty search results', async () => {
      mockPrisma.monitoredSearch.findMany.mockResolvedValue([]);

      scheduledJobs.initialize();

      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      await dailyTaskCallback();

      expect(mockScraperQueue.add).not.toHaveBeenCalled();
      expect(mockPrisma.monitoredSearch.update).not.toHaveBeenCalled();
    });

    it('should handle errors gracefully', async () => {
      mockPrisma.monitoredSearch.findMany.mockRejectedValue(
        new Error('Database error')
      );

      scheduledJobs.initialize();

      const dailyTaskCallback = (cron.schedule as jest.Mock).mock.calls[0][1];

      // Should not throw
      await expect(dailyTaskCallback()).resolves.not.toThrow();
    });
  });

  describe('cleanupOldJobs', () => {
    beforeEach(() => {
      mockPrisma.scrapeJob.deleteMany.mockResolvedValue({ count: 15 });
      mockScraperQueue.clean.mockResolvedValue(undefined);
    });

    it('should delete scrape jobs older than 30 days', async () => {
      scheduledJobs.initialize();

      const cleanupCallback = (cron.schedule as jest.Mock).mock.calls[3][1];

      await cleanupCallback();

      expect(mockPrisma.scrapeJob.deleteMany).toHaveBeenCalledWith({
        where: {
          completedAt: {
            lt: expect.any(Date),
          },
        },
      });

      // Verify the date is approximately 30 days ago
      const deleteCall = mockPrisma.scrapeJob.deleteMany.mock.calls[0][0];
      const thirtyDaysAgo = deleteCall.where.completedAt.lt;
      const now = new Date();
      const daysDiff = Math.floor(
        (now.getTime() - thirtyDaysAgo.getTime()) / (1000 * 60 * 60 * 24)
      );
      expect(daysDiff).toBe(30);
    });

    it('should clean Bull queue completed jobs older than 7 days', async () => {
      scheduledJobs.initialize();

      const cleanupCallback = (cron.schedule as jest.Mock).mock.calls[3][1];

      await cleanupCallback();

      const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
      expect(mockScraperQueue.clean).toHaveBeenCalledWith(
        sevenDaysInMs,
        'completed'
      );
    });

    it('should clean Bull queue failed jobs older than 7 days', async () => {
      scheduledJobs.initialize();

      const cleanupCallback = (cron.schedule as jest.Mock).mock.calls[3][1];

      await cleanupCallback();

      const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
      expect(mockScraperQueue.clean).toHaveBeenCalledWith(sevenDaysInMs, 'failed');
    });

    it('should handle cleanup errors gracefully', async () => {
      mockPrisma.scrapeJob.deleteMany.mockRejectedValue(
        new Error('Cleanup error')
      );

      scheduledJobs.initialize();

      const cleanupCallback = (cron.schedule as jest.Mock).mock.calls[3][1];

      // Should not throw
      await expect(cleanupCallback()).resolves.not.toThrow();
    });

    it('should handle queue cleanup errors gracefully', async () => {
      mockScraperQueue.clean.mockRejectedValue(new Error('Queue cleanup error'));

      scheduledJobs.initialize();

      const cleanupCallback = (cron.schedule as jest.Mock).mock.calls[3][1];

      // Should not throw
      await expect(cleanupCallback()).resolves.not.toThrow();
    });
  });

  describe('stop', () => {
    it('should stop all tasks', () => {
      scheduledJobs.initialize();

      const scheduleMock = cron.schedule as jest.Mock;
      const tasks = scheduleMock.mock.results.map((result: any) => result.value);

      // Clear mocks after init
      tasks.forEach((task: any) => {
        task.stop.mockClear();
      });

      scheduledJobs.stop();

      // Should stop all 4 tasks
      tasks.forEach((task: any) => {
        expect(task.stop).toHaveBeenCalled();
      });
    });

    it('should handle stop before initialize', () => {
      // Since we're using a singleton and it may have been initialized in other tests,
      // we can't reliably test this without resetting the module
      // Just verify stop can be called without throwing
      expect(() => scheduledJobs.stop()).not.toThrow();
    });

    it('should handle multiple stop calls', () => {
      scheduledJobs.initialize();

      const scheduleMock = cron.schedule as jest.Mock;
      const tasks = scheduleMock.mock.results.map((result: any) => result.value);

      scheduledJobs.stop();

      // Clear first stop calls
      tasks.forEach((task: any) => {
        task.stop.mockClear();
      });

      // Second stop
      scheduledJobs.stop();

      // Should still attempt to stop tasks
      tasks.forEach((task: any) => {
        expect(task.stop).toHaveBeenCalled();
      });
    });
  });

  describe('triggerDailyScrapes', () => {
    beforeEach(() => {
      mockPrisma.monitoredSearch.findMany.mockResolvedValue([
        {
          id: '1',
          searchTerm: 'Test Search',
          frequency: 'daily',
          active: true,
        },
      ]);

      mockPrisma.monitoredSearch.update.mockResolvedValue({});
    });

    it('should manually trigger daily scrapes', async () => {
      await scheduledJobs.triggerDailyScrapes();

      expect(mockPrisma.monitoredSearch.findMany).toHaveBeenCalledWith({
        where: {
          active: true,
          frequency: 'daily',
        },
      });
    });

    it('should add jobs to queue when manually triggered', async () => {
      await scheduledJobs.triggerDailyScrapes();

      expect(mockScraperQueue.add).toHaveBeenCalledWith(
        'scrape-properties',
        expect.objectContaining({
          searchTerm: 'Test Search',
          scheduled: true,
        }),
        expect.any(Object)
      );
    });

    it('should update last run time when manually triggered', async () => {
      await scheduledJobs.triggerDailyScrapes();

      expect(mockPrisma.monitoredSearch.update).toHaveBeenCalledWith({
        where: { id: '1' },
        data: { lastRun: expect.any(Date) },
      });
    });
  });

  describe('Module Export', () => {
    it('should export scheduledJobs instance', () => {
      expect(scheduledJobs).toBeDefined();
      expect(typeof scheduledJobs.initialize).toBe('function');
      expect(typeof scheduledJobs.stop).toBe('function');
      expect(typeof scheduledJobs.triggerDailyScrapes).toBe('function');
    });
  });
});
</file>

<file path="README_ENHANCED.md">
# schedulers

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "schedulers",
  "description": "Directory containing 1 code files with 1 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Subdirectories

- `__tests__/`

## Files and Schemas

### `scrape-scheduler.ts` (typescript)

**Classes:**
- `ScheduledJobs` - Line 15

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# schedulers

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `scrape-scheduler.ts` (typescript)

**Classes:**
- `ScheduledJobs` - Line 16

**Key Imports:** `../lib/prisma`, `../queues/scraper.queue`, `node-cron`, `winston`

---
*Generated by Schema Generator*
</file>

<file path="scrape-scheduler.ts">
import cron from 'node-cron';
import { scraperQueue } from '../queues/scraper.queue';
import { prisma } from '../lib/prisma';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple(),
    }),
  ],
});

class ScheduledJobs {
  private tasks: cron.ScheduledTask[] = [];

  initialize() {
    logger.info('Initializing scheduled jobs...');

    // Daily scrape at 2 AM for monitored searches
    const dailyTask = cron.schedule('0 2 * * *', async () => {
      await this.runScheduledScrapes('daily');
    }, {
      scheduled: false,
      timezone: 'America/Chicago',
    });

    // Weekly scrape on Sundays at 3 AM
    const weeklyTask = cron.schedule('0 3 * * 0', async () => {
      await this.runScheduledScrapes('weekly');
    }, {
      scheduled: false,
      timezone: 'America/Chicago',
    });

    // Monthly scrape on the 1st at 4 AM
    const monthlyTask = cron.schedule('0 4 1 * *', async () => {
      await this.runScheduledScrapes('monthly');
    }, {
      scheduled: false,
      timezone: 'America/Chicago',
    });

    // Clean up old jobs every hour
    const cleanupTask = cron.schedule('0 * * * *', async () => {
      await this.cleanupOldJobs();
    }, {
      scheduled: false,
    });

    this.tasks = [dailyTask, weeklyTask, monthlyTask, cleanupTask];

    // Start all tasks
    this.tasks.forEach(task => task.start());

    logger.info('Scheduled jobs initialized successfully');
  }

  private async runScheduledScrapes(frequency: string) {
    try {
      logger.info(`Running ${frequency} scheduled scrapes...`);

      const monitoredSearches = await prisma.monitoredSearch.findMany({
        where: {
          active: true,
          frequency,
        },
      });

      logger.info(`Found ${monitoredSearches.length} ${frequency} searches to run`);

      for (const search of monitoredSearches) {
        // Add random delay to avoid overwhelming the target site
        const delay = Math.floor(Math.random() * 60000); // 0-60 seconds

        await scraperQueue.add(
          'scrape-properties',
          {
            searchTerm: search.searchTerm,
            scheduled: true,
          },
          {
            delay,
            attempts: 5,
            backoff: {
              type: 'exponential',
              delay: 5000,
            },
          }
        );

        // Update last run time
        await prisma.monitoredSearch.update({
          where: { id: search.id },
          data: { lastRun: new Date() },
        });

        logger.info(`Scheduled scrape for "${search.searchTerm}" with ${delay}ms delay`);
      }
    } catch (error) {
      logger.error(`Failed to run ${frequency} scheduled scrapes:`, error);
    }
  }

  private async cleanupOldJobs() {
    try {
      logger.info('Cleaning up old jobs...');

      // Delete scrape jobs older than 30 days
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const deletedJobs = await prisma.scrapeJob.deleteMany({
        where: {
          completedAt: {
            lt: thirtyDaysAgo,
          },
        },
      });

      // Clean Bull queue completed/failed jobs older than 7 days
      const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
      await scraperQueue.clean(sevenDaysInMs, 'completed');
      await scraperQueue.clean(sevenDaysInMs, 'failed');

      logger.info(`Cleaned up ${deletedJobs.count} old database jobs`);
    } catch (error) {
      logger.error('Failed to clean up old jobs:', error);
    }
  }

  stop() {
    logger.info('Stopping scheduled jobs...');
    this.tasks.forEach(task => task.stop());
    logger.info('Scheduled jobs stopped');
  }

  // Manual trigger for testing
  async triggerDailyScrapes() {
    await this.runScheduledScrapes('daily');
  }
}

export const scheduledJobs = new ScheduledJobs();
</file>

</files>
