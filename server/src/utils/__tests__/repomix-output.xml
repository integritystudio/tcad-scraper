This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
deduplication.test.ts
json-ld.utils.test.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="deduplication.test.ts">
import { removeDuplicatesFromQueue } from '../deduplication';

// Mock dependencies
jest.mock('../../queues/scraper.queue', () => ({
  scraperQueue: {
    getWaiting: jest.fn(),
    getDelayed: jest.fn(),
  },
}));

jest.mock('../../lib/prisma', () => ({
  prisma: {
    scrapeJob: {
      findMany: jest.fn(),
    },
  },
}));

jest.mock('../../lib/logger', () => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
}));

describe('removeDuplicatesFromQueue', () => {
  let scraperQueue: any;
  let prisma: any;
  let logger: any;

  beforeEach(() => {
    jest.clearAllMocks();

    const scraperQueueModule = require('../../queues/scraper.queue');
    scraperQueue = scraperQueueModule.scraperQueue;

    const prismaModule = require('../../lib/prisma');
    prisma = prismaModule.prisma;

    logger = require('../../lib/logger');
  });

  describe('with no duplicates', () => {
    it('should return zero removed when queue is empty', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result).toEqual({ removed: 0, failed: 0 });
      expect(scraperQueue.getWaiting).toHaveBeenCalled();
      expect(scraperQueue.getDelayed).toHaveBeenCalled();
    });

    it('should return zero removed when no duplicates exist', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn(),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn(),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result).toEqual({ removed: 0, failed: 0 });
      expect(mockJobs[0].remove).not.toHaveBeenCalled();
      expect(mockJobs[1].remove).not.toHaveBeenCalled();
    });
  });

  describe('with duplicate pending jobs', () => {
    it('should remove duplicate pending jobs and keep highest priority', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 5 }, // Higher priority (lower number)
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 }, // Lower priority (higher number)
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 15 }, // Lowest priority
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(2); // Remove 2 out of 3
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Keep highest priority
      expect(mockJobs[1].remove).toHaveBeenCalled(); // Remove
      expect(mockJobs[2].remove).toHaveBeenCalled(); // Remove
    });

    it('should handle jobs with no priority (default to 10)', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: {}, // No priority
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 15 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Default priority 10 < 15
      expect(mockJobs[1].remove).toHaveBeenCalled();
    });

    it('should handle multiple duplicate groups', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-4',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(2); // Remove 1 from each group
    });
  });

  describe('with already completed terms', () => {
    it('should remove all pending jobs for completed terms', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Smith' }, // Already completed
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      // Note: These 2 jobs are both duplicates AND completed, so they get removed
      // by both the duplicate removal logic and the completed term logic
      // This results in 3 removals (1 from duplicate handling + 2 from completed handling)
      expect(result.removed).toBe(3);
      expect(mockJobs[0].remove).toHaveBeenCalled();
      expect(mockJobs[1].remove).toHaveBeenCalled();
    });

    it('should handle mix of completed and unique terms', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' }, // Already completed
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Johnson' }, // Not completed
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Smith' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
      expect(mockJobs[0].remove).toHaveBeenCalled();
      expect(mockJobs[1].remove).not.toHaveBeenCalled();
    });
  });

  describe('with both waiting and delayed jobs', () => {
    it('should process jobs from both queues', async () => {
      const waitingJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      const delayedJobs = [
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(waitingJobs);
      scraperQueue.getDelayed.mockResolvedValue(delayedJobs);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
    });
  });

  describe('error handling', () => {
    it('should continue removing jobs even if some fail', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed')),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1); // 2 attempts, 1 success, 1 failure
      expect(result.failed).toBe(1);
    });

    it('should track multiple failures correctly', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Failed 1')),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Failed 2')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.failed).toBe(2);
      expect(result.removed).toBe(0);
    });

    it('should handle failures when removing completed terms', async () => {
      // Use only one job to avoid duplicate removal logic
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'CompletedTerm' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed for completed term')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'CompletedTerm' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(result.failed).toBe(1);
      expect(result.removed).toBe(0);
      expect(logger.error).toHaveBeenCalled();
    });
  });

  describe('verbose logging', () => {
    it('should log information when verbose is true', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(logger.info).toHaveBeenCalled();
      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('checking for duplicates')
      );
    });

    it('should not log when verbose is false', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: false });

      expect(logger.info).not.toHaveBeenCalled();
    });

    it('should log "No duplicates found" when verbose and queue is clean', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('No duplicates or completed terms found')
      );
    });

    it('should log errors for failed removals when verbose', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(logger.error).toHaveBeenCalled();
    });

    it('should show "... and X more" when more than 10 duplicate terms', async () => {
      // Create 15 different search terms, each with 2 duplicate jobs
      const mockJobs = [];
      for (let i = 0; i < 15; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: `Term${i}` },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          },
          {
            id: `job-${i}-2`,
            data: { searchTerm: `Term${i}` },
            opts: { priority: 15 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('... and 5 more')
      );
    });

    it('should show "... and X more" when more than 20 completed terms', async () => {
      // Create 25 different completed terms, each with 1 pending job
      const mockJobs = [];
      const completedTerms = [];
      for (let i = 0; i < 25; i++) {
        mockJobs.push({
          id: `job-${i}`,
          data: { searchTerm: `CompletedTerm${i}` },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        });
        completedTerms.push({ searchTerm: `CompletedTerm${i}` });
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue(completedTerms);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('... and 5 more')
      );
    });
  });

  describe('progress reporting', () => {
    it('should show progress when showProgress is true and removing many jobs', async () => {
      // Create enough duplicate jobs to trigger progress reporting (10+ removals)
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: 'DuplicateTerm' },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      // Mock process.stdout.write to verify progress output
      const stdoutWriteSpy = jest.spyOn(process.stdout, 'write').mockImplementation();

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      // Should have written progress at 10 removals
      expect(stdoutWriteSpy).toHaveBeenCalledWith(
        expect.stringContaining('Progress: 10/')
      );

      stdoutWriteSpy.mockRestore();
    });

    it('should not show progress when showProgress is false', async () => {
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: 'DuplicateTerm' },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      const stdoutWriteSpy = jest.spyOn(process.stdout, 'write').mockImplementation();

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      // Should not have written any progress
      expect(stdoutWriteSpy).not.toHaveBeenCalled();

      stdoutWriteSpy.mockRestore();
    });

    it('should log new line after progress when verbose and showProgress', async () => {
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push({
          id: `job-${i}`,
          data: { searchTerm: 'CompletedTerm' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        });
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'CompletedTerm' },
      ]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      // Should log empty string for new line after progress (line 172)
      expect(logger.info).toHaveBeenCalledWith('');
    });
  });

  describe('complex scenarios', () => {
    it('should handle combination of duplicates and completed terms', async () => {
      const mockJobs = [
        // Duplicates for 'Smith' (2 jobs)
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 5 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        // Already completed 'Johnson' (should remove all)
        {
          id: 'job-3',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        // Unique 'Williams' (should keep)
        {
          id: 'job-4',
          data: { searchTerm: 'Williams' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Johnson' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      // Should remove: 1 duplicate Smith + 1 completed Johnson = 2 total
      expect(result.removed).toBe(2);
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Keep high priority Smith
      expect(mockJobs[1].remove).toHaveBeenCalled(); // Remove duplicate Smith
      expect(mockJobs[2].remove).toHaveBeenCalled(); // Remove completed Johnson
      expect(mockJobs[3].remove).not.toHaveBeenCalled(); // Keep unique Williams
    });

    it('should handle empty searchTerm gracefully', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: '' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: '' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1); // Treat empty strings as duplicates
    });
  });
});
</file>

<file path="json-ld.utils.test.ts">
import {
  generatePropertyJsonLd,
  generatePropertyListJsonLd,
  generateOrganizationJsonLd,
  generateBreadcrumbJsonLd,
  generatePropertyCollectionJsonLd,
  injectJsonLdScript,
  generatePageJsonLd,
  validateJsonLd,
} from '../json-ld.utils';
import { PropertyAPI, PaginatedPropertyResponse } from '../../types/property.types';

describe('JSON-LD Utils', () => {
  const mockProperty: PropertyAPI = {
    '@type': 'RealEstateListing',
    propertyId: 'TEST-123',
    address: {
      formatted: '123 Main St, Austin, TX 78701',
      shortFormat: '123 Main St',
      streetAddress: '123 Main St',
      addressLocality: 'Austin',
      addressRegion: 'TX',
      addressCountry: 'US',
      postalCode: '78701',
    },
    propertyType: 'Residential',
    owner: {
      '@type': 'Person',
      name: 'John Doe',
    },
    valuation: {
      appraisedValue: {
        value: 500000,
        currency: 'USD',
        formatted: '$500,000',
      },
      assessedValue: {
        value: 450000,
        currency: 'USD',
        formatted: '$450,000',
      },
    },
    geography: {
      latitude: 30.2672,
      longitude: -97.7431,
      neighborhood: 'Downtown',
    },
    legalDescription: 'Lot 5, Block 3, Downtown Addition',
    metadata: {
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-02T00:00:00Z',
      scrapedAt: '2024-01-01T00:00:00Z',
      dataFreshness: 'fresh' as const,
    },
  };

  describe('generatePropertyJsonLd', () => {
    it('should generate valid property JSON-LD with all fields', () => {
      const result = generatePropertyJsonLd(mockProperty, 'TCAD', 'https://example.com');

      expect(result).toMatchObject({
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        '@id': 'https://example.com/properties/TEST-123',
        identifier: 'TEST-123',
        name: '123 Main St, Austin, TX 78701 - TCAD Property',
      });
    });

    it('should include address information', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.address).toEqual({
        '@type': 'PostalAddress',
        streetAddress: '123 Main St',
        addressLocality: 'Austin',
        addressRegion: 'TX',
        addressCountry: 'US',
        postalCode: '78701',
      });
    });

    it('should include geographic coordinates when available', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.geo).toEqual({
        '@type': 'GeoCoordinates',
        latitude: 30.2672,
        longitude: -97.7431,
      });
    });

    it('should include owner/seller information', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.seller).toEqual({
        '@type': 'Person',
        name: 'John Doe',
      });
    });

    it('should include pricing offers', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.offers).toMatchObject({
        '@type': 'Offer',
        price: 500000,
        priceCurrency: 'USD',
      });
    });

    it('should include both appraised and assessed values in price specifications', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.offers.priceSpecification).toHaveLength(2);
      expect(result.offers.priceSpecification[0]).toMatchObject({
        '@type': 'PriceSpecification',
        price: 500000,
        name: 'Appraised Value',
      });
      expect(result.offers.priceSpecification[1]).toMatchObject({
        '@type': 'PriceSpecification',
        price: 450000,
        name: 'Assessed Value',
      });
    });

    it('should work without optional fields', () => {
      const minimalProperty: PropertyAPI = {
        propertyId: 'MIN-123',
        address: {
          formatted: '456 Oak Ave',
          streetAddress: '456 Oak Ave',
          addressLocality: 'Austin',
          addressRegion: 'TX',
          addressCountry: 'US',
        },
        propertyType: 'Commercial',
        valuation: {
          appraisedValue: {
            value: 1000000,
            currency: 'USD',
            formatted: '$1,000,000',
          },
        },
        metadata: {
          createdAt: '2024-01-01T00:00:00Z',
          updatedAt: '2024-01-01T00:00:00Z',
          scrapedAt: '2024-01-01T00:00:00Z',
          dataFreshness: 'fresh' as const,
        },
      };

      const result = generatePropertyJsonLd(minimalProperty) as any;

      expect(result['@type']).toBe('RealEstateListing');
      expect(result.identifier).toBe('MIN-123');
      expect(result.geo).toBeUndefined();
      expect(result.seller).toBeUndefined();
    });
  });

  describe('generatePropertyListJsonLd', () => {
    const mockResponse: PaginatedPropertyResponse = {
      results: [mockProperty],
      pagination: {
        total: 1,
        offset: 0,
        limit: 20,
        hasMore: false,
      },
    };

    it('should generate valid ItemList JSON-LD', () => {
      const result = generatePropertyListJsonLd(mockResponse);

      expect(result).toMatchObject({
        '@context': 'https://schema.org',
        '@type': 'ItemList',
        numberOfItems: 1,
      });
    });

    it('should include search query in name when provided', () => {
      const result = generatePropertyListJsonLd(mockResponse, 'Austin homes') as any;

      expect(result.name).toBe('Property Search Results for "Austin homes"');
    });

    it('should use default name when no search query', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.name).toBe('Travis County Properties');
    });

    it('should include list items with correct positions', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.itemListElement).toHaveLength(1);
      expect(result.itemListElement[0]).toMatchObject({
        '@type': 'ListItem',
        position: 1,
      });
    });

    it('should include item details for each property', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.itemListElement[0].item).toMatchObject({
        '@type': 'RealEstateListing',
        '@id': 'https://example.com/properties/TEST-123',
        identifier: 'TEST-123',
        name: '123 Main St, Austin, TX 78701',
      });
    });

    it('should include nextItem when hasMore is true', () => {
      const responseWithMore: PaginatedPropertyResponse = {
        ...mockResponse,
        pagination: {
          ...mockResponse.pagination,
          hasMore: true,
        },
      };

      const result = generatePropertyListJsonLd(responseWithMore) as any;

      expect(result.nextItem).toBeDefined();
      expect(result.nextItem).toContain('offset=20');
    });

    it('should not include nextItem when hasMore is false', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.nextItem).toBeUndefined();
    });

    it('should include search action', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.potentialAction).toMatchObject({
        '@type': 'SearchAction',
        'query-input': 'required name=search_term_string',
      });
    });
  });

  describe('generateOrganizationJsonLd', () => {
    it('should generate valid WebSite JSON-LD with defaults', () => {
      const result = generateOrganizationJsonLd() as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('WebSite');
      expect(result.name).toBeDefined();
      expect(result.url).toBeDefined();
    });

    it('should use custom website URL', () => {
      const result = generateOrganizationJsonLd('https://custom.com') as any;

      expect(result.url).toBe('https://custom.com');
    });

    it('should use custom organization name', () => {
      const result = generateOrganizationJsonLd('https://example.com', 'Custom TCAD') as any;

      expect(result.name).toBe('Custom TCAD');
    });

    it('should include description', () => {
      const result = generateOrganizationJsonLd() as any;

      expect(result.description).toBeDefined();
      expect(typeof result.description).toBe('string');
    });
  });

  describe('generateBreadcrumbJsonLd', () => {
    it('should generate valid BreadcrumbList JSON-LD', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' },
        { name: 'Details' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('BreadcrumbList');
      expect(result.itemListElement).toHaveLength(3);
    });

    it('should set correct position for each item', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result.itemListElement[0].position).toBe(1);
      expect(result.itemListElement[1].position).toBe(2);
    });

    it('should include URLs when provided', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' }
      ];

      const result = generateBreadcrumbJsonLd(items, 'https://example.com') as any;

      expect(result.itemListElement[0].item).toBe('https://example.com/');
      expect(result.itemListElement[1].item).toBe('https://example.com/properties');
    });

    it('should omit item field when URL not provided', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Current Page' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result.itemListElement[0].item).toBeDefined();
      expect(result.itemListElement[1].item).toBeUndefined();
    });

    it('should handle empty items array', () => {
      const result = generateBreadcrumbJsonLd([]) as any;

      expect(result.itemListElement).toHaveLength(0);
    });
  });

  describe('generatePropertyCollectionJsonLd', () => {
    const mockProperties: PropertyAPI[] = [
      mockProperty,
      {
        ...mockProperty,
        propertyId: 'TEST-456',
        valuation: {
          appraisedValue: {
            value: 750000,
            currency: 'USD',
            formatted: '$750,000',
          },
        },
      },
    ];

    it('should generate valid CollectionPage JSON-LD', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('CollectionPage');
      expect(result.name).toBe('Austin Properties');
    });

    it('should include correct number of items', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result.description).toBe('Collection of 2 properties');
      expect(result.mainEntity.numberOfItems).toBe(2);
    });

    it('should limit list items to 10', () => {
      const manyProperties = Array(15).fill(mockProperty).map((p, i) => ({
        ...p,
        propertyId: `TEST-${i}`,
      }));

      const result = generatePropertyCollectionJsonLd(
        manyProperties,
        'Large Collection',
        'custom'
      ) as any;

      expect(result.mainEntity.itemListElement).toHaveLength(10);
    });

    it('should calculate aggregate statistics correctly', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result.aggregateRating).toMatchObject({
        '@type': 'AggregateOffer',
        lowPrice: 500000,
        highPrice: 750000,
        priceCurrency: 'USD',
        offerCount: 2,
        averagePrice: 625000,
      });
    });

    it('should include city metadata for city collections', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin',
        'city'
      ) as any;

      expect(result.about).toEqual({
        '@type': 'City',
        name: 'Austin',
      });
    });

    it('should omit city metadata for non-city collections', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Residential',
        'type'
      ) as any;

      expect(result.about).toBeUndefined();
    });

    it('should include modification date', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Test Collection',
        'custom'
      ) as any;

      expect(result.dateModified).toBeDefined();
      expect(new Date(result.dateModified)).toBeInstanceOf(Date);
    });

    it('should include item URLs', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city',
        'https://example.com'
      ) as any;

      expect(result.mainEntity.itemListElement[0].item.url).toBe(
        'https://example.com/properties/TEST-123'
      );
    });
  });

  describe('injectJsonLdScript', () => {
    it('should generate valid script tag', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('<script type="application/ld+json">');
      expect(result).toContain('</script>');
    });

    it('should include properly formatted JSON', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('"@context": "https://schema.org"');
      expect(result).toContain('"@type": "WebSite"');
      expect(result).toContain('"name": "Test"');
    });

    it('should handle complex nested objects', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('PostalAddress');
      expect(result).toContain('123 Main St');
    });
  });

  describe('generatePageJsonLd', () => {
    it('should generate property page scripts', () => {
      const result = generatePageJsonLd('property', mockProperty);

      expect(result).toHaveLength(2);
      expect(result[0]).toContain('RealEstateListing');
      expect(result[1]).toContain('BreadcrumbList');
    });

    it('should generate listing page scripts', () => {
      const data: PaginatedPropertyResponse = {
        results: [mockProperty],
        pagination: {
          total: 1,
          offset: 0,
          limit: 20,
          hasMore: false,
        },
      };

      const result = generatePageJsonLd('listing', data);

      expect(result).toHaveLength(2);
      expect(result[0]).toContain('ItemList');
      expect(result[1]).toContain('BreadcrumbList');
    });

    it('should generate home page scripts', () => {
      const result = generatePageJsonLd('home', null);

      expect(result).toHaveLength(1);
      expect(result[0]).toContain('WebSite');
    });

    it('should include proper breadcrumbs for property page', () => {
      const result = generatePageJsonLd('property', mockProperty);

      expect(result[1]).toContain('Home');
      expect(result[1]).toContain('Properties');
      expect(result[1]).toContain('123 Main St');
    });

    it('should include proper breadcrumbs for listing page', () => {
      const data: PaginatedPropertyResponse = {
        results: [mockProperty],
        pagination: {
          total: 1,
          offset: 0,
          limit: 20,
          hasMore: false,
        },
      };

      const result = generatePageJsonLd('listing', data);

      expect(result[1]).toContain('Search Results');
    });

    it('should use custom website URL', () => {
      const result = generatePageJsonLd('home', null, 'https://custom.com');

      expect(result[0]).toContain('https://custom.com');
    });
  });

  describe('validateJsonLd', () => {
    it('should return no errors for valid JSON-LD', () => {
      const validJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const errors = validateJsonLd(validJsonLd);

      expect(errors).toHaveLength(0);
    });

    it('should detect missing @context', () => {
      const invalidJsonLd = {
        '@type': 'WebSite',
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('Missing @context field');
    });

    it('should detect missing @type', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('Missing @type field');
    });

    it('should validate RealEstateListing requires address', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        name: 'Test Property',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('RealEstateListing requires address field');
    });

    it('should validate RealEstateListing requires offers or price', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('RealEstateListing requires offers or price field');
    });

    it('should validate PostalAddress requires streetAddress', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'Thing',
        address: {
          '@type': 'PostalAddress',
          addressLocality: 'Austin',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('PostalAddress requires streetAddress');
    });

    it('should validate PostalAddress requires locality or region', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'Thing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('PostalAddress requires addressLocality or addressRegion');
    });

    it('should accept valid RealEstateListing with price instead of offers', () => {
      const validJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
          addressLocality: 'Austin',
        },
        price: 500000,
      };

      const errors = validateJsonLd(validJsonLd);

      expect(errors).not.toContain('RealEstateListing requires offers or price field');
    });

    it('should handle array @type with RealEstateListing', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': ['Place', 'RealEstateListing'],
        name: 'Test',
      };

      const errors = validateJsonLd(jsonLd);

      expect(errors).toContain('RealEstateListing requires address field');
    });

    it('should accumulate multiple errors', () => {
      const invalidJsonLd = {
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors.length).toBeGreaterThanOrEqual(2);
      expect(errors).toContain('Missing @context field');
      expect(errors).toContain('Missing @type field');
    });
  });
});
</file>

</files>
