This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  deduplication.test.ts
  json-ld.utils.test.ts
deduplication.ts
json-ld.utils.ts
README_ENHANCED.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/deduplication.test.ts">
import { removeDuplicatesFromQueue } from '../deduplication';

// Mock dependencies
jest.mock('../../queues/scraper.queue', () => ({
  scraperQueue: {
    getWaiting: jest.fn(),
    getDelayed: jest.fn(),
  },
}));

jest.mock('../../lib/prisma', () => ({
  prisma: {
    scrapeJob: {
      findMany: jest.fn(),
    },
  },
}));

jest.mock('../../lib/logger', () => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
}));

describe('removeDuplicatesFromQueue', () => {
  let scraperQueue: any;
  let prisma: any;
  let logger: any;

  beforeEach(() => {
    jest.clearAllMocks();

    const scraperQueueModule = require('../../queues/scraper.queue');
    scraperQueue = scraperQueueModule.scraperQueue;

    const prismaModule = require('../../lib/prisma');
    prisma = prismaModule.prisma;

    logger = require('../../lib/logger');
  });

  describe('with no duplicates', () => {
    it('should return zero removed when queue is empty', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result).toEqual({ removed: 0, failed: 0 });
      expect(scraperQueue.getWaiting).toHaveBeenCalled();
      expect(scraperQueue.getDelayed).toHaveBeenCalled();
    });

    it('should return zero removed when no duplicates exist', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn(),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn(),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result).toEqual({ removed: 0, failed: 0 });
      expect(mockJobs[0].remove).not.toHaveBeenCalled();
      expect(mockJobs[1].remove).not.toHaveBeenCalled();
    });
  });

  describe('with duplicate pending jobs', () => {
    it('should remove duplicate pending jobs and keep highest priority', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 5 }, // Higher priority (lower number)
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 }, // Lower priority (higher number)
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 15 }, // Lowest priority
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(2); // Remove 2 out of 3
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Keep highest priority
      expect(mockJobs[1].remove).toHaveBeenCalled(); // Remove
      expect(mockJobs[2].remove).toHaveBeenCalled(); // Remove
    });

    it('should handle jobs with no priority (default to 10)', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: {}, // No priority
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 15 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Default priority 10 < 15
      expect(mockJobs[1].remove).toHaveBeenCalled();
    });

    it('should handle multiple duplicate groups', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-4',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(2); // Remove 1 from each group
    });
  });

  describe('with already completed terms', () => {
    it('should remove all pending jobs for completed terms', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Smith' }, // Already completed
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      // Note: These 2 jobs are both duplicates AND completed, so they get removed
      // by both the duplicate removal logic and the completed term logic
      // This results in 3 removals (1 from duplicate handling + 2 from completed handling)
      expect(result.removed).toBe(3);
      expect(mockJobs[0].remove).toHaveBeenCalled();
      expect(mockJobs[1].remove).toHaveBeenCalled();
    });

    it('should handle mix of completed and unique terms', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' }, // Already completed
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Johnson' }, // Not completed
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Smith' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
      expect(mockJobs[0].remove).toHaveBeenCalled();
      expect(mockJobs[1].remove).not.toHaveBeenCalled();
    });
  });

  describe('with both waiting and delayed jobs', () => {
    it('should process jobs from both queues', async () => {
      const waitingJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      const delayedJobs = [
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(waitingJobs);
      scraperQueue.getDelayed.mockResolvedValue(delayedJobs);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1);
    });
  });

  describe('error handling', () => {
    it('should continue removing jobs even if some fail', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed')),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1); // 2 attempts, 1 success, 1 failure
      expect(result.failed).toBe(1);
    });

    it('should track multiple failures correctly', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Failed 1')),
        },
        {
          id: 'job-3',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Failed 2')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.failed).toBe(2);
      expect(result.removed).toBe(0);
    });

    it('should handle failures when removing completed terms', async () => {
      // Use only one job to avoid duplicate removal logic
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'CompletedTerm' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed for completed term')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'CompletedTerm' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(result.failed).toBe(1);
      expect(result.removed).toBe(0);
      expect(logger.error).toHaveBeenCalled();
    });
  });

  describe('verbose logging', () => {
    it('should log information when verbose is true', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(logger.info).toHaveBeenCalled();
      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('checking for duplicates')
      );
    });

    it('should not log when verbose is false', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: false });

      expect(logger.info).not.toHaveBeenCalled();
    });

    it('should log "No duplicates found" when verbose and queue is clean', async () => {
      scraperQueue.getWaiting.mockResolvedValue([]);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('No duplicates or completed terms found')
      );
    });

    it('should log errors for failed removals when verbose', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockRejectedValue(new Error('Remove failed')),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      expect(logger.error).toHaveBeenCalled();
    });

    it('should show "... and X more" when more than 10 duplicate terms', async () => {
      // Create 15 different search terms, each with 2 duplicate jobs
      const mockJobs = [];
      for (let i = 0; i < 15; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: `Term${i}` },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          },
          {
            id: `job-${i}-2`,
            data: { searchTerm: `Term${i}` },
            opts: { priority: 15 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('... and 5 more')
      );
    });

    it('should show "... and X more" when more than 20 completed terms', async () => {
      // Create 25 different completed terms, each with 1 pending job
      const mockJobs = [];
      const completedTerms = [];
      for (let i = 0; i < 25; i++) {
        mockJobs.push({
          id: `job-${i}`,
          data: { searchTerm: `CompletedTerm${i}` },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        });
        completedTerms.push({ searchTerm: `CompletedTerm${i}` });
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue(completedTerms);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      expect(logger.info).toHaveBeenCalledWith(
        expect.stringContaining('... and 5 more')
      );
    });
  });

  describe('progress reporting', () => {
    it('should show progress when showProgress is true and removing many jobs', async () => {
      // Create enough duplicate jobs to trigger progress reporting (10+ removals)
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: 'DuplicateTerm' },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      // Mock process.stdout.write to verify progress output
      const stdoutWriteSpy = jest.spyOn(process.stdout, 'write').mockImplementation();

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      // Should have written progress at 10 removals
      expect(stdoutWriteSpy).toHaveBeenCalledWith(
        expect.stringContaining('Progress: 10/')
      );

      stdoutWriteSpy.mockRestore();
    });

    it('should not show progress when showProgress is false', async () => {
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push(
          {
            id: `job-${i}-1`,
            data: { searchTerm: 'DuplicateTerm' },
            opts: { priority: 10 },
            remove: jest.fn().mockResolvedValue(true),
          }
        );
      }

      const stdoutWriteSpy = jest.spyOn(process.stdout, 'write').mockImplementation();

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: false });

      // Should not have written any progress
      expect(stdoutWriteSpy).not.toHaveBeenCalled();

      stdoutWriteSpy.mockRestore();
    });

    it('should log new line after progress when verbose and showProgress', async () => {
      const mockJobs = [];
      for (let i = 0; i < 12; i++) {
        mockJobs.push({
          id: `job-${i}`,
          data: { searchTerm: 'CompletedTerm' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        });
      }

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'CompletedTerm' },
      ]);

      await removeDuplicatesFromQueue({ verbose: true, showProgress: true });

      // Should log empty string for new line after progress (line 172)
      expect(logger.info).toHaveBeenCalledWith('');
    });
  });

  describe('complex scenarios', () => {
    it('should handle combination of duplicates and completed terms', async () => {
      const mockJobs = [
        // Duplicates for 'Smith' (2 jobs)
        {
          id: 'job-1',
          data: { searchTerm: 'Smith' },
          opts: { priority: 5 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: 'Smith' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        // Already completed 'Johnson' (should remove all)
        {
          id: 'job-3',
          data: { searchTerm: 'Johnson' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        // Unique 'Williams' (should keep)
        {
          id: 'job-4',
          data: { searchTerm: 'Williams' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([
        { searchTerm: 'Johnson' },
      ]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      // Should remove: 1 duplicate Smith + 1 completed Johnson = 2 total
      expect(result.removed).toBe(2);
      expect(mockJobs[0].remove).not.toHaveBeenCalled(); // Keep high priority Smith
      expect(mockJobs[1].remove).toHaveBeenCalled(); // Remove duplicate Smith
      expect(mockJobs[2].remove).toHaveBeenCalled(); // Remove completed Johnson
      expect(mockJobs[3].remove).not.toHaveBeenCalled(); // Keep unique Williams
    });

    it('should handle empty searchTerm gracefully', async () => {
      const mockJobs = [
        {
          id: 'job-1',
          data: { searchTerm: '' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
        {
          id: 'job-2',
          data: { searchTerm: '' },
          opts: { priority: 10 },
          remove: jest.fn().mockResolvedValue(true),
        },
      ];

      scraperQueue.getWaiting.mockResolvedValue(mockJobs);
      scraperQueue.getDelayed.mockResolvedValue([]);
      prisma.scrapeJob.findMany.mockResolvedValue([]);

      const result = await removeDuplicatesFromQueue({ verbose: false });

      expect(result.removed).toBe(1); // Treat empty strings as duplicates
    });
  });
});
</file>

<file path="__tests__/json-ld.utils.test.ts">
import {
  generatePropertyJsonLd,
  generatePropertyListJsonLd,
  generateOrganizationJsonLd,
  generateBreadcrumbJsonLd,
  generatePropertyCollectionJsonLd,
  injectJsonLdScript,
  generatePageJsonLd,
  validateJsonLd,
} from '../json-ld.utils';
import { PropertyAPI, PaginatedPropertyResponse } from '../../types/property.types';

describe('JSON-LD Utils', () => {
  const mockProperty: PropertyAPI = {
    '@type': 'RealEstateListing',
    propertyId: 'TEST-123',
    address: {
      formatted: '123 Main St, Austin, TX 78701',
      shortFormat: '123 Main St',
      streetAddress: '123 Main St',
      addressLocality: 'Austin',
      addressRegion: 'TX',
      addressCountry: 'US',
      postalCode: '78701',
    },
    propertyType: 'Residential',
    owner: {
      '@type': 'Person',
      name: 'John Doe',
    },
    valuation: {
      appraisedValue: {
        value: 500000,
        currency: 'USD',
        formatted: '$500,000',
      },
      assessedValue: {
        value: 450000,
        currency: 'USD',
        formatted: '$450,000',
      },
    },
    geography: {
      latitude: 30.2672,
      longitude: -97.7431,
      neighborhood: 'Downtown',
    },
    legalDescription: 'Lot 5, Block 3, Downtown Addition',
    metadata: {
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-02T00:00:00Z',
      scrapedAt: '2024-01-01T00:00:00Z',
      dataFreshness: 'fresh' as const,
    },
  };

  describe('generatePropertyJsonLd', () => {
    it('should generate valid property JSON-LD with all fields', () => {
      const result = generatePropertyJsonLd(mockProperty, 'TCAD', 'https://example.com');

      expect(result).toMatchObject({
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        '@id': 'https://example.com/properties/TEST-123',
        identifier: 'TEST-123',
        name: '123 Main St, Austin, TX 78701 - TCAD Property',
      });
    });

    it('should include address information', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.address).toEqual({
        '@type': 'PostalAddress',
        streetAddress: '123 Main St',
        addressLocality: 'Austin',
        addressRegion: 'TX',
        addressCountry: 'US',
        postalCode: '78701',
      });
    });

    it('should include geographic coordinates when available', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.geo).toEqual({
        '@type': 'GeoCoordinates',
        latitude: 30.2672,
        longitude: -97.7431,
      });
    });

    it('should include owner/seller information', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.seller).toEqual({
        '@type': 'Person',
        name: 'John Doe',
      });
    });

    it('should include pricing offers', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.offers).toMatchObject({
        '@type': 'Offer',
        price: 500000,
        priceCurrency: 'USD',
      });
    });

    it('should include both appraised and assessed values in price specifications', () => {
      const result = generatePropertyJsonLd(mockProperty) as any;

      expect(result.offers.priceSpecification).toHaveLength(2);
      expect(result.offers.priceSpecification[0]).toMatchObject({
        '@type': 'PriceSpecification',
        price: 500000,
        name: 'Appraised Value',
      });
      expect(result.offers.priceSpecification[1]).toMatchObject({
        '@type': 'PriceSpecification',
        price: 450000,
        name: 'Assessed Value',
      });
    });

    it('should work without optional fields', () => {
      const minimalProperty: PropertyAPI = {
        propertyId: 'MIN-123',
        address: {
          formatted: '456 Oak Ave',
          streetAddress: '456 Oak Ave',
          addressLocality: 'Austin',
          addressRegion: 'TX',
          addressCountry: 'US',
        },
        propertyType: 'Commercial',
        valuation: {
          appraisedValue: {
            value: 1000000,
            currency: 'USD',
            formatted: '$1,000,000',
          },
        },
        metadata: {
          createdAt: '2024-01-01T00:00:00Z',
          updatedAt: '2024-01-01T00:00:00Z',
          scrapedAt: '2024-01-01T00:00:00Z',
          dataFreshness: 'fresh' as const,
        },
      };

      const result = generatePropertyJsonLd(minimalProperty) as any;

      expect(result['@type']).toBe('RealEstateListing');
      expect(result.identifier).toBe('MIN-123');
      expect(result.geo).toBeUndefined();
      expect(result.seller).toBeUndefined();
    });
  });

  describe('generatePropertyListJsonLd', () => {
    const mockResponse: PaginatedPropertyResponse = {
      results: [mockProperty],
      pagination: {
        total: 1,
        offset: 0,
        limit: 20,
        hasMore: false,
      },
    };

    it('should generate valid ItemList JSON-LD', () => {
      const result = generatePropertyListJsonLd(mockResponse);

      expect(result).toMatchObject({
        '@context': 'https://schema.org',
        '@type': 'ItemList',
        numberOfItems: 1,
      });
    });

    it('should include search query in name when provided', () => {
      const result = generatePropertyListJsonLd(mockResponse, 'Austin homes') as any;

      expect(result.name).toBe('Property Search Results for "Austin homes"');
    });

    it('should use default name when no search query', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.name).toBe('Travis County Properties');
    });

    it('should include list items with correct positions', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.itemListElement).toHaveLength(1);
      expect(result.itemListElement[0]).toMatchObject({
        '@type': 'ListItem',
        position: 1,
      });
    });

    it('should include item details for each property', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.itemListElement[0].item).toMatchObject({
        '@type': 'RealEstateListing',
        '@id': 'https://example.com/properties/TEST-123',
        identifier: 'TEST-123',
        name: '123 Main St, Austin, TX 78701',
      });
    });

    it('should include nextItem when hasMore is true', () => {
      const responseWithMore: PaginatedPropertyResponse = {
        ...mockResponse,
        pagination: {
          ...mockResponse.pagination,
          hasMore: true,
        },
      };

      const result = generatePropertyListJsonLd(responseWithMore) as any;

      expect(result.nextItem).toBeDefined();
      expect(result.nextItem).toContain('offset=20');
    });

    it('should not include nextItem when hasMore is false', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.nextItem).toBeUndefined();
    });

    it('should include search action', () => {
      const result = generatePropertyListJsonLd(mockResponse) as any;

      expect(result.potentialAction).toMatchObject({
        '@type': 'SearchAction',
        'query-input': 'required name=search_term_string',
      });
    });
  });

  describe('generateOrganizationJsonLd', () => {
    it('should generate valid WebSite JSON-LD with defaults', () => {
      const result = generateOrganizationJsonLd() as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('WebSite');
      expect(result.name).toBeDefined();
      expect(result.url).toBeDefined();
    });

    it('should use custom website URL', () => {
      const result = generateOrganizationJsonLd('https://custom.com') as any;

      expect(result.url).toBe('https://custom.com');
    });

    it('should use custom organization name', () => {
      const result = generateOrganizationJsonLd('https://example.com', 'Custom TCAD') as any;

      expect(result.name).toBe('Custom TCAD');
    });

    it('should include description', () => {
      const result = generateOrganizationJsonLd() as any;

      expect(result.description).toBeDefined();
      expect(typeof result.description).toBe('string');
    });
  });

  describe('generateBreadcrumbJsonLd', () => {
    it('should generate valid BreadcrumbList JSON-LD', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' },
        { name: 'Details' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('BreadcrumbList');
      expect(result.itemListElement).toHaveLength(3);
    });

    it('should set correct position for each item', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result.itemListElement[0].position).toBe(1);
      expect(result.itemListElement[1].position).toBe(2);
    });

    it('should include URLs when provided', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' }
      ];

      const result = generateBreadcrumbJsonLd(items, 'https://example.com') as any;

      expect(result.itemListElement[0].item).toBe('https://example.com/');
      expect(result.itemListElement[1].item).toBe('https://example.com/properties');
    });

    it('should omit item field when URL not provided', () => {
      const items = [
        { name: 'Home', url: '/' },
        { name: 'Current Page' }
      ];

      const result = generateBreadcrumbJsonLd(items) as any;

      expect(result.itemListElement[0].item).toBeDefined();
      expect(result.itemListElement[1].item).toBeUndefined();
    });

    it('should handle empty items array', () => {
      const result = generateBreadcrumbJsonLd([]) as any;

      expect(result.itemListElement).toHaveLength(0);
    });
  });

  describe('generatePropertyCollectionJsonLd', () => {
    const mockProperties: PropertyAPI[] = [
      mockProperty,
      {
        ...mockProperty,
        propertyId: 'TEST-456',
        valuation: {
          appraisedValue: {
            value: 750000,
            currency: 'USD',
            formatted: '$750,000',
          },
        },
      },
    ];

    it('should generate valid CollectionPage JSON-LD', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('CollectionPage');
      expect(result.name).toBe('Austin Properties');
    });

    it('should include correct number of items', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result.description).toBe('Collection of 2 properties');
      expect(result.mainEntity.numberOfItems).toBe(2);
    });

    it('should limit list items to 10', () => {
      const manyProperties = Array(15).fill(mockProperty).map((p, i) => ({
        ...p,
        propertyId: `TEST-${i}`,
      }));

      const result = generatePropertyCollectionJsonLd(
        manyProperties,
        'Large Collection',
        'custom'
      ) as any;

      expect(result.mainEntity.itemListElement).toHaveLength(10);
    });

    it('should calculate aggregate statistics correctly', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city'
      ) as any;

      expect(result.aggregateRating).toMatchObject({
        '@type': 'AggregateOffer',
        lowPrice: 500000,
        highPrice: 750000,
        priceCurrency: 'USD',
        offerCount: 2,
        averagePrice: 625000,
      });
    });

    it('should include city metadata for city collections', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin',
        'city'
      ) as any;

      expect(result.about).toEqual({
        '@type': 'City',
        name: 'Austin',
      });
    });

    it('should omit city metadata for non-city collections', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Residential',
        'type'
      ) as any;

      expect(result.about).toBeUndefined();
    });

    it('should include modification date', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Test Collection',
        'custom'
      ) as any;

      expect(result.dateModified).toBeDefined();
      expect(new Date(result.dateModified)).toBeInstanceOf(Date);
    });

    it('should include item URLs', () => {
      const result = generatePropertyCollectionJsonLd(
        mockProperties,
        'Austin Properties',
        'city',
        'https://example.com'
      ) as any;

      expect(result.mainEntity.itemListElement[0].item.url).toBe(
        'https://example.com/properties/TEST-123'
      );
    });
  });

  describe('injectJsonLdScript', () => {
    it('should generate valid script tag', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('<script type="application/ld+json">');
      expect(result).toContain('</script>');
    });

    it('should include properly formatted JSON', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('"@context": "https://schema.org"');
      expect(result).toContain('"@type": "WebSite"');
      expect(result).toContain('"name": "Test"');
    });

    it('should handle complex nested objects', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const result = injectJsonLdScript(jsonLd);

      expect(result).toContain('PostalAddress');
      expect(result).toContain('123 Main St');
    });
  });

  describe('generatePageJsonLd', () => {
    it('should generate property page scripts', () => {
      const result = generatePageJsonLd('property', mockProperty);

      expect(result).toHaveLength(2);
      expect(result[0]).toContain('RealEstateListing');
      expect(result[1]).toContain('BreadcrumbList');
    });

    it('should generate listing page scripts', () => {
      const data: PaginatedPropertyResponse = {
        results: [mockProperty],
        pagination: {
          total: 1,
          offset: 0,
          limit: 20,
          hasMore: false,
        },
      };

      const result = generatePageJsonLd('listing', data);

      expect(result).toHaveLength(2);
      expect(result[0]).toContain('ItemList');
      expect(result[1]).toContain('BreadcrumbList');
    });

    it('should generate home page scripts', () => {
      const result = generatePageJsonLd('home', null);

      expect(result).toHaveLength(1);
      expect(result[0]).toContain('WebSite');
    });

    it('should include proper breadcrumbs for property page', () => {
      const result = generatePageJsonLd('property', mockProperty);

      expect(result[1]).toContain('Home');
      expect(result[1]).toContain('Properties');
      expect(result[1]).toContain('123 Main St');
    });

    it('should include proper breadcrumbs for listing page', () => {
      const data: PaginatedPropertyResponse = {
        results: [mockProperty],
        pagination: {
          total: 1,
          offset: 0,
          limit: 20,
          hasMore: false,
        },
      };

      const result = generatePageJsonLd('listing', data);

      expect(result[1]).toContain('Search Results');
    });

    it('should use custom website URL', () => {
      const result = generatePageJsonLd('home', null, 'https://custom.com');

      expect(result[0]).toContain('https://custom.com');
    });
  });

  describe('validateJsonLd', () => {
    it('should return no errors for valid JSON-LD', () => {
      const validJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'WebSite',
        name: 'Test',
      };

      const errors = validateJsonLd(validJsonLd);

      expect(errors).toHaveLength(0);
    });

    it('should detect missing @context', () => {
      const invalidJsonLd = {
        '@type': 'WebSite',
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('Missing @context field');
    });

    it('should detect missing @type', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('Missing @type field');
    });

    it('should validate RealEstateListing requires address', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        name: 'Test Property',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('RealEstateListing requires address field');
    });

    it('should validate RealEstateListing requires offers or price', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('RealEstateListing requires offers or price field');
    });

    it('should validate PostalAddress requires streetAddress', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'Thing',
        address: {
          '@type': 'PostalAddress',
          addressLocality: 'Austin',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('PostalAddress requires streetAddress');
    });

    it('should validate PostalAddress requires locality or region', () => {
      const invalidJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'Thing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
        },
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors).toContain('PostalAddress requires addressLocality or addressRegion');
    });

    it('should accept valid RealEstateListing with price instead of offers', () => {
      const validJsonLd = {
        '@context': 'https://schema.org',
        '@type': 'RealEstateListing',
        address: {
          '@type': 'PostalAddress',
          streetAddress: '123 Main St',
          addressLocality: 'Austin',
        },
        price: 500000,
      };

      const errors = validateJsonLd(validJsonLd);

      expect(errors).not.toContain('RealEstateListing requires offers or price field');
    });

    it('should handle array @type with RealEstateListing', () => {
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': ['Place', 'RealEstateListing'],
        name: 'Test',
      };

      const errors = validateJsonLd(jsonLd);

      expect(errors).toContain('RealEstateListing requires address field');
    });

    it('should accumulate multiple errors', () => {
      const invalidJsonLd = {
        name: 'Test',
      };

      const errors = validateJsonLd(invalidJsonLd);

      expect(errors.length).toBeGreaterThanOrEqual(2);
      expect(errors).toContain('Missing @context field');
      expect(errors).toContain('Missing @type field');
    });
  });
});
</file>

<file path="deduplication.ts">
import { scraperQueue } from '../queues/scraper.queue';
import { prisma } from '../lib/prisma';
import logger from '../lib/logger';

interface DeduplicationOptions {
  verbose?: boolean;
  showProgress?: boolean;
}

export async function removeDuplicatesFromQueue(options: DeduplicationOptions = {}) {
  const { verbose = true, showProgress = true } = options;

  if (verbose) {
    logger.info('ðŸ” Now checking for duplicates...\n');
  }

  // Get all pending jobs (waiting + delayed)
  const [waitingJobs, delayedJobs] = await Promise.all([
    scraperQueue.getWaiting(),
    scraperQueue.getDelayed(),
  ]);

  const allPendingJobs = [...waitingJobs, ...delayedJobs];

  if (verbose) {
    logger.info(`ðŸ“Š Queue State:`);
    logger.info(`   Waiting: ${waitingJobs.length}`);
    logger.info(`   Delayed: ${delayedJobs.length}`);
    logger.info(`   Total Pending: ${allPendingJobs.length}\n`);
  }

  // Get completed search terms from database
  const completedTerms = await prisma.scrapeJob.findMany({
    where: { status: 'completed' },
    select: { searchTerm: true },
    distinct: ['searchTerm'],
  });

  const completedTermSet = new Set(completedTerms.map(j => j.searchTerm));

  // Track search terms and their job IDs
  const termMap = new Map<string, Array<{ job: any; priority: number; state: string }>>();

  // Build map of search terms to jobs
  for (const job of allPendingJobs) {
    const term = job.data.searchTerm;
    let state = 'waiting';
    if (delayedJobs.includes(job)) state = 'delayed';

    if (!termMap.has(term)) {
      termMap.set(term, []);
    }
    termMap.get(term)!.push({
      job,
      priority: job.opts.priority || 10,
      state
    });
  }

  // Find duplicates within pending jobs
  const duplicateTerms = Array.from(termMap.entries())
    .filter(([_, jobs]) => jobs.length > 1);

  // Find jobs that were already completed
  const alreadyCompletedTerms = Array.from(termMap.entries())
    .filter(([term, _]) => completedTermSet.has(term));

  if (verbose) {
    logger.info(`ðŸ” Analysis:`);
    logger.info(`   Unique pending terms: ${termMap.size}`);
    logger.info(`   âŒ Terms with duplicate pending jobs: ${duplicateTerms.length}`);
    logger.info(`   âœ… Terms already completed: ${alreadyCompletedTerms.length}`);
  }

  let totalToRemove = 0;

  // Count duplicates
  for (const [_, jobs] of duplicateTerms) {
    totalToRemove += jobs.length - 1; // Keep one
  }

  // Count already completed
  for (const [_, jobs] of alreadyCompletedTerms) {
    totalToRemove += jobs.length; // Remove all
  }

  if (verbose) {
    logger.info(`   ðŸ—‘ï¸  Total jobs to remove: ${totalToRemove}\n`);
  }

  if (totalToRemove === 0) {
    if (verbose) {
      logger.info('âœ… No duplicates or completed terms found!');
    }
    return { removed: 0, failed: 0 };
  }

  // Show what we're removing
  if (verbose) {
    if (duplicateTerms.length > 0) {
      logger.info('ðŸ“ Duplicate pending jobs:');
      const displayCount = showProgress ? 10 : duplicateTerms.length;
      duplicateTerms.slice(0, displayCount).forEach(([term, jobs]) => {
        logger.info(`   "${term}": ${jobs.length} copies (keeping 1, removing ${jobs.length - 1})`);
      });
      if (duplicateTerms.length > displayCount) {
        logger.info(`   ... and ${duplicateTerms.length - displayCount} more`);
      }
      logger.info('');
    }

    if (alreadyCompletedTerms.length > 0) {
      logger.info('ðŸ“ Already completed terms in queue:');
      const displayCount = showProgress ? 20 : alreadyCompletedTerms.length;
      alreadyCompletedTerms.slice(0, displayCount).forEach(([term, jobs]) => {
        logger.info(`   "${term}": ${jobs.length} pending (removing all)`);
      });
      if (alreadyCompletedTerms.length > displayCount) {
        logger.info(`   ... and ${alreadyCompletedTerms.length - displayCount} more`);
      }
      logger.info('');
    }

    logger.info(`ðŸš€ Removing ${totalToRemove} duplicate/completed jobs...`);
  }

  let removed = 0;
  let failed = 0;

  // Remove duplicates (keep highest priority)
  for (const [term, jobs] of duplicateTerms) {
    // Sort by priority (lower number = higher priority)
    jobs.sort((a, b) => a.priority - b.priority);

    // Remove all but the first (highest priority) job
    for (let i = 1; i < jobs.length; i++) {
      try {
        await jobs[i].job.remove();
        removed++;
        if (showProgress && removed % 10 === 0) {
          process.stdout.write(`\r   Progress: ${removed}/${totalToRemove} (${((removed/totalToRemove)*100).toFixed(1)}%)`);
        }
      } catch (error: any) {
        failed++;
        if (verbose && failed <= 3) {
          logger.error(`${showProgress ? '\n' : ''}   âŒ Failed to remove job ${jobs[i].job.id}:`, error.message);
        }
      }
    }
  }

  // Remove already completed terms
  for (const [term, jobs] of alreadyCompletedTerms) {
    for (const jobInfo of jobs) {
      try {
        await jobInfo.job.remove();
        removed++;
        if (showProgress && removed % 10 === 0) {
          process.stdout.write(`\r   Progress: ${removed}/${totalToRemove} (${((removed/totalToRemove)*100).toFixed(1)}%)`);
        }
      } catch (error: any) {
        failed++;
        if (verbose && failed <= 3) {
          logger.error(`${showProgress ? '\n' : ''}   âŒ Failed to remove job ${jobInfo.job.id}:`, error.message);
        }
      }
    }
  }

  if (verbose) {
    if (showProgress) {
      logger.info(''); // New line after progress
    }
    logger.info(`\nâœ… Cleanup complete!`);
    logger.info(`   - Successfully removed: ${removed}`);
    logger.info(`   - Failed to remove: ${failed}`);
  }

  return { removed, failed };
}
</file>

<file path="json-ld.utils.ts">
/**
 * JSON-LD Structured Data Utilities for TCAD Properties
 *
 * This module provides utilities to generate Schema.org compliant JSON-LD
 * structured data for maximum SEO value. It supports various contexts including
 * individual property pages, property listings, and search results.
 *
 * @see https://schema.org/RealEstateListing
 * @see https://developers.google.com/search/docs/appearance/structured-data
 */

import { PropertyAPI, PropertyDatabase, PaginatedPropertyResponse } from '../types/property.types';

// ============================================================================
// Type Definitions for JSON-LD
// ============================================================================

interface JsonLdBase {
  '@context': 'https://schema.org';
  '@type': string | string[];
  '@id'?: string;
}

interface BreadcrumbItem {
  '@type': 'ListItem';
  position: number;
  name: string;
  item?: string;
}

interface SearchAction {
  '@type': 'SearchAction';
  target: {
    '@type': 'EntryPoint';
    urlTemplate: string;
  };
  'query-input': string;
}

// ============================================================================
// Individual Property JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a single property detail page
 * This provides the most comprehensive structured data for SEO
 */
export function generatePropertyJsonLd(
  property: PropertyAPI,
  organizationName = 'Travis County Appraisal District',
  websiteUrl = 'https://example.com'
): object {
  const jsonLd: any = {
    '@context': 'https://schema.org',
    '@type': property['@type'] || 'RealEstateListing',
    '@id': `${websiteUrl}/properties/${property.propertyId}`,

    // Core property information
    identifier: property.propertyId,
    name: `${property.address.formatted} - TCAD Property`,
    description: property.legalDescription ||
      `${property.propertyType} property located at ${property.address.formatted}`,

    // Address with full PostalAddress structure
    address: {
      '@type': 'PostalAddress',
      streetAddress: property.address.streetAddress,
      addressLocality: property.address.addressLocality,
      addressRegion: property.address.addressRegion,
      addressCountry: property.address.addressCountry,
      postalCode: property.address.postalCode
    },

    // Geographic coordinates if available
    ...(property.geography?.latitude && property.geography?.longitude && {
      geo: {
        '@type': 'GeoCoordinates',
        latitude: property.geography.latitude,
        longitude: property.geography.longitude
      }
    }),

    // Property type categorization
    additionalType: property.propertyType,

    // Owner/Seller information
    ...(property.owner && {
      seller: {
        '@type': property.owner['@type'] || 'Person',
        name: property.owner.name
      }
    }),

    // Pricing and valuation
    offers: {
      '@type': 'Offer',
      price: property.valuation.appraisedValue.value,
      priceCurrency: property.valuation.appraisedValue.currency,

      // Additional price specifications
      priceSpecification: [
        {
          '@type': 'PriceSpecification',
          price: property.valuation.appraisedValue.value,
          priceCurrency: property.valuation.appraisedValue.currency,
          name: 'Appraised Value',
          description: 'Market value as determined by TCAD'
        },
        ...(property.valuation.assessedValue ? [{
          '@type': 'PriceSpecification',
          price: property.valuation.assessedValue.value,
          priceCurrency: property.valuation.assessedValue.currency,
          name: 'Assessed Value',
          description: 'Tax assessed value for property tax calculations'
        }] : [])
      ],

      // Seller/offerer information
      seller: {
        '@type': 'Organization',
        name: organizationName,
        url: websiteUrl
      },

      // Validity dates based on data freshness
      validFrom: property.metadata.scrapedAt,
      ...(property.metadata.dataFreshness === 'stale' && {
        validThrough: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
      })
    },

    // Additional property details
    ...(property.geography?.neighborhood && {
      containedInPlace: {
        '@type': 'Place',
        name: property.geography.neighborhood
      }
    }),

    // Data provider information
    provider: {
      '@type': 'Organization',
      name: organizationName,
      url: websiteUrl,
      sameAs: [
        'https://www.traviscad.org'
      ]
    },

    // Metadata
    datePosted: property.metadata.createdAt,
    dateModified: property.metadata.updatedAt,

    // Potential actions
    potentialAction: [
      {
        '@type': 'ViewAction',
        target: `${websiteUrl}/properties/${property.propertyId}`,
        name: 'View Property Details'
      }
    ]
  };

  return jsonLd;
}

// ============================================================================
// Property Listing/Search Results JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a property listing or search results page
 * Implements ItemList for better search result presentation
 */
export function generatePropertyListJsonLd(
  response: PaginatedPropertyResponse,
  searchQuery?: string,
  websiteUrl = 'https://example.com'
): object {
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'ItemList',
    name: searchQuery
      ? `Property Search Results for "${searchQuery}"`
      : 'Travis County Properties',
    description: `Browse ${response.pagination.total} properties in Travis County`,
    numberOfItems: response.pagination.total,

    // Individual property items
    itemListElement: response.results.map((property, index) => ({
      '@type': 'ListItem',
      position: response.pagination.offset + index + 1,
      item: {
        '@type': property['@type'] || 'RealEstateListing',
        '@id': `${websiteUrl}/properties/${property.propertyId}`,
        identifier: property.propertyId,
        name: property.address.formatted,
        description: `${property.propertyType} - ${property.valuation.appraisedValue.formatted}`,

        address: {
          '@type': 'PostalAddress',
          streetAddress: property.address.streetAddress,
          addressLocality: property.address.addressLocality,
          addressRegion: property.address.addressRegion,
          addressCountry: property.address.addressCountry
        },

        offers: {
          '@type': 'Offer',
          price: property.valuation.appraisedValue.value,
          priceCurrency: property.valuation.appraisedValue.currency
        },

        url: `${websiteUrl}/properties/${property.propertyId}`
      }
    })),

    // Pagination information
    ...(response.pagination.hasMore && {
      nextItem: `${websiteUrl}/search?offset=${response.pagination.offset + response.pagination.limit}`
    }),

    // Search action for the listing
    potentialAction: {
      '@type': 'SearchAction',
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${websiteUrl}/search?q={search_term_string}`
      },
      'query-input': 'required name=search_term_string'
    }
  };

  return jsonLd;
}

// ============================================================================
// Website/Organization JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for the website/organization
 * Should be included on the homepage
 */
export function generateOrganizationJsonLd(
  websiteUrl = 'https://example.com',
  organizationName = 'TCAD Property Search'
): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    '@id': websiteUrl,
    name: organizationName,
    description: 'Search and browse Travis County Appraisal District property records',
    url: websiteUrl,

    // Publisher/operator
    publisher: {
      '@type': 'Organization',
      name: organizationName,
      url: websiteUrl,
      logo: {
        '@type': 'ImageObject',
        url: `${websiteUrl}/logo.png`,
        width: 600,
        height: 60
      }
    },

    // Site search box
    potentialAction: {
      '@type': 'SearchAction',
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${websiteUrl}/search?q={search_term_string}`
      },
      'query-input': 'required name=search_term_string'
    },

    // Related entities
    about: {
      '@type': 'Thing',
      name: 'Travis County Property Records',
      description: 'Official property appraisal and tax assessment records for Travis County, Texas'
    },

    // Geographic service area
    areaServed: {
      '@type': 'AdministrativeArea',
      name: 'Travis County',
      containedInPlace: {
        '@type': 'State',
        name: 'Texas',
        containedInPlace: {
          '@type': 'Country',
          name: 'United States'
        }
      }
    }
  };
}

// ============================================================================
// Breadcrumb JSON-LD
// ============================================================================

/**
 * Generate breadcrumb JSON-LD for navigation
 */
export function generateBreadcrumbJsonLd(
  items: Array<{ name: string; url?: string }>,
  websiteUrl = 'https://example.com'
): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: items.map((item, index) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: item.name,
      ...(item.url && {
        item: `${websiteUrl}${item.url}`
      })
    }))
  };
}

// ============================================================================
// Property Collection JSON-LD
// ============================================================================

/**
 * Generate JSON-LD for a collection of properties (e.g., by city or type)
 */
export function generatePropertyCollectionJsonLd(
  properties: PropertyAPI[],
  collectionName: string,
  collectionType: 'city' | 'type' | 'custom',
  websiteUrl = 'https://example.com'
): object {
  const totalValue = properties.reduce(
    (sum, p) => sum + p.valuation.appraisedValue.value,
    0
  );

  const avgValue = totalValue / properties.length;

  return {
    '@context': 'https://schema.org',
    '@type': 'CollectionPage',
    name: collectionName,
    description: `Collection of ${properties.length} properties`,

    // Main entity of the page
    mainEntity: {
      '@type': 'ItemList',
      numberOfItems: properties.length,
      itemListElement: properties.slice(0, 10).map((property, index) => ({
        '@type': 'ListItem',
        position: index + 1,
        item: {
          '@type': property['@type'] || 'RealEstateListing',
          identifier: property.propertyId,
          name: property.address.formatted,
          offers: {
            '@type': 'Offer',
            price: property.valuation.appraisedValue.value,
            priceCurrency: property.valuation.appraisedValue.currency
          },
          url: `${websiteUrl}/properties/${property.propertyId}`
        }
      }))
    },

    // Aggregate statistics
    aggregateRating: {
      '@type': 'AggregateOffer',
      lowPrice: Math.min(...properties.map(p => p.valuation.appraisedValue.value)),
      highPrice: Math.max(...properties.map(p => p.valuation.appraisedValue.value)),
      priceCurrency: 'USD',
      offerCount: properties.length,
      averagePrice: avgValue
    },

    // Collection metadata
    ...(collectionType === 'city' && {
      about: {
        '@type': 'City',
        name: collectionName
      }
    }),

    dateModified: new Date().toISOString()
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Inject JSON-LD script into HTML head
 */
export function injectJsonLdScript(jsonLd: object): string {
  return `<script type="application/ld+json">
${JSON.stringify(jsonLd, null, 2)}
</script>`;
}

/**
 * Generate multiple JSON-LD scripts for a page
 */
export function generatePageJsonLd(
  type: 'property' | 'listing' | 'home',
  data: any,
  websiteUrl = 'https://example.com'
): string[] {
  const scripts: string[] = [];

  switch (type) {
    case 'property':
      // Individual property page
      scripts.push(injectJsonLdScript(generatePropertyJsonLd(data, undefined, websiteUrl)));
      scripts.push(injectJsonLdScript(generateBreadcrumbJsonLd([
        { name: 'Home', url: '/' },
        { name: 'Properties', url: '/properties' },
        { name: data.address.shortFormat }
      ], websiteUrl)));
      break;

    case 'listing':
      // Property listing/search results
      scripts.push(injectJsonLdScript(generatePropertyListJsonLd(data, undefined, websiteUrl)));
      scripts.push(injectJsonLdScript(generateBreadcrumbJsonLd([
        { name: 'Home', url: '/' },
        { name: 'Search Results' }
      ], websiteUrl)));
      break;

    case 'home':
      // Homepage
      scripts.push(injectJsonLdScript(generateOrganizationJsonLd(websiteUrl)));
      break;
  }

  return scripts;
}

/**
 * Validate JSON-LD structure
 * Returns validation errors if any
 */
export function validateJsonLd(jsonLd: any): string[] {
  const errors: string[] = [];

  // Check for required @context
  if (!jsonLd['@context']) {
    errors.push('Missing @context field');
  }

  // Check for required @type
  if (!jsonLd['@type']) {
    errors.push('Missing @type field');
  }

  // Validate RealEstateListing specific fields
  if (jsonLd['@type'] === 'RealEstateListing' ||
      (Array.isArray(jsonLd['@type']) && jsonLd['@type'].includes('RealEstateListing'))) {
    if (!jsonLd.address) {
      errors.push('RealEstateListing requires address field');
    }
    if (!jsonLd.offers && !jsonLd.price) {
      errors.push('RealEstateListing requires offers or price field');
    }
  }

  // Validate PostalAddress
  if (jsonLd.address && jsonLd.address['@type'] === 'PostalAddress') {
    if (!jsonLd.address.streetAddress) {
      errors.push('PostalAddress requires streetAddress');
    }
    if (!jsonLd.address.addressLocality && !jsonLd.address.addressRegion) {
      errors.push('PostalAddress requires addressLocality or addressRegion');
    }
  }

  return errors;
}

export default {
  generatePropertyJsonLd,
  generatePropertyListJsonLd,
  generateOrganizationJsonLd,
  generateBreadcrumbJsonLd,
  generatePropertyCollectionJsonLd,
  generatePageJsonLd,
  validateJsonLd,
  injectJsonLdScript
};
</file>

<file path="README_ENHANCED.md">
# utils

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "utils",
  "description": "Directory containing 2 code files with 4 classes and 1 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "4 class definitions",
    "1 function definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Subdirectories

- `__tests__/`

## Files and Schemas

### `deduplication.ts` (typescript)

**Classes:**
- `DeduplicationOptions` - Line 4

**Functions:**
- `async removeDuplicatesFromQueue()` - Line 9

### `json-ld.utils.ts` (typescript)

**Classes:**
- `JsonLdBase` - Line 17
- `BreadcrumbItem` - Line 23
- `SearchAction` - Line 30

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

</files>
