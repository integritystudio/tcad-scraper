This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
index.ts
property.types.ts
README_ENHANCED.md
README.md
SCHEMA-DOCUMENTATION.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="index.ts">
// Scraper configuration types
export interface ScraperConfig {
  headless: boolean;
  timeout: number;
  retryAttempts: number;
  retryDelay: number;
  userAgents: string[];
  viewports: Array<{ width: number; height: number }>;
  proxyServer?: string;
  proxyUsername?: string;
  proxyPassword?: string;
}

// Property data structure matching database schema
export interface PropertyData {
  propertyId: string;
  name: string;
  propType: string;
  city: string | null;
  propertyAddress: string;
  assessedValue: number;
  appraisedValue: number;
  geoId: string | null;
  description: string | null;
}

// API request/response types
export interface ScrapeRequest {
  searchTerm: string;
  userId?: string;
}

export interface ScrapeResponse {
  jobId: string;
  message: string;
}

export interface JobStatus {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultCount?: number;
  error?: string;
  data?: PropertyData[];
  createdAt: Date;
  completedAt?: Date;
}

// Queue job data types
export interface ScrapeJobData {
  searchTerm: string;
  userId?: string;
  scheduled?: boolean;
}

export interface ScrapeJobResult {
  count: number;
  properties: PropertyData[];
  searchTerm: string;
  duration: number;
}
</file>

<file path="property.types.ts">
/**
 * TCAD Property Type Definitions with Schema.org Alignment
 *
 * This file provides TypeScript interfaces that align with Schema.org vocabulary
 * for maximum SEO value and semantic clarity. The types are designed to work
 * across frontend, backend, and provide excellent structured data for search engines.
 *
 * Schema.org Types Used:
 * - Place (https://schema.org/Place)
 * - RealEstateListing (https://schema.org/RealEstateListing)
 * - PropertyValue (https://schema.org/PropertyValue)
 * - PostalAddress (https://schema.org/PostalAddress)
 * - MonetaryAmount (https://schema.org/MonetaryAmount)
 * - GeoCoordinates (https://schema.org/GeoCoordinates)
 * - Organization (https://schema.org/Organization)
 * - Person (https://schema.org/Person)
 */

import { z } from 'zod';

// ============================================================================
// Database Level Types (Prisma/Backend)
// ============================================================================

/**
 * Database representation of a property matching Prisma schema
 * Maps to Schema.org: Place + RealEstateListing hybrid
 */
export interface PropertyDatabase {
  id: string;
  propertyId: string;           // TCAD unique identifier
  name: string;                 // Owner/taxpayer name
  propType: string;             // Property classification
  city: string | null;
  propertyAddress: string;
  assessedValue: number | null;  // Tax assessed value
  appraisedValue: number;        // Market appraised value
  geoId: string | null;          // Geographic identifier
  description: string | null;    // Legal description
  searchTerm: string | null;
  scrapedAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Property type enumeration based on common TCAD classifications
 * Maps to Schema.org: @type values for subtypes of Place/Residence
 */
export enum PropertyType {
  SINGLE_FAMILY = 'Single Family',
  CONDO = 'Condo',
  TOWNHOUSE = 'Townhouse',
  MULTI_FAMILY = 'Multi Family',
  COMMERCIAL = 'Commercial',
  INDUSTRIAL = 'Industrial',
  LAND = 'Land',
  AGRICULTURAL = 'Agricultural',
  MIXED_USE = 'Mixed Use'
}

// ============================================================================
// API Level Types (Frontend/API Response)
// ============================================================================

/**
 * API representation with Schema.org alignment
 * Enhanced with semantic annotations for structured data
 * Maps to Schema.org: RealEstateListing
 */
export interface PropertyAPI {
  // Core identification
  '@context'?: 'https://schema.org';
  '@type'?: 'RealEstateListing' | 'Place' | 'Residence';
  '@id'?: string;               // Unique URI for this property

  id: string;
  propertyId: string;           // Schema.org: identifier

  // Ownership (Schema.org: seller/owner)
  owner: PropertyOwner;

  // Property details (Schema.org: name, description)
  propertyType: string;         // Schema.org: additionalType
  legalDescription?: string;    // Schema.org: description

  // Location (Schema.org: address, geo)
  address: PropertyAddress;
  geography?: PropertyGeography;

  // Valuation (Schema.org: offers/priceSpecification)
  valuation: PropertyValuation;

  // Metadata
  metadata: PropertyMetadata;
}

/**
 * Property owner information
 * Maps to Schema.org: Person or Organization
 */
export interface PropertyOwner {
  '@type'?: 'Person' | 'Organization';
  name: string;                 // Schema.org: name
  type?: 'individual' | 'entity'; // Determines Person vs Organization
}

/**
 * Property address with full Schema.org PostalAddress alignment
 */
export interface PropertyAddress {
  '@type'?: 'PostalAddress';
  streetAddress: string;        // Schema.org: streetAddress
  addressLocality?: string;     // Schema.org: addressLocality (city)
  addressRegion: string;        // Schema.org: addressRegion (state)
  addressCountry: string;       // Schema.org: addressCountry
  postalCode?: string;          // Schema.org: postalCode

  // Formatted versions
  formatted: string;            // Full formatted address
  shortFormat?: string;         // Abbreviated format for display
}

/**
 * Geographic information for the property
 * Maps to Schema.org: GeoCoordinates + geo properties
 */
export interface PropertyGeography {
  '@type'?: 'GeoCoordinates';
  geoId?: string;               // TCAD geographic identifier
  latitude?: number;            // Schema.org: latitude
  longitude?: number;           // Schema.org: longitude
  elevation?: number;           // Schema.org: elevation

  // Additional geographic context
  neighborhood?: string;        // Schema.org: containedInPlace
  schoolDistrict?: string;
  taxDistrict?: string;
  censusTract?: string;
}

/**
 * Property valuation information
 * Maps to Schema.org: PriceSpecification / PropertyValue
 */
export interface PropertyValuation {
  '@type'?: 'PropertyValue';

  // Assessed value for tax purposes
  assessedValue?: MonetaryAmount;

  // Market appraisal value
  appraisedValue: MonetaryAmount;

  // Additional valuation details
  landValue?: MonetaryAmount;
  improvementValue?: MonetaryAmount;

  // Tax information
  taxableValue?: MonetaryAmount;
  exemptions?: TaxExemption[];

  // Valuation metadata
  valuationDate?: string;       // ISO 8601 date
  valuationMethod?: string;
}

/**
 * Monetary amount with currency
 * Maps to Schema.org: MonetaryAmount
 */
export interface MonetaryAmount {
  '@type'?: 'MonetaryAmount';
  value: number;                // Schema.org: value
  currency: string;             // Schema.org: currency (e.g., "USD")

  // Display helpers
  formatted?: string;           // e.g., "$450,000"
  abbreviated?: string;         // e.g., "$450K"
}

/**
 * Tax exemption information
 */
export interface TaxExemption {
  type: string;                 // e.g., "Homestead", "Senior", "Veteran"
  amount: MonetaryAmount;
  percentage?: number;          // If percentage-based exemption
}

/**
 * Property metadata for tracking and management
 */
export interface PropertyMetadata {
  searchTerm?: string;          // Search term that found this property
  dataSource: string;           // e.g., "TCAD"
  scrapedAt: string;           // ISO 8601 datetime
  createdAt: string;           // ISO 8601 datetime
  updatedAt: string;           // ISO 8601 datetime
  dataFreshness?: 'current' | 'stale' | 'historical';
  lastVerified?: string;        // ISO 8601 datetime
}

// ============================================================================
// Legacy Validation Schemas (Preserved for backward compatibility)
// ============================================================================

export const scrapeRequestSchema = z.object({
  searchTerm: z.string().min(4, 'Search term must be at least 4 characters').max(100),
  userId: z.string().optional(),
});

export const propertyFilterSchema = z.object({
  searchTerm: z.string().optional(),
  city: z.string().optional(),
  propType: z.string().optional(),
  minValue: z.coerce.number().optional(),
  maxValue: z.coerce.number().optional(),
  limit: z.coerce.number().min(1).max(1000).default(100),
  offset: z.coerce.number().min(0).default(0),
});

export const naturalLanguageSearchSchema = z.object({
  query: z.string().min(1),
  limit: z.number().min(1).max(1000).optional(),
  offset: z.number().min(0).optional(),
});

export const historyQuerySchema = z.object({
  limit: z.coerce.number().min(1).max(100).default(20),
  offset: z.coerce.number().min(0).default(0),
});

export const monitorRequestSchema = z.object({
  searchTerm: z.string().min(1),
  frequency: z.enum(['hourly', 'daily', 'weekly']).default('daily'),
});

// Legacy type exports
export type ScrapeRequestBody = z.infer<typeof scrapeRequestSchema>;
export type PropertyFilters = z.infer<typeof propertyFilterSchema>;
export type NaturalLanguageSearchBody = z.infer<typeof naturalLanguageSearchSchema>;
export type HistoryQueryParams = z.infer<typeof historyQuerySchema>;
export type MonitorRequestBody = z.infer<typeof monitorRequestSchema>;

// ============================================================================
// Enhanced Search and Filter Types
// ============================================================================

/**
 * Search parameters for querying properties
 */
export interface PropertySearchParams {
  query?: string;               // Full text search
  propertyTypes?: PropertyType[];
  cities?: string[];
  priceRange?: {
    min?: number;
    max?: number;
  };
  owner?: string;
  propertyId?: string;
  geoId?: string;

  // Pagination
  limit?: number;
  offset?: number;

  // Sorting
  sortBy?: 'appraisedValue' | 'assessedValue' | 'address' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

// ============================================================================
// Response Types
// ============================================================================

export interface PaginationMeta {
  total: number;
  limit: number;
  offset: number;
  hasMore: boolean;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: PaginationMeta;
}

/**
 * Paginated property response with Schema.org alignment
 */
export interface PaginatedPropertyResponse {
  '@context'?: 'https://schema.org';
  '@type'?: 'SearchResultsPage';

  results: PropertyAPI[];
  pagination: PaginationMeta;

  // Aggregations for filtering
  aggregations?: {
    propertyTypes: Array<{ type: string; count: number }>;
    cities: Array<{ city: string; count: number }>;
    priceRanges: Array<{ range: string; count: number }>;
  };
}

export interface JobStatusResponse {
  id: string;
  status: string;
  progress: number;
  resultCount?: number;
  error?: string | null;
  createdAt: Date;
  completedAt: Date | null;
}

export interface StatsResponse {
  totalProperties: number;
  totalJobs: number;
  recentJobs: number;
  cityDistribution: Array<{
    city: string;
    _count: number;
  }>;
  propertyTypeDistribution: Array<{
    propType: string;
    _count: number;
    _avg: {
      appraisedValue: number | null;
    };
  }>;
}

// ============================================================================
// Transformation Utilities
// ============================================================================

/**
 * Transform database property to API format with Schema.org alignment
 */
export function transformPropertyToAPI(
  dbProperty: PropertyDatabase,
  includeSchemaContext = true
): PropertyAPI {
  const [streetAddress, ...addressParts] = dbProperty.propertyAddress.split(',').map(s => s.trim());

  return {
    ...(includeSchemaContext && {
      '@context': 'https://schema.org',
      '@type': getSchemaType(dbProperty.propType),
      '@id': `/properties/${dbProperty.propertyId}`
    }),

    id: dbProperty.id,
    propertyId: dbProperty.propertyId,

    owner: {
      '@type': dbProperty.name.includes('LLC') || dbProperty.name.includes('INC')
        ? 'Organization'
        : 'Person',
      name: dbProperty.name,
      type: dbProperty.name.includes('LLC') || dbProperty.name.includes('INC')
        ? 'entity'
        : 'individual'
    },

    propertyType: dbProperty.propType,
    legalDescription: dbProperty.description || undefined,

    address: {
      '@type': 'PostalAddress',
      streetAddress,
      addressLocality: dbProperty.city || 'Austin',
      addressRegion: 'TX',
      addressCountry: 'US',
      formatted: dbProperty.propertyAddress,
      shortFormat: `${streetAddress}, ${dbProperty.city || 'Austin'}`
    },

    geography: dbProperty.geoId ? {
      '@type': 'GeoCoordinates',
      geoId: dbProperty.geoId
    } : undefined,

    valuation: {
      '@type': 'PropertyValue',
      assessedValue: dbProperty.assessedValue ? {
        '@type': 'MonetaryAmount',
        value: dbProperty.assessedValue,
        currency: 'USD',
        formatted: formatCurrency(dbProperty.assessedValue)
      } : undefined,
      appraisedValue: {
        '@type': 'MonetaryAmount',
        value: dbProperty.appraisedValue,
        currency: 'USD',
        formatted: formatCurrency(dbProperty.appraisedValue)
      }
    },

    metadata: {
      searchTerm: dbProperty.searchTerm || undefined,
      dataSource: 'TCAD',
      scrapedAt: dbProperty.scrapedAt.toISOString(),
      createdAt: dbProperty.createdAt.toISOString(),
      updatedAt: dbProperty.updatedAt.toISOString(),
      dataFreshness: getDataFreshness(dbProperty.scrapedAt)
    }
  };
}

/**
 * Get appropriate Schema.org type based on property type
 */
function getSchemaType(propType: string): 'RealEstateListing' | 'Place' | 'Residence' {
  const commercialTypes = ['Commercial', 'Industrial', 'Mixed Use'];
  const residentialTypes = ['Single Family', 'Condo', 'Townhouse', 'Multi Family'];

  if (commercialTypes.includes(propType)) {
    return 'Place';
  } else if (residentialTypes.includes(propType)) {
    return 'Residence';
  }
  return 'RealEstateListing';
}

/**
 * Format currency for display
 */
function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(value);
}

/**
 * Determine data freshness based on scrape date
 */
function getDataFreshness(scrapedAt: Date): 'current' | 'stale' | 'historical' {
  const daysSinceUpdate = (Date.now() - scrapedAt.getTime()) / (1000 * 60 * 60 * 24);

  if (daysSinceUpdate < 7) return 'current';
  if (daysSinceUpdate < 30) return 'stale';
  return 'historical';
}

// ============================================================================
// Type Guards
// ============================================================================

export function isPropertyDatabase(obj: any): obj is PropertyDatabase {
  return obj &&
    typeof obj.propertyId === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.propType === 'string' &&
    typeof obj.propertyAddress === 'string' &&
    typeof obj.appraisedValue === 'number';
}

export function isPropertyAPI(obj: any): obj is PropertyAPI {
  return obj &&
    typeof obj.propertyId === 'string' &&
    obj.owner &&
    obj.address &&
    obj.valuation;
}
</file>

<file path="README_ENHANCED.md">
# types

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "types",
  "description": "Directory containing 2 code files with 21 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "21 class definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Files and Schemas

### `index.ts` (typescript)

**Classes:**
- `ScraperConfig` - Line 1
- `PropertyData` - Line 14
- `ScrapeRequest` - Line 27
- `ScrapeResponse` - Line 32
- `JobStatus` - Line 37
- `ScrapeJobData` - Line 49
- `ScrapeJobResult` - Line 55

### `property.types.ts` (typescript)

**Classes:**
- `PropertyDatabase` - Line 28
- `PropertyAPI` - Line 70
- `PropertyOwner` - Line 101
- `PropertyAddress` - Line 110
- `PropertyGeography` - Line 127
- `PropertyValuation` - Line 145
- `MonetaryAmount` - Line 171
- `TaxExemption` - Line 184
- `PropertyMetadata` - Line 193
- `PropertySearchParams` - Line 252
- `PaginationMeta` - Line 277
- `PaginatedPropertyResponse` - Line 292
- `JobStatusResponse` - Line 307
- `StatsResponse` - Line 317

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# types

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `index.ts` (typescript)

**Classes:**
- `ScraperConfig` - Line 2
- `PropertyData` - Line 12
- `ScrapeRequest` - Line 25
- `ScrapeResponse` - Line 30
- `JobStatus` - Line 35
- `ScrapeJobData` - Line 47
- `ScrapeJobResult` - Line 53

---
*Generated by Schema Generator*
</file>

<file path="SCHEMA-DOCUMENTATION.md">
# TCAD Property Schema.org Type System Documentation

## Overview

This document describes the comprehensive TypeScript type system designed for the Travis County Appraisal District (TCAD) property scraper application. The type system aligns with Schema.org vocabulary to provide maximum SEO value and semantic clarity.

## Architecture

### Three-Layer Type System

1. **Database Layer** (`PropertyDatabase`) - Matches Prisma schema exactly
2. **API Layer** (`PropertyAPI`) - Enhanced with Schema.org properties
3. **Presentation Layer** (JSON-LD) - Full Schema.org structured data

## Schema.org Type Mapping

### Primary Schema.org Types Used

| TCAD Property Type | Schema.org Type | Use Case |
|-------------------|-----------------|----------|
| Single Family | `Residence` | Residential homes |
| Condo | `Residence` | Condominiums |
| Townhouse | `Residence` | Townhomes |
| Multi Family | `Residence` | Apartments/Duplexes |
| Commercial | `Place` | Business properties |
| Industrial | `Place` | Industrial facilities |
| Land | `RealEstateListing` | Vacant land |
| Agricultural | `Place` | Farms/Ranches |
| Mixed Use | `Place` | Mixed-use buildings |

### Property Components Schema Mapping

| Component | Schema.org Type | Properties |
|-----------|-----------------|------------|
| Address | `PostalAddress` | streetAddress, addressLocality, addressRegion, postalCode |
| Location | `GeoCoordinates` | latitude, longitude, elevation |
| Owner | `Person` / `Organization` | name, type |
| Valuation | `PropertyValue` / `MonetaryAmount` | value, currency |
| Tax Info | `PriceSpecification` | price, name, description |

## Type Definitions

### Core Types

```typescript
// Database representation (Prisma)
PropertyDatabase

// API representation (Frontend/Backend)
PropertyAPI

// Search/Filter types
PropertySearchParams
PaginatedPropertyResponse

// Supporting types
PropertyOwner
PropertyAddress
PropertyGeography
PropertyValuation
MonetaryAmount
TaxExemption
```

## Implementation Examples

### 1. Transform Database to API Format

```typescript
import { transformPropertyToAPI } from './types/property.types';

const dbProperty = await prisma.property.findUnique({
  where: { propertyId: 'TCAD-123456' }
});

const apiProperty = transformPropertyToAPI(dbProperty);
```

### 2. Generate JSON-LD for SEO

```typescript
import { generatePropertyJsonLd } from './utils/json-ld.utils';

const jsonLd = generatePropertyJsonLd(
  apiProperty,
  'Travis County Appraisal District',
  'https://example.com'
);

// Inject into HTML
const script = `<script type="application/ld+json">
${JSON.stringify(jsonLd, null, 2)}
</script>`;
```

### 3. API Response with Schema.org

```typescript
app.get('/api/properties/:id', async (req, res) => {
  const property = await getProperty(req.params.id);
  const apiProperty = transformPropertyToAPI(property);

  res.json({
    '@context': 'https://schema.org',
    ...apiProperty
  });
});
```

### 4. Property Listing Page

```typescript
app.get('/api/properties', async (req, res) => {
  const properties = await searchProperties(req.query);

  const response: PaginatedPropertyResponse = {
    '@context': 'https://schema.org',
    '@type': 'SearchResultsPage',
    results: properties.map(p => transformPropertyToAPI(p)),
    pagination: {
      total: totalCount,
      limit: 20,
      offset: 0,
      hasMore: true
    }
  };

  res.json(response);
});
```

## SEO Benefits

### Rich Results Eligibility

The Schema.org implementation enables:

1. **Property Rich Cards** - Enhanced search results with images, prices, and details
2. **Breadcrumb Navigation** - Clear site hierarchy in search results
3. **Site Search Box** - Direct search from Google results
4. **Knowledge Graph** - Entity recognition for properties and locations
5. **Local Search** - Enhanced local business/property listings

### Structured Data Features

- **Price Range Display** - Shows min/max prices in search results
- **Location Mapping** - Geographic coordinates for map integration
- **Owner Information** - Clear entity attribution
- **Tax Information** - Detailed financial breakdowns
- **Property Classifications** - Clear categorization for filtering

## JSON-LD Examples

### Individual Property

```json
{
  "@context": "https://schema.org",
  "@type": "RealEstateListing",
  "@id": "https://example.com/properties/TCAD-123456",
  "identifier": "TCAD-123456",
  "name": "123 Main St, Austin TX",
  "address": {
    "@type": "PostalAddress",
    "streetAddress": "123 Main St",
    "addressLocality": "Austin",
    "addressRegion": "TX",
    "addressCountry": "US",
    "postalCode": "78701"
  },
  "offers": {
    "@type": "Offer",
    "price": 450000,
    "priceCurrency": "USD"
  }
}
```

### Property Collection

```json
{
  "@context": "https://schema.org",
  "@type": "ItemList",
  "name": "Austin Properties",
  "numberOfItems": 100,
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "item": {
        "@type": "RealEstateListing",
        "identifier": "TCAD-123456",
        "name": "123 Main St"
      }
    }
  ]
}
```

## Validation

### Schema.org Validation Tools

1. **Google Rich Results Test**: https://search.google.com/test/rich-results
2. **Schema.org Validator**: https://validator.schema.org/
3. **Google Search Console**: Monitor rich results performance

### TypeScript Type Validation

```typescript
import { isPropertyAPI, isPropertyDatabase } from './types/property.types';

// Runtime type guards
if (isPropertyAPI(data)) {
  // Safe to use as PropertyAPI
}

// Compile-time validation with Zod
import { propertyFilterSchema } from './types/property.types';

const filters = propertyFilterSchema.parse(req.query);
```

## Best Practices

### 1. Always Include Context

```typescript
// Good
const property: PropertyAPI = {
  '@context': 'https://schema.org',
  '@type': 'RealEstateListing',
  // ...
};

// Bad - missing context
const property = {
  propertyId: '123',
  // ...
};
```

### 2. Use Specific Schema Types

```typescript
// Good - specific type
'@type': 'Residence'  // for residential properties

// Bad - generic type
'@type': 'Thing'
```

### 3. Include All Recommended Properties

Essential properties for rich results:
- `name` - Property title
- `address` - Full postal address
- `offers.price` - Current value
- `geo` - Coordinates when available
- `image` - Property photos (when available)

### 4. Maintain Data Consistency

```typescript
// Ensure consistency between visible content and structured data
<h1>{property.address.formatted}</h1>  // Visible
"name": "123 Main St, Austin TX"       // Structured data matches
```

### 5. Update Timestamps

```typescript
metadata: {
  scrapedAt: new Date().toISOString(),
  dataFreshness: getDataFreshness(scrapedAt),
  lastVerified: new Date().toISOString()
}
```

## Migration Guide

### From Legacy Types to Schema.org Types

```typescript
// Legacy
interface OldProperty {
  property_id: string;
  owner_name: string;
  value: number;
}

// New Schema.org aligned
interface PropertyAPI {
  propertyId: string;
  owner: {
    '@type': 'Person',
    name: string;
  };
  valuation: {
    appraisedValue: {
      '@type': 'MonetaryAmount',
      value: number;
      currency: 'USD';
    };
  };
}
```

## Testing

### Unit Tests

```typescript
describe('Property Type Transformations', () => {
  it('should transform database property to API format', () => {
    const dbProperty: PropertyDatabase = mockDbProperty();
    const apiProperty = transformPropertyToAPI(dbProperty);

    expect(apiProperty['@context']).toBe('https://schema.org');
    expect(apiProperty['@type']).toMatch(/RealEstateListing|Residence|Place/);
    expect(apiProperty.address['@type']).toBe('PostalAddress');
  });
});
```

### Validation Tests

```typescript
describe('JSON-LD Validation', () => {
  it('should generate valid structured data', () => {
    const jsonLd = generatePropertyJsonLd(mockProperty);
    const errors = validateJsonLd(jsonLd);

    expect(errors).toHaveLength(0);
  });
});
```

## Performance Considerations

1. **Lazy Loading** - Include full Schema.org context only when needed
2. **Caching** - Cache transformed API responses
3. **Selective Fields** - Use `includeSchemaContext` parameter
4. **Batch Processing** - Transform multiple properties efficiently

## Future Enhancements

1. **Additional Schema Types**
   - `ApartmentComplex` for multi-family
   - `Office` for commercial properties
   - `Store` for retail properties

2. **Enhanced Geographic Data**
   - School district boundaries
   - Neighborhood polygons
   - Transit accessibility

3. **Historical Data**
   - `PriceSpecification` with date ranges
   - Value trend graphs
   - Tax history

4. **Images and Media**
   - `ImageObject` for property photos
   - `VideoObject` for virtual tours
   - `3DModel` for interactive views

## Resources

- [Schema.org Documentation](https://schema.org/)
- [Google Structured Data Guide](https://developers.google.com/search/docs/appearance/structured-data)
- [JSON-LD Specification](https://json-ld.org/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
</file>

</files>
