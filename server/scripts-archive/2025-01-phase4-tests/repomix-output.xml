This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
diagnose-page.ts
diagnose-pagination.ts
diagnose-results.ts
queue-test-searches.ts
README_ENHANCED.md
README.md
test-ag-grid-data.ts
test-api-scraper.ts
test-db-save.ts
test-direct-api-bypass.ts
test-fixed-scraper.ts
test-network-interception.ts
test-optimized-search.ts
test-pagesize-limits.ts
test-pagination.ts
test-selectors.ts
test-urls.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="diagnose-page.ts">
import { chromium } from 'playwright';

async function diagnosePage() {
  console.log('üîç Diagnosing TCAD page structure...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext({
    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  });

  const page = await context.newPage();

  try {
    console.log('üìÑ Loading staging URL...');
    await page.goto('https://stage.travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    console.log('‚úÖ Page loaded, waiting for React app to render...\n');

    // Wait for React to render content in the root div
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    console.log('‚úÖ React app rendered\n');

    // Get page title
    const title = await page.title();
    console.log(`üìå Page title: ${title}\n`);

    // Check for input fields
    const inputs = await page.$$('input');
    console.log(`üî¢ Found ${inputs.length} input elements\n`);

    // Get details about each input
    for (let i = 0; i < Math.min(inputs.length, 10); i++) {
      const input = inputs[i];
      const type = await input.getAttribute('type');
      const placeholder = await input.getAttribute('placeholder');
      const id = await input.getAttribute('id');
      const name = await input.getAttribute('name');
      const className = await input.getAttribute('class');

      console.log(`Input ${i + 1}:`);
      console.log(`  Type: ${type || 'none'}`);
      console.log(`  Placeholder: ${placeholder || 'none'}`);
      console.log(`  ID: ${id || 'none'}`);
      console.log(`  Name: ${name || 'none'}`);
      console.log(`  Class: ${className || 'none'}\n`);
    }

    // Save screenshot
    await page.screenshot({ path: '/home/aledlie/tcad-scraper/server/page-diagnostic.png', fullPage: true });
    console.log('üì∏ Screenshot saved to: /home/aledlie/tcad-scraper/server/page-diagnostic.png\n');

    // Save HTML
    const html = await page.content();
    const fs = require('fs');
    fs.writeFileSync('/home/aledlie/tcad-scraper/server/page-diagnostic.html', html);
    console.log('üíæ HTML saved to: /home/aledlie/tcad-scraper/server/page-diagnostic.html\n');

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await browser.close();
  }
}

diagnosePage();
</file>

<file path="diagnose-pagination.ts">
import { chromium } from 'playwright';

async function diagnosePagination() {
  console.log('üîç Diagnosing pagination elements...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    console.log('Loading TCAD search page...');
    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
    });

    // Wait for React
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    console.log('Page loaded, performing search...');

    // Search for a common name
    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'Smith', { delay: 100 });
    await page.press('#searchInput', 'Enter');
    await page.waitForTimeout(3000);

    // Wait for results
    await page.waitForFunction(
      () => {
        const hasGridCells = document.querySelector('[role="gridcell"]') !== null;
        const hasNoResults = document.querySelector('.ag-overlay-no-rows-center') !== null;
        return hasGridCells || hasNoResults;
      },
      { timeout: 15000 }
    );

    console.log('\n=== Checking Status Bar Elements ===');

    // Check various status bar selectors
    const statusBarInfo = await page.evaluate(() => {
      const selectors = [
        '.ag-status-bar-center',
        '.ag-status-name-value',
        '[ref="eName"]',
        '.ag-status-bar',
        '.ag-paging-row-summary-panel',
      ];

      const results: any = {};

      selectors.forEach(selector => {
        const el = document.querySelector(selector);
        results[selector] = {
          exists: !!el,
          text: el?.textContent?.trim() || null,
          innerHTML: el?.innerHTML || null,
        };
      });

      // Also get all elements with 'ag-status' or 'paging' in class name
      const allStatusElements = Array.from(document.querySelectorAll('[class*="ag-status"], [class*="paging"]'));
      results['allStatusElements'] = allStatusElements.map(el => ({
        tag: el.tagName,
        class: el.className,
        text: el.textContent?.trim(),
      }));

      return results;
    });

    console.log(JSON.stringify(statusBarInfo, null, 2));

    console.log('\n=== Checking Pagination Elements ===');

    const paginationInfo = await page.evaluate(() => {
      return {
        pageSize: {
          selector: document.querySelector('.ag-paging-page-size'),
          value: (document.querySelector('.ag-paging-page-size') as any)?.value,
          options: Array.from(document.querySelectorAll('.ag-paging-page-size option')).map((opt: any) => ({
            value: opt.value,
            text: opt.textContent?.trim(),
          })),
        },
        nextButton: {
          exists: !!document.querySelector('.ag-paging-button[ref="btNext"]'),
          disabled: document.querySelector('.ag-paging-button[ref="btNext"]')?.classList.contains('ag-disabled'),
        },
        prevButton: {
          exists: !!document.querySelector('.ag-paging-button[ref="btPrevious"]'),
          disabled: document.querySelector('.ag-paging-button[ref="btPrevious"]')?.classList.contains('ag-disabled'),
        },
      };
    });

    console.log(JSON.stringify(paginationInfo, null, 2));

    console.log('\n=== Taking Screenshot ===');
    await page.screenshot({
      path: '/home/aledlie/tcad-scraper/server/pagination-diagnostic.png',
      fullPage: true
    });
    console.log('Screenshot saved to: pagination-diagnostic.png');

    console.log('\n‚úÖ Diagnostic complete!');
    console.log('Keep browser open for 10 seconds to inspect...');
    await page.waitForTimeout(10000);

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await context.close();
    await browser.close();
  }
}

diagnosePagination();
</file>

<file path="diagnose-results.ts">
import { chromium } from 'playwright';

async function diagnoseResults() {
  console.log('üîç Diagnosing TCAD results grid structure...\n');

  const browser = await chromium.launch({
    headless: true, // Run in headless mode for server environment
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext({
    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    viewport: { width: 1920, height: 1080 },
  });

  const page = await context.newPage();

  try {
    console.log('üìÑ Loading staging URL...');
    await page.goto('https://stage.travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    console.log('‚úÖ Page loaded, waiting for React app to render...\n');

    // Wait for React to render content
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    console.log('‚úÖ React app rendered\n');

    // Wait for and fill the search input
    console.log('üîç Performing search for "Austin"...');
    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'Austin', { delay: 100 });
    await page.waitForTimeout(500);
    await page.press('#searchInput', 'Enter');

    console.log('‚è≥ Waiting for results...\n');

    // Wait a moment for any results to appear
    await page.waitForTimeout(5000);

    // Take screenshot before checking for results
    await page.screenshot({
      path: '/home/aledlie/tcad-scraper/server/after-search.png',
      fullPage: true
    });
    console.log('üì∏ Screenshot after search saved to: /home/aledlie/tcad-scraper/server/after-search.png\n');

    // Try to wait for results, but continue even if it times out
    try {
      await page.waitForSelector('[role="gridcell"]', {
        timeout: 10000,
        state: 'visible'
      });
      console.log('‚úÖ Results grid found!\n');
    } catch (error) {
      console.log('‚ö†Ô∏è  No gridcell found after 10 seconds, continuing with analysis...\n');
    }

    // Wait a bit for all results to render
    await page.waitForTimeout(2000);

    // Analyze the page structure
    const analysis = await page.evaluate(() => {
      const results: any = {
        gridcellCount: 0,
        rowsWithSpaceLabel: 0,
        allRows: 0,
        sampleRowHTML: '',
        columnHeaders: [] as string[],
        sampleCellAttributes: [] as any[],
        pageMessages: [] as string[],
        agGridElements: 0,
        bodyText: '',
      };

      // Check for any messages on the page (error messages, "no results", etc.)
      const possibleMessageSelectors = [
        '.ag-overlay-no-rows-center',
        '.no-results',
        '.error-message',
        '[role="alert"]',
        '.message',
      ];

      for (const selector of possibleMessageSelectors) {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          const text = el.textContent?.trim();
          if (text) results.pageMessages.push(text);
        });
      }

      // Check for AG Grid elements
      results.agGridElements = document.querySelectorAll('.ag-root').length;

      // Get visible body text (first 500 chars)
      results.bodyText = document.body.textContent?.trim().substring(0, 500) || '';

      // Count gridcells
      const gridcells = document.querySelectorAll('[role="gridcell"]');
      results.gridcellCount = gridcells.length;

      // Count rows with the SPACE label
      const rowsWithSpace = document.querySelectorAll('[aria-label="Press SPACE to select this row."][role="row"]');
      results.rowsWithSpaceLabel = rowsWithSpace.length;

      // Count all rows
      const allRows = document.querySelectorAll('[role="row"]');
      results.allRows = allRows.length;

      // Get first data row HTML
      if (rowsWithSpace.length > 0) {
        results.sampleRowHTML = rowsWithSpace[0].outerHTML.substring(0, 2000);
      }

      // Get column headers
      const headers = document.querySelectorAll('[role="columnheader"]');
      results.columnHeaders = Array.from(headers).map(h => h.textContent?.trim() || '');

      // Get sample cell attributes from first row
      if (rowsWithSpace.length > 0) {
        const firstRow = rowsWithSpace[0];
        const cells = firstRow.querySelectorAll('[role="gridcell"]');
        results.sampleCellAttributes = Array.from(cells).slice(0, 10).map(cell => ({
          colId: cell.getAttribute('col-id'),
          ariaColIndex: cell.getAttribute('aria-colindex'),
          textContent: cell.textContent?.trim(),
          className: cell.className,
        }));
      }

      return results;
    });

    console.log('üìä Results Analysis:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    console.log(`AG Grid elements: ${analysis.agGridElements}`);
    console.log(`Total gridcells found: ${analysis.gridcellCount}`);
    console.log(`Rows with "Press SPACE" label: ${analysis.rowsWithSpaceLabel}`);
    console.log(`Total rows: ${analysis.allRows}\n`);

    if (analysis.pageMessages.length > 0) {
      console.log('üì¢ Page Messages:');
      analysis.pageMessages.forEach(msg => console.log(`  - ${msg}`));
      console.log('');
    }

    if (analysis.bodyText) {
      console.log('üìÑ Body Text (first 500 chars):');
      console.log(analysis.bodyText);
      console.log('');
    }

    console.log('üìã Column Headers:');
    analysis.columnHeaders.forEach((header, i) => {
      console.log(`  ${i + 1}. ${header}`);
    });
    console.log('');

    console.log('üîç Sample Cell Attributes (first 10 cells of first row):');
    analysis.sampleCellAttributes.forEach((cell, i) => {
      console.log(`\nCell ${i + 1}:`);
      console.log(`  col-id: ${cell.colId || 'none'}`);
      console.log(`  aria-colindex: ${cell.ariaColIndex || 'none'}`);
      console.log(`  text: ${cell.textContent || 'empty'}`);
      console.log(`  class: ${cell.className || 'none'}`);
    });
    console.log('');

    // Save screenshot of results
    await page.screenshot({
      path: '/home/aledlie/tcad-scraper/server/results-diagnostic.png',
      fullPage: true
    });
    console.log('üì∏ Screenshot saved to: /home/aledlie/tcad-scraper/server/results-diagnostic.png\n');

    // Save HTML of results
    const html = await page.content();
    const fs = require('fs');
    fs.writeFileSync('/home/aledlie/tcad-scraper/server/results-diagnostic.html', html);
    console.log('üíæ HTML saved to: /home/aledlie/tcad-scraper/server/results-diagnostic.html\n');

    // Try to extract properties using current method
    console.log('üß™ Testing current extraction method...\n');
    const properties = await page.evaluate(() => {
      const rows = document.querySelectorAll('[aria-label="Press SPACE to select this row."][role="row"]');

      return Array.from(rows).map(row => {
        const extractText = (selector: string): string | null => {
          const element = row.querySelector(selector);
          return element?.textContent?.trim() || null;
        };

        const extractNumber = (selector: string): number => {
          const text = extractText(selector);
          if (!text) return 0;
          const cleaned = text.replace(/[$,]/g, '');
          return parseFloat(cleaned) || 0;
        };

        return {
          propertyId: extractText('[col-id="pid"]') || '',
          name: extractText('[col-id="name"]') || '',
          propType: extractText('[col-id="propType"]') || '',
          city: extractText('[col-id="city"]'),
          propertyAddress: extractText('[col-id="streetPrimary"]') || '',
          assessedValue: extractNumber('.assessedValue'),
          appraisedValue: extractNumber('[col-id="appraisedValue"]'),
          geoId: extractText('[col-id="geoID"]'),
          description: extractText('[col-id="legalDescription"]'),
        };
      }).filter(property => property.propertyAddress && property.propertyId);
    });

    console.log(`Current method extracted: ${properties.length} properties`);
    if (properties.length > 0) {
      console.log('\n‚úÖ Sample extracted property:');
      console.log(JSON.stringify(properties[0], null, 2));
    } else {
      console.log('\n‚ùå Current method extracted 0 properties');
    }

    console.log('\n‚úÖ Diagnostic complete!');

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await browser.close();
  }
}

diagnoseResults();
</file>

<file path="queue-test-searches.ts">
import Bull from 'bull';

async function queueTestSearches() {
  const queue = new Bull('scraper-queue', {
    redis: {
      host: 'localhost',
      port: 6379,
    },
  });

  console.log('üìã Queuing test searches...\n');

  const searchTerms = [
    'Austin',
    '78701',
    'dede', // Known to have 20 results
  ];

  for (const searchTerm of searchTerms) {
    await queue.add('scrape-properties', {
      searchTerm,
      timestamp: new Date().toISOString(),
    });
    console.log(`‚úÖ Queued: ${searchTerm}`);
  }

  const waiting = await queue.getWaitingCount();
  const active = await queue.getActiveCount();
  const completed = await queue.getCompletedCount();
  const failed = await queue.getFailedCount();

  console.log(`\nüìä Queue status:`);
  console.log(`   Waiting: ${waiting}`);
  console.log(`   Active: ${active}`);
  console.log(`   Completed: ${completed}`);
  console.log(`   Failed: ${failed}`);

  await queue.close();
  process.exit(0);
}

queueTestSearches();
</file>

<file path="README_ENHANCED.md">
# 2025-01-phase4-tests

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "2025-01-phase4-tests",
  "description": "Directory containing 15 code files with 1 classes and 14 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "1 class definitions",
    "14 function definitions"
  ]
}
</script>

## Overview

This directory contains 15 code file(s) with extracted schemas.

## Files and Schemas

### `diagnose-page.ts` (typescript)

**Functions:**
- `async diagnosePage()` - Line 2

### `diagnose-pagination.ts` (typescript)

**Functions:**
- `async diagnosePagination()` - Line 2

### `diagnose-results.ts` (typescript)

**Functions:**
- `async diagnoseResults()` - Line 2

### `queue-test-searches.ts` (typescript)

**Functions:**
- `async queueTestSearches()` - Line 2

### `test-ag-grid-data.ts` (typescript)

**Functions:**
- `async testAGGridData()` - Line 2

### `test-api-scraper.ts` (typescript)

**Functions:**
- `async testAPIScraper()` - Line 12

### `test-db-save.ts` (typescript)

**Functions:**
- `async testDatabaseSave()` - Line 13

### `test-direct-api-bypass.ts` (typescript)

**Functions:**
- `async testDirectAPIBypass()` - Line 11

### `test-fixed-scraper.ts` (typescript)

**Functions:**
- `async testFix()` - Line 2

### `test-network-interception.ts` (typescript)

**Functions:**
- `async testNetworkInterception()` - Line 7

### `test-optimized-search.ts` (typescript)

**Classes:**
- `SearchPatternGenerator` - Line 2

### `test-pagesize-limits.ts` (typescript)

**Functions:**
- `async testPageSizeLimits()` - Line 5

### `test-pagination.ts` (typescript)

**Functions:**
- `async testPagination()` - Line 2

### `test-selectors.ts` (typescript)

**Functions:**
- `async testSelectors()` - Line 2

### `test-urls.ts` (typescript)

**Functions:**
- `async testBothURLs()` - Line 2

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# Phase 4: Archived Test and Diagnostic Scripts

**Archive Date**: January 6, 2025
**Reason**: Obsolete, superseded by better implementations, or debugging completed

---

## What Was Archived

This directory contains 15 test and diagnostic scripts that were used during development but are no longer needed in active codebase. All scripts are preserved in git history and this archive for reference.

---

## Archived Diagnostic Scripts (3 files)

### diagnose-page.ts
- **Purpose**: Diagnosed page rendering and scraping issues
- **Status**: Pagination issue resolved, no longer needed
- **Date**: November 2024

### diagnose-pagination.ts
- **Purpose**: Debugged pagination controls and behavior
- **Status**: Pagination issue resolved, no longer needed
- **Date**: November 2024

### diagnose-results.ts
- **Purpose**: Debugged result extraction and parsing
- **Status**: Results extraction working correctly
- **Date**: November 2024

---

## Archived Test Scripts (12 files)

### test-ag-grid-data.ts
- **Purpose**: Tested AG Grid data extraction approach
- **Status**: AG Grid approach deprecated in favor of API scraping
- **Superseded By**: API-based scraping in lib/tcad-scraper.ts

### test-api-scraper.ts
- **Purpose**: Early testing of API scraping approach
- **Status**: API scraping now standard, implemented in lib/tcad-scraper.ts
- **Superseded By**: lib/tcad-scraper.ts (production implementation)

### test-db-save.ts
- **Purpose**: Tested database saving functionality
- **Status**: Database integration complete, proper tests in __tests__/
- **Superseded By**: __tests__/integration.test.ts

### test-direct-api-bypass.ts
- **Purpose**: Tested direct API access without browser
- **Status**: API method now standard approach
- **Superseded By**: Standard API scraping implementation

### test-fixed-scraper.ts
- **Purpose**: Testing of fixed/improved scraper version
- **Status**: Improvements integrated into main scraper
- **Superseded By**: lib/tcad-scraper.ts

### test-network-interception.ts
- **Purpose**: Debugging network requests and responses
- **Status**: Network issues resolved
- **Date**: November 2024

### test-optimized-search.ts
- **Purpose**: Testing search optimizations
- **Status**: Optimizations integrated into production
- **Superseded By**: lib/tcad-scraper.ts

### test-pagesize-limits.ts
- **Purpose**: Testing pagination and page size limits
- **Status**: Pagination issue resolved
- **Date**: November 2024

### test-pagination.ts
- **Purpose**: Testing pagination controls
- **Status**: Pagination working correctly
- **Date**: November 2024

### test-selectors.ts
- **Purpose**: Testing CSS selectors for scraping
- **Status**: Selectors finalized and working
- **Date**: November 2024

### test-urls.ts
- **Purpose**: Testing URL construction and navigation
- **Status**: URL handling working correctly
- **Date**: November 2024

### queue-test-searches.ts
- **Purpose**: One-off utility for queuing test searches
- **Status**: Superseded by CLI tools
- **Superseded By**: npm run queue add-terms

---

## Active Test Scripts (Still in src/scripts/)

These scripts are still actively used and referenced in package.json:

```
src/scripts/test-api-token-config.ts   - Token configuration testing
src/scripts/test-queue-job-flow.ts     - Queue flow testing
src/scripts/test-token-refresh.ts      - Token refresh testing
```

**Package.json scripts:**
```json
{
  "test:token-config": "tsx src/scripts/test-api-token-config.ts",
  "test:queue-flow": "tsx src/scripts/test-queue-job-flow.ts",
  "test:token-refresh": "tsx src/scripts/test-token-refresh.ts"
}
```

---

## Production Scripts (Still in src/scripts/)

### Core Scraping
```
batch-scrape.ts                    - Manual batch scraping utility
continuous-batch-scraper.ts        - Automated continuous scraper (PRODUCTION)
worker.ts                          - Queue worker (PRODUCTION)
```

### Entity-Specific Batches
```
enqueue-*-batch.ts                 - Various entity type batch queueing scripts
```

### Batch Variants
```
batch-scrape-100.ts                - Batch scraper with specific size
batch-scrape-comprehensive.ts      - Comprehensive batch scraping
```

---

## Why These Scripts Were Archived

### 1. **Debugging Complete**
Scripts like `diagnose-pagination.ts` and `test-pagesize-limits.ts` were created to solve specific bugs. Once fixed, these became obsolete.

### 2. **Better Implementations Available**
Scripts like `test-api-scraper.ts` were prototypes. The final implementation in `lib/tcad-scraper.ts` replaced them.

### 3. **Superseded by CLI Tools**
Scripts like `queue-test-searches.ts` are now better handled by the consolidated CLI tools:
```bash
npm run queue add-terms <file>
```

### 4. **Proper Tests Exist**
Test scripts like `test-db-save.ts` were exploratory. Proper integration tests now exist in `__tests__/`.

---

## Restoration Procedure

If you need to restore any of these scripts:

### From Archive
```bash
cp scripts-archive/2025-01-phase4-tests/<script-name>.ts src/scripts/
```

### From Git History
```bash
git checkout <commit-hash> -- server/src/scripts/<script-name>.ts
```

### Find Commit
```bash
git log --all --full-history -- "server/src/scripts/test-*.ts"
```

---

## Impact of Archiving

### Before
- 18 test/diagnostic scripts cluttering src/scripts/
- Unclear which scripts were active vs obsolete
- Mixed production and testing code
- Hard to find what you need

### After
- 3 active test scripts (clearly identified)
- 21 production scripts
- Clean separation of concerns
- Easy to navigate

---

## Related Changes

### Phase 2 (Script Consolidation)
- 38 utility scripts ‚Üí 4 CLI tools
- Located in: scripts-archive/2025-01-phase2-consolidation/

### Phase 3 (Type System)
- Shared types created
- Schema.org alignment

### Phase 4 (Test Cleanup) - This Archive
- 15 obsolete test/diagnostic scripts archived
- 1 duplicate Jest config removed
- Test structure clarified

---

## File List

**Total Archived**: 15 files

```
diagnose-page.ts
diagnose-pagination.ts
diagnose-results.ts
queue-test-searches.ts
test-ag-grid-data.ts
test-api-scraper.ts
test-db-save.ts
test-direct-api-bypass.ts
test-fixed-scraper.ts
test-network-interception.ts
test-optimized-search.ts
test-pagesize-limits.ts
test-pagination.ts
test-selectors.ts
test-urls.ts
```

---

**Archive Complete**: January 6, 2025
**Next Phase**: Ready for future refactoring phases if needed
</file>

<file path="test-ag-grid-data.ts">
import { chromium } from 'playwright';

async function testAGGridData() {
  console.log('üîç Testing AG Grid data extraction...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
    });

    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'Smith', { delay: 100 });
    await page.press('#searchInput', 'Enter');
    await page.waitForTimeout(3000);

    await page.waitForFunction(
      () => document.querySelector('[role="gridcell"]') !== null,
      { timeout: 15000 }
    );

    console.log('Results loaded, checking AG Grid data sources...\n');

    const dataInfo = await page.evaluate(() => {
      return {
        visibleRows: document.querySelectorAll('.ag-row').length,
        totalElements: document.querySelectorAll('[class*="ag-"]').length,
      };
    });

    console.log('Visible rows:', dataInfo.visibleRows);
    console.log('Grid APIs found:', dataInfo.gridAPIs.length);
    console.log('Data extracted:', dataInfo.dataFound);
    console.log('Total data items:', dataInfo.allData.length);

    if (dataInfo.allData.length > 0) {
      console.log('\n‚úÖ Found data! Sample:');
      console.log(JSON.stringify(dataInfo.allData.slice(0, 3), null, 2));
    } else {
      console.log('\n‚ùå Could not extract data from AG Grid internal model');
      console.log('Grid API locations found:', JSON.stringify(dataInfo.gridAPIs, null, 2));
    }

  } catch (error) {
    console.error('Error:', error);
  } finally {
    await context.close();
    await browser.close();
  }
}

testAGGridData();
</file>

<file path="test-api-scraper.ts">
import { TCADScraper } from '../lib/tcad-scraper';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.simple(),
  transports: [new winston.transports.Console()],
});

/**
 * Test the new API-based scraper with sample search terms
 */
async function testAPIScraper() {
  console.log('üß™ Testing New API-Based Scraper\n');
  console.log('=' .repeat(80) + '\n');

  const searchTerms = [
    'Smith',         // Common name - should have many results
    'Austin',        // City name - should have many results
    '1234 Lamar',    // Street address
    'Johnson LLC',   // Business name
    'Hyde Park',     // Neighborhood
  ];

  const scraper = new TCADScraper({ headless: true });

  try {
    await scraper.initialize();
    console.log('‚úÖ Scraper initialized\n');

    const results: Array<{
      searchTerm: string;
      count: number;
      duration: number;
      sample: any;
    }> = [];

    for (const searchTerm of searchTerms) {
      console.log(`\n${'‚îÄ'.repeat(80)}`);
      console.log(`Testing search term: "${searchTerm}"`);
      console.log('‚îÄ'.repeat(80));

      const startTime = Date.now();

      try {
        const properties = await scraper.scrapePropertiesViaAPI(searchTerm);
        const duration = Date.now() - startTime;

        console.log(`‚úÖ Found ${properties.length} properties in ${(duration / 1000).toFixed(2)}s`);

        if (properties.length > 0) {
          const sample = properties[0];
          console.log('\nSample property:');
          console.log(`  Name: ${sample.name}`);
          console.log(`  Address: ${sample.propertyAddress}, ${sample.city || 'N/A'}`);
          console.log(`  Property ID: ${sample.propertyId}`);
          console.log(`  Appraised Value: $${sample.appraisedValue.toLocaleString()}`);
          console.log(`  Property Type: ${sample.propType}`);

          results.push({
            searchTerm,
            count: properties.length,
            duration,
            sample,
          });
        } else {
          console.log('  No properties found');
          results.push({
            searchTerm,
            count: 0,
            duration,
            sample: null,
          });
        }
      } catch (error) {
        console.error(`  ‚ùå Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
        results.push({
          searchTerm,
          count: -1, // Indicate error
          duration: Date.now() - startTime,
          sample: null,
        });
      }

      // Small delay between searches
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    // Summary
    console.log('\n\n' + '='.repeat(80));
    console.log('TEST SUMMARY');
    console.log('='.repeat(80) + '\n');

    console.log('Search Term          | Results | Time (s) | Status');
    console.log('-'.repeat(60));

    results.forEach(r => {
      const term = r.searchTerm.padEnd(20);
      const count = r.count === -1 ? 'ERROR'.padEnd(7) : r.count.toString().padEnd(7);
      const time = (r.duration / 1000).toFixed(2).padEnd(8);
      const status = r.count === -1 ? '‚ùå' : r.count > 0 ? '‚úÖ' : '‚ö†Ô∏è';
      console.log(`${term} | ${count} | ${time} | ${status}`);
    });

    const totalResults = results.reduce((sum, r) => sum + (r.count > 0 ? r.count : 0), 0);
    const avgTime = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    const successCount = results.filter(r => r.count >= 0).length;

    console.log('\n' + '‚îÄ'.repeat(60));
    console.log(`Total properties found: ${totalResults.toLocaleString()}`);
    console.log(`Average time per search: ${(avgTime / 1000).toFixed(2)}s`);
    console.log(`Success rate: ${successCount}/${results.length} (${((successCount/results.length)*100).toFixed(1)}%)`);

    // Compare with old method
    console.log('\n' + '='.repeat(80));
    console.log('COMPARISON WITH OLD METHOD');
    console.log('='.repeat(80) + '\n');

    const oldMethodResults = results.length * 20; // Old method: max 20 results per search
    const improvement = totalResults / oldMethodResults;

    console.log(`Old method (DOM scraping):  ~${oldMethodResults} properties (20 per search)`);
    console.log(`New method (API scraping):  ${totalResults} properties`);
    console.log(`Improvement:                ${improvement.toFixed(1)}x more results`);
    console.log(`\n‚úÖ API scraping method is ${improvement.toFixed(1)}x more effective!\n`);

  } catch (error) {
    console.error('‚ùå Fatal error:', error);
  } finally {
    await scraper.cleanup();
    console.log('Scraper cleaned up');
  }
}

testAPIScraper();
</file>

<file path="test-db-save.ts">
import { TCADScraper } from '../lib/tcad-scraper';
import { prisma } from '../lib/prisma';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.simple(),
  transports: [new winston.transports.Console()],
});

/**
 * Test scraping and saving to database with new schema
 */
async function testDatabaseSave() {
  console.log('üß™ Testing Database Save with New Schema\n');
  console.log('=' .repeat(80) + '\n');

  const searchTerm = 'Smith'; // Use a successful search term
  const scraper = new TCADScraper({ headless: true });

  try {
    await scraper.initialize();
    console.log('‚úÖ Scraper initialized\n');

    console.log(`Scraping properties for: "${searchTerm}"`);
    const properties = await scraper.scrapePropertiesViaAPI(searchTerm);
    console.log(`‚úÖ Found ${properties.length} properties\n`);

    if (properties.length === 0) {
      console.log('No properties to save');
      return;
    }

    // Save to database
    console.log('Saving properties to database...');
    let savedCount = 0;
    let updatedCount = 0;

    for (const property of properties) {
      try {
        const result = await prisma.property.upsert({
          where: { propertyId: property.propertyId },
          update: {
            name: property.name,
            propType: property.propType,
            city: property.city || null,
            propertyAddress: property.propertyAddress,
            assessedValue: property.assessedValue || null,
            appraisedValue: property.appraisedValue,
            geoId: property.geoId || null,
            description: property.description || null,
            searchTerm: searchTerm,
            scrapedAt: new Date(),
            updatedAt: new Date(),
          },
          create: {
            propertyId: property.propertyId,
            name: property.name,
            propType: property.propType,
            city: property.city || null,
            propertyAddress: property.propertyAddress,
            assessedValue: property.assessedValue || null,
            appraisedValue: property.appraisedValue,
            geoId: property.geoId || null,
            description: property.description || null,
            searchTerm: searchTerm,
            scrapedAt: new Date(),
          },
        });

        if (result.createdAt.getTime() === result.updatedAt.getTime()) {
          savedCount++;
        } else {
          updatedCount++;
        }
      } catch (error) {
        console.error(`Error saving property ${property.propertyId}:`, error);
      }
    }

    console.log(`‚úÖ Saved ${savedCount} new properties, updated ${updatedCount} existing`);

    // Verify data
    console.log('\n' + '‚îÄ'.repeat(80));
    console.log('VERIFICATION');
    console.log('‚îÄ'.repeat(80) + '\n');

    const totalInDb = await prisma.property.count();
    console.log(`Total properties in database: ${totalInDb}`);

    const sample = await prisma.property.findFirst({
      where: { searchTerm: searchTerm },
    });

    if (sample) {
      console.log('\nSample property from database:');
      console.log(`  Property ID: ${sample.propertyId}`);
      console.log(`  Name: ${sample.name}`);
      console.log(`  Address: ${sample.propertyAddress}`);
      console.log(`  City: ${sample.city || 'N/A'}`);
      console.log(`  Property Type: ${sample.propType}`);
      console.log(`  Appraised Value: $${sample.appraisedValue.toLocaleString()}`);
      console.log(`  Assessed Value: $${sample.assessedValue?.toLocaleString() || 'N/A'}`);
      console.log(`  Geo ID: ${sample.geoId || 'N/A'}`);
      console.log(`  Search Term: ${sample.searchTerm || 'N/A'}`);
      console.log(`  Scraped At: ${sample.scrapedAt.toISOString()}`);
      console.log(`  Created At: ${sample.createdAt.toISOString()}`);
    }

    console.log('\n‚úÖ Database schema verification PASSED!');
    console.log('All fields are saving correctly with proper data types.\n');

  } catch (error) {
    console.error('‚ùå Fatal error:', error);
  } finally {
    await scraper.cleanup();
    await prisma.$disconnect();
    console.log('Cleanup complete');
  }
}

testDatabaseSave();
</file>

<file path="test-direct-api-bypass.ts">
import { chromium } from 'playwright';

/**
 * PROOF OF CONCEPT: Direct API bypass for pagination limitation
 *
 * Instead of using the UI with its 20-result limit, we can:
 * 1. Get an auth token from the website
 * 2. Make direct HTTP POST requests to the API
 * 3. Use a larger pageSize (100, 500, or even 1000)
 * 4. Paginate through all results if needed
 */
async function testDirectAPIBypass() {
  console.log('üöÄ Testing Direct API Bypass for Pagination Limit\n');
  console.log('=' .repeat(80) + '\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    // Step 1: Get authentication token by performing a search
    console.log('Step 1: Loading page and waiting for authentication...');

    let authToken: string | null = null;

    // Capture the authorization token from network requests
    page.on('request', (request) => {
      const headers = request.headers();
      if (headers['authorization']) {
        authToken = headers['authorization'];
      }
    });

    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    // Wait for React to render
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    // Perform a quick search to trigger auth token usage
    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'test', { delay: 50 });
    await page.press('#searchInput', 'Enter');
    await page.waitForTimeout(3000);

    console.log(`Auth Token: ${authToken ? authToken.substring(0, 50) + '...' : 'Not found'}\n`);

    if (!authToken) {
      throw new Error('Could not capture authorization token');
    }

    // Step 2: Test direct API call with larger pageSize
    console.log('Step 2: Making direct API call with pageSize=100...\n');

    const response = await page.evaluate(async (token: string) => {
      // Make direct fetch request to the API
      const apiUrl = 'https://prod-container.trueprodigyapi.com/public/property/searchfulltext?page=1&pageSize=100';

      const requestBody = {
        pYear: { operator: '=', value: '2025' },
        fullTextSearch: { operator: 'match', value: 'Smith' }
      };

      const res = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': token,
        },
        body: JSON.stringify(requestBody)
      });

      if (!res.ok) {
        return {
          status: res.status,
          error: await res.text(),
        };
      }

      const data = await res.json();
      return {
        status: res.status,
        totalCount: data.totalProperty?.propertyCount,
        resultsReturned: data.results?.length,
        sampleResults: data.results?.slice(0, 3).map((r: any) => ({
          pid: r.pid,
          displayName: r.displayName,
          streetPrimary: r.streetPrimary,
          city: r.city,
          appraisedValue: r.appraisedValue,
        }))
      };
    }, authToken);

    console.log('API Response:');
    console.log(`- Status: ${response.status}`);
    console.log(`- Total properties matching search: ${response.totalCount}`);
    console.log(`- Results returned: ${response.resultsReturned}`);
    console.log(`\n‚úÖ SUCCESS! We got ${response.resultsReturned} results instead of 20!\n`);

    console.log('Sample results:');
    response.sampleResults?.forEach((result: any, i: number) => {
      console.log(`\n${i + 1}. ${result.displayName}`);
      console.log(`   PID: ${result.pid}`);
      console.log(`   Address: ${result.streetPrimary}, ${result.city}`);
      console.log(`   Appraised Value: $${result.appraisedValue?.toLocaleString()}`);
    });

    // Step 3: Calculate pagination needed for all results
    console.log('\n' + '='.repeat(80));
    console.log('PAGINATION ANALYSIS');
    console.log('='.repeat(80) + '\n');

    const totalCount = response.totalCount || 0;
    const pageSize = 100;
    const totalPages = Math.ceil(totalCount / pageSize);

    console.log(`Total properties: ${totalCount}`);
    console.log(`Page size: ${pageSize}`);
    console.log(`Total pages needed: ${totalPages}`);
    console.log(`\nTo get ALL results, we would need to make ${totalPages} API calls.`);

    // Step 4: Test getting multiple pages
    console.log('\n' + '='.repeat(80));
    console.log('TESTING MULTI-PAGE RETRIEVAL');
    console.log('='.repeat(80) + '\n');

    console.log('Fetching pages 1, 2, and 3...\n');

    const multiPageResults = await page.evaluate(async (token: string) => {
      const apiUrl = 'https://prod-container.trueprodigyapi.com/public/property/searchfulltext';
      const requestBody = {
        pYear: { operator: '=', value: '2025' },
        fullTextSearch: { operator: 'match', value: 'Smith' }
      };

      const allResults = [];
      for (let page = 1; page <= 3; page++) {
        const url = `${apiUrl}?page=${page}&pageSize=100`;
        const res = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': token,
          },
          body: JSON.stringify(requestBody)
        });
        const data = await res.json();
        allResults.push({
          page,
          count: data.results?.length || 0,
          firstPid: data.results?.[0]?.pid,
          lastPid: data.results?.[data.results.length - 1]?.pid,
        });
      }
      return allResults;
    }, authToken);

    multiPageResults.forEach((result: any) => {
      console.log(`Page ${result.page}: ${result.count} results (PID range: ${result.firstPid} - ${result.lastPid})`);
    });

    const totalFetched = multiPageResults.reduce((sum: number, r: any) => sum + r.count, 0);
    console.log(`\n‚úÖ Successfully fetched ${totalFetched} results across 3 pages!`);

    // Summary
    console.log('\n' + '='.repeat(80));
    console.log('SOLUTION SUMMARY');
    console.log('='.repeat(80) + '\n');

    console.log('üéØ WORKAROUND CONFIRMED!\n');
    console.log('Instead of scraping the UI with Playwright:');
    console.log('1. Navigate to the page once to get cookies/session');
    console.log('2. Use page.evaluate() to call fetch() directly');
    console.log('3. Set pageSize to 100-1000 (test to find max allowed)');
    console.log('4. Loop through pages to get all results');
    console.log('5. This bypasses the hidden AG Grid pagination completely!\n');

    console.log('Benefits:');
    console.log('‚úÖ No DOM parsing needed');
    console.log('‚úÖ Much faster (direct JSON response)');
    console.log('‚úÖ Can get 1000s of results per search term');
    console.log('‚úÖ More reliable (no UI element waiting)');
    console.log('‚úÖ Less resource intensive\n');

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await context.close();
    await browser.close();
  }
}

testDirectAPIBypass();
</file>

<file path="test-fixed-scraper.ts">
import { TCADScraper } from '../lib/tcad-scraper';

async function testFix() {
  console.log('üß™ Testing fixed scraper...\n');

  const scraper = new TCADScraper();

  try {
    await scraper.initialize();

    const searchTerm = 'dede';
    console.log(`Searching for: "${searchTerm}"`);

    const properties = await scraper.scrapeProperties(searchTerm, 1);

    console.log(`\n‚úÖ Found ${properties.length} properties!\n`);

    if (properties.length > 0) {
      console.log('Sample property:');
      console.log(JSON.stringify(properties[0], null, 2));
    }

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await scraper.cleanup();
  }
}

testFix();
</file>

<file path="test-network-interception.ts">
import { chromium } from 'playwright';

/**
 * Test script to intercept network requests and identify the backend API
 * that AG Grid uses to fetch property data. If we can identify the API endpoint,
 * we can bypass the 20-result pagination limit entirely.
 */
async function testNetworkInterception() {
  console.log('üîç Testing network interception to find backend API...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  // Array to store all network requests
  const apiRequests: Array<{
    url: string;
    method: string;
    postData?: string;
    response?: any;
  }> = [];

  // Intercept all network requests
  page.on('request', (request) => {
    const url = request.url();
    const method = request.method();

    // Look for API calls (not static assets)
    if (
      !url.includes('.js') &&
      !url.includes('.css') &&
      !url.includes('.png') &&
      !url.includes('.jpg') &&
      !url.includes('.svg') &&
      !url.includes('.woff') &&
      !url.includes('static/')
    ) {
      console.log(`üì§ REQUEST: ${method} ${url}`);

      const postData = request.postData();
      if (postData) {
        console.log(`   POST Data: ${postData.substring(0, 200)}...`);
      }

      apiRequests.push({
        url,
        method,
        postData: postData || undefined,
      });
    }
  });

  // Intercept all network responses
  page.on('response', async (response) => {
    const url = response.url();
    const status = response.status();

    // Look for API responses
    if (
      !url.includes('.js') &&
      !url.includes('.css') &&
      !url.includes('.png') &&
      !url.includes('.jpg') &&
      !url.includes('.svg') &&
      !url.includes('.woff') &&
      !url.includes('static/')
    ) {
      console.log(`üì• RESPONSE: ${status} ${url}`);

      try {
        // Try to get JSON response
        const contentType = response.headers()['content-type'];
        if (contentType && contentType.includes('application/json')) {
          const json = await response.json();
          console.log(`   Response preview: ${JSON.stringify(json).substring(0, 200)}...`);

          // Store response data
          const request = apiRequests.find(r => r.url === url);
          if (request) {
            request.response = json;
          }
        }
      } catch (error) {
        // Response might not be JSON
      }
    }
  });

  try {
    console.log('Loading TCAD search page...');
    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    // Wait for React
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    console.log('\nPage loaded, performing search...\n');

    // Search for a common term that will definitely return results
    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'Smith', { delay: 100 });
    await page.press('#searchInput', 'Enter');

    // Wait for results to load
    console.log('Waiting for search results...\n');
    await page.waitForTimeout(5000);

    // Wait for grid to populate
    await page.waitForFunction(
      () => {
        const hasGridCells = document.querySelector('[role="gridcell"]') !== null;
        const hasNoResults = document.querySelector('.ag-overlay-no-rows-center') !== null;
        return hasGridCells || hasNoResults;
      },
      { timeout: 15000 }
    );

    console.log('\n' + '='.repeat(80));
    console.log('NETWORK ANALYSIS COMPLETE');
    console.log('='.repeat(80) + '\n');

    console.log(`Total API requests captured: ${apiRequests.length}\n`);

    // Filter for potential data API endpoints
    const dataEndpoints = apiRequests.filter(req =>
      req.url.includes('api') ||
      req.url.includes('search') ||
      req.url.includes('property') ||
      req.url.includes('query') ||
      req.method === 'POST'
    );

    console.log('üéØ POTENTIAL DATA ENDPOINTS:\n');
    dataEndpoints.forEach((req, i) => {
      console.log(`${i + 1}. ${req.method} ${req.url}`);
      if (req.postData) {
        console.log(`   POST Data: ${req.postData}`);
      }
      if (req.response) {
        const responseStr = JSON.stringify(req.response);
        console.log(`   Response: ${responseStr.substring(0, 300)}...`);

        // Check if response contains property data
        if (
          responseStr.includes('propertyId') ||
          responseStr.includes('address') ||
          responseStr.includes('owner') ||
          responseStr.includes('assessed') ||
          responseStr.includes('appraised')
        ) {
          console.log('   ‚úÖ This looks like the property data endpoint!');
        }
      }
      console.log('');
    });

    // Check if we can extract the full dataset from the page's memory
    console.log('\n' + '='.repeat(80));
    console.log('CHECKING FOR DATA IN REACT STATE');
    console.log('='.repeat(80) + '\n');

    const reactStateData = await page.evaluate(() => {
      // Try to find React Fiber nodes
      const root = document.getElementById('root');
      if (!root) return null;

      // Try to access React internals
      const reactRoot = (root as any)._reactRootContainer || (root as any)._reactRootContainer;

      // Try to find data in various places
      const results = {
        windowKeys: Object.keys(window).filter(k =>
          k.toLowerCase().includes('data') ||
          k.toLowerCase().includes('property') ||
          k.toLowerCase().includes('grid')
        ),
        gridData: null as any,
      };

      // Look for AG Grid data
      try {
        const gridDivs = document.querySelectorAll('[class*="ag-"]');
        for (const div of gridDivs) {
          const gridApi = (div as any).__agComponent?.api;
          if (gridApi) {
            // Try to get all row data
            const allRows: any[] = [];
            gridApi.forEachNode((node: any) => allRows.push(node.data));
            results.gridData = {
              totalRows: allRows.length,
              sampleData: allRows.slice(0, 3),
              displayedRowCount: gridApi.getDisplayedRowCount?.(),
            };
            break;
          }
        }
      } catch (e) {
        // Ignore
      }

      return results;
    });

    console.log('Window object keys related to data:');
    console.log(reactStateData?.windowKeys || 'None found');
    console.log('\nAG Grid internal data:');
    console.log(JSON.stringify(reactStateData?.gridData, null, 2));

    // Save full report
    const report = {
      timestamp: new Date().toISOString(),
      totalRequests: apiRequests.length,
      dataEndpoints,
      reactState: reactStateData,
    };

    console.log('\n' + '='.repeat(80));
    console.log('SUMMARY');
    console.log('='.repeat(80));
    console.log('\nNext steps:');
    console.log('1. Review the potential data endpoints above');
    console.log('2. If an API endpoint is found, we can make direct HTTP requests');
    console.log('3. This would bypass the 20-result UI limitation completely');
    console.log('4. Look for pagination parameters in POST data (page, pageSize, offset, limit)');

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await context.close();
    await browser.close();
  }
}

testNetworkInterception();
</file>

<file path="test-optimized-search.ts">
// Quick test to show the optimized search term generation

class SearchPatternGenerator {
  private usedTerms = new Set<string>();
  private firstNames = ['James', 'Mary', 'John', 'Robert', 'Michael', 'William'];
  private lastNames = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia'];
  private streetNames = ['Main', 'Oak', 'Lamar', 'Congress', 'Guadalupe', 'Burnet'];
  private propertyTypes = ['Apartments', 'Condos', 'Townhomes', 'Office', 'Retail'];
  private businessSuffixes = ['LLC', 'Inc', 'Corp', 'Trust', 'Properties'];
  private neighborhoods = ['Hyde Park', 'Mueller', 'East Austin', 'Travis Heights'];
  private propertyDescriptors = ['Home', 'House', 'Property', 'Land'];

  getNextBatch(batchSize: number): string[] {
    const batch: string[] = [];
    const strategies = [
      { fn: () => this.generateFullName(), weight: 20 },
      { fn: () => this.generateLastNameOnly(), weight: 15 },
      { fn: () => this.generateStreetAddress(), weight: 18 },
      { fn: () => this.generateBusinessName(), weight: 12 },
      { fn: () => this.generateNeighborhood(), weight: 7 },
      { fn: () => this.generateCompoundName(), weight: 10 },
      { fn: () => this.generateStreetNumber(), weight: 12 },
    ];

    const weightedStrategies: (() => string)[] = [];
    strategies.forEach(s => {
      for (let i = 0; i < s.weight; i++) {
        weightedStrategies.push(s.fn);
      }
    });

    let attempts = 0;
    const maxAttempts = batchSize * 10;

    while (batch.length < batchSize && attempts < maxAttempts) {
      attempts++;
      const strategy = weightedStrategies[Math.floor(Math.random() * weightedStrategies.length)];
      const term = strategy();

      if (term && term.length >= 4 && !this.usedTerms.has(term)) {
        this.usedTerms.add(term);
        batch.push(term);
      }
    }

    return batch;
  }

  private generateFullName(): string {
    const first = this.firstNames[Math.floor(Math.random() * this.firstNames.length)];
    const last = this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
    return `${first} ${last}`;
  }

  private generateLastNameOnly(): string {
    return this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
  }

  private generateStreetAddress(): string {
    const number = Math.floor(Math.random() * 9999) + 1;
    const street = this.streetNames[Math.floor(Math.random() * this.streetNames.length)];
    return `${number} ${street}`;
  }

  private generateBusinessName(): string {
    const name = this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
    const suffix = this.businessSuffixes[Math.floor(Math.random() * this.businessSuffixes.length)];
    return `${name} ${suffix}`;
  }

  private generateNeighborhood(): string {
    return this.neighborhoods[Math.floor(Math.random() * this.neighborhoods.length)];
  }

  private generateCompoundName(): string {
    const last1 = this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
    const last2 = this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
    const patterns = [
      `${last1} & ${last2}`,
      `${last1} Family`,
      `${last1} Estate`,
      `${last1} Trust`,
    ];
    return patterns[Math.floor(Math.random() * patterns.length)];
  }

  private generateStreetNumber(): string {
    return (Math.floor(Math.random() * 9999) + 1).toString();
  }
}

console.log('üéØ Optimized Search Term Generation Test\n');

const generator = new SearchPatternGenerator();
const batch = generator.getNextBatch(20);

console.log(`Generated ${batch.length} diverse search terms:\n`);
batch.forEach((term, i) => {
  console.log(`${(i + 1).toString().padStart(2)}. ${term}`);
});

console.log('\n‚úÖ Key Improvements:');
console.log('  ‚Ä¢ Weighted strategies favor high-yield patterns');
console.log('  ‚Ä¢ Street addresses get 18% of searches (very high yield)');
console.log('  ‚Ä¢ Full names get 20% (high yield)');
console.log('  ‚Ä¢ Added compound names (Trusts, Families, Estates)');
console.log('  ‚Ä¢ Added neighborhood searches');
console.log('  ‚Ä¢ Added street number-only searches');
console.log('  ‚Ä¢ Expanded street names, property types, and business suffixes');
</file>

<file path="test-pagesize-limits.ts">
import { chromium } from 'playwright';

/**
 * Test to find the maximum allowed page size for the TCAD API
 */
async function testPageSizeLimits() {
  console.log('üß™ Testing API Page Size Limits\n');
  console.log('=' .repeat(80) + '\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    // Get auth token
    console.log('Step 1: Obtaining authentication token...');

    let authToken: string | null = null;

    page.on('request', (request) => {
      const headers = request.headers();
      if (headers['authorization']) {
        authToken = headers['authorization'];
      }
    });

    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'test', { delay: 50 });
    await page.press('#searchInput', 'Enter');
    await page.waitForTimeout(3000);

    if (!authToken) {
      throw new Error('Could not capture authorization token');
    }

    console.log('‚úÖ Auth token obtained\n');

    // Test different page sizes
    console.log('Step 2: Testing different page sizes...\n');

    const pageSizesToTest = [20, 50, 100, 200, 500, 1000, 2000, 5000];
    const results: Array<{
      pageSize: number;
      success: boolean;
      resultsReturned: number;
      totalAvailable: number;
      responseTime: number;
      error?: string;
    }> = [];

    for (const pageSize of pageSizesToTest) {
      console.log(`Testing pageSize=${pageSize}...`);

      const startTime = Date.now();
      const result = await page.evaluate(async ({ token, size }: { token: string; size: number }) => {
        try {
          const apiUrl = `https://prod-container.trueprodigyapi.com/public/property/searchfulltext?page=1&pageSize=${size}`;

          const requestBody = {
            pYear: { operator: '=', value: '2025' },
            fullTextSearch: { operator: 'match', value: 'Smith' }
          };

          const res = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'Authorization': token,
            },
            body: JSON.stringify(requestBody)
          });

          if (!res.ok) {
            return {
              success: false,
              error: `HTTP ${res.status}: ${await res.text()}`,
            };
          }

          const data = await res.json();
          return {
            success: true,
            resultsReturned: data.results?.length || 0,
            totalAvailable: data.totalProperty?.propertyCount || 0,
          };
        } catch (error: any) {
          return {
            success: false,
            error: error.message,
          };
        }
      }, { token: authToken, size: pageSize });

      const responseTime = Date.now() - startTime;

      results.push({
        pageSize,
        success: result.success,
        resultsReturned: result.resultsReturned || 0,
        totalAvailable: result.totalAvailable || 0,
        responseTime,
        error: result.error,
      });

      if (result.success) {
        console.log(`  ‚úÖ Success: Got ${result.resultsReturned} results in ${responseTime}ms`);
      } else {
        console.log(`  ‚ùå Failed: ${result.error}`);
      }

      // Small delay between requests
      await page.waitForTimeout(500);
    }

    // Summary
    console.log('\n' + '='.repeat(80));
    console.log('RESULTS SUMMARY');
    console.log('='.repeat(80) + '\n');

    console.log('PageSize | Success | Results | Time (ms) | Status');
    console.log('-'.repeat(60));
    results.forEach(r => {
      const status = r.success ? '‚úÖ' : '‚ùå';
      const results = r.success ? r.resultsReturned.toString().padEnd(7) : 'N/A'.padEnd(7);
      const time = r.responseTime.toString().padEnd(9);
      console.log(`${r.pageSize.toString().padEnd(8)} | ${status}      | ${results} | ${time} | ${r.error || 'OK'}`);
    });

    // Find optimal page size
    const successfulResults = results.filter(r => r.success);
    if (successfulResults.length > 0) {
      const maxPageSize = Math.max(...successfulResults.map(r => r.pageSize));
      const optimal = successfulResults.find(r => r.pageSize === maxPageSize);

      console.log('\n' + '='.repeat(80));
      console.log('RECOMMENDATION');
      console.log('='.repeat(80) + '\n');

      console.log(`‚úÖ Maximum supported page size: ${maxPageSize}`);
      console.log(`‚úÖ Results returned: ${optimal?.resultsReturned}`);
      console.log(`‚úÖ Response time: ${optimal?.responseTime}ms`);
      console.log(`\nRecommended page size for production: ${Math.min(maxPageSize, 1000)}`);
      console.log('(Balance between result count and response time)');
    }

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await context.close();
    await browser.close();
  }
}

testPageSizeLimits();
</file>

<file path="test-pagination.ts">
import { TCADScraper } from '../lib/tcad-scraper';

async function testPagination() {
  console.log('üß™ Testing pagination with search term that has many results...\n');

  const scraper = new TCADScraper();

  try {
    await scraper.initialize();

    // Use a common name that should return many results
    const searchTerm = 'Smith';
    console.log(`Searching for: "${searchTerm}" (should have many results)`);

    const properties = await scraper.scrapeProperties(searchTerm, 1);

    console.log(`\n‚úÖ Found ${properties.length} properties!\n`);

    if (properties.length > 0) {
      console.log('First 3 properties:');
      properties.slice(0, 3).forEach((prop, i) => {
        console.log(`\n${i + 1}. ${prop.name}`);
        console.log(`   Address: ${prop.propertyAddress}`);
        console.log(`   Property ID: ${prop.propertyId}`);
        console.log(`   Appraised Value: $${prop.appraisedValue.toLocaleString()}`);
      });

      if (properties.length > 20) {
        console.log(`\nüéâ Pagination worked! Got ${properties.length} properties (more than default 20)`);
      } else {
        console.log(`\n‚ö†Ô∏è Only got ${properties.length} properties (may not have triggered pagination)`);
      }
    }

  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await scraper.cleanup();
  }
}

testPagination();
</file>

<file path="test-selectors.ts">
import { chromium } from 'playwright';

async function testSelectors() {
  console.log('üîç Testing different row selectors on production...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const context = await browser.newContext({
    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
    viewport: { width: 1920, height: 1080 },
  });

  const page = await context.newPage();

  try {
    await page.goto('https://travis.prodigycad.com/property-search', {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    // Wait for React to render
    await page.waitForFunction(() => {
      const root = document.getElementById('root');
      return root && root.children.length > 0;
    }, { timeout: 15000 });

    // Perform search for "dede"
    await page.waitForSelector('#searchInput', { timeout: 10000 });
    await page.type('#searchInput', 'dede', { delay: 100 });
    await page.waitForTimeout(500);
    await page.press('#searchInput', 'Enter');

    // Wait for potential results
    await page.waitForTimeout(7000);

    // Test different row selectors
    const analysis = await page.evaluate(() => {
      const tests: any = {};

      // Test various selectors
      tests.spaceLabel = document.querySelectorAll('[aria-label="Press SPACE to select this row."][role="row"]').length;
      tests.roleRow = document.querySelectorAll('[role="row"]').length;
      tests.agRow = document.querySelectorAll('.ag-row').length;
      tests.agRowPosition = document.querySelectorAll('[row-index]').length;
      tests.gridcell = document.querySelectorAll('[role="gridcell"]').length;
      tests.noRowsOverlay = document.querySelectorAll('.ag-overlay-no-rows-wrapper').length;

      // Get sample row HTML for first ag-row
      const firstAgRow = document.querySelector('.ag-row');
      tests.firstAgRowHTML = firstAgRow ? firstAgRow.outerHTML.substring(0, 1000) : null;

      // Get sample cell data from first ag-row
      if (firstAgRow) {
        const cells = firstAgRow.querySelectorAll('[role="gridcell"]');
        tests.firstRowCells = Array.from(cells).slice(0, 5).map(cell => ({
          colId: cell.getAttribute('col-id'),
          text: cell.textContent?.trim(),
        }));
      }

      // Check if overlay is visible or hidden
      const overlay = document.querySelector('.ag-overlay-no-rows-wrapper') as HTMLElement;
      tests.overlayDisplay = overlay ? overlay.style.display : 'not found';

      return tests;
    });

    console.log('üìä Selector Test Results:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    console.log(`[aria-label="Press SPACE..."][role="row"]: ${analysis.spaceLabel}`);
    console.log(`[role="row"]: ${analysis.roleRow}`);
    console.log(`.ag-row: ${analysis.agRow}`);
    console.log(`[row-index]: ${analysis.agRowPosition}`);
    console.log(`[role="gridcell"]: ${analysis.gridcell}`);
    console.log(`No rows overlay elements: ${analysis.noRowsOverlay}`);
    console.log(`Overlay display style: ${analysis.overlayDisplay}\n`);

    if (analysis.firstRowCells && analysis.firstRowCells.length > 0) {
      console.log('‚úÖ Found data rows! First row sample cells:');
      analysis.firstRowCells.forEach((cell: any, i: number) => {
        console.log(`  Cell ${i + 1}:`);
        console.log(`    col-id: ${cell.colId || 'none'}`);
        console.log(`    text: ${cell.text || 'empty'}`);
      });
      console.log('');
    }

    if (analysis.firstAgRowHTML) {
      console.log('üìÑ First .ag-row HTML (first 1000 chars):');
      console.log(analysis.firstAgRowHTML);
      console.log('');
    }

  } catch (error: any) {
    console.error(`‚ùå Error: ${error.message}`);
  } finally {
    await context.close();
    await browser.close();
  }
}

testSelectors();
</file>

<file path="test-urls.ts">
import { chromium } from 'playwright';

async function testBothURLs() {
  console.log('üîç Testing STAGING vs PRODUCTION URLs...\n');

  const browser = await chromium.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  const searchTerm = 'dede';

  for (const env of ['staging', 'production']) {
    const url = env === 'staging'
      ? 'https://stage.travis.prodigycad.com/property-search'
      : 'https://travis.prodigycad.com/property-search';

    console.log(`\n${'='.repeat(60)}`);
    console.log(`Testing ${env.toUpperCase()}: ${url}`);
    console.log('='.repeat(60));

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      viewport: { width: 1920, height: 1080 },
    });

    const page = await context.newPage();

    try {
      await page.goto(url, {
        waitUntil: 'networkidle',
        timeout: 30000,
      });

      // Wait for React to render
      await page.waitForFunction(() => {
        const root = document.getElementById('root');
        return root && root.children.length > 0;
      }, { timeout: 15000 });

      // Perform search
      await page.waitForSelector('#searchInput', { timeout: 10000 });
      await page.type('#searchInput', searchTerm, { delay: 100 });
      await page.waitForTimeout(500);
      await page.press('#searchInput', 'Enter');

      // Wait for potential results
      await page.waitForTimeout(5000);

      // Analyze results
      const analysis = await page.evaluate(() => {
        const messages: string[] = [];
        const noRowsElement = document.querySelector('.ag-overlay-no-rows-center');
        if (noRowsElement) {
          messages.push(noRowsElement.textContent?.trim() || '');
        }

        const gridcells = document.querySelectorAll('[role="gridcell"]');
        const rows = document.querySelectorAll('[aria-label="Press SPACE to select this row."][role="row"]');

        return {
          hasNoRowsMessage: messages.length > 0,
          messages,
          gridcellCount: gridcells.length,
          rowCount: rows.length,
        };
      });

      console.log(`\nüìä Results for "${searchTerm}":`);
      console.log(`  Gridcells: ${analysis.gridcellCount}`);
      console.log(`  Rows: ${analysis.rowCount}`);

      if (analysis.hasNoRowsMessage) {
        console.log(`  ‚ùå Message: ${analysis.messages.join(', ')}`);
      } else if (analysis.rowCount > 0) {
        console.log(`  ‚úÖ Found ${analysis.rowCount} results!`);
      }

      // Take screenshot
      const screenshotPath = `/home/aledlie/tcad-scraper/server/${env}-results.png`;
      await page.screenshot({ path: screenshotPath, fullPage: true });
      console.log(`  üì∏ Screenshot: ${screenshotPath}`);

    } catch (error: any) {
      console.error(`  ‚ùå Error: ${error.message}`);
    } finally {
      await context.close();
    }
  }

  await browser.close();
  console.log('\n‚úÖ Test complete!');
}

testBothURLs();
</file>

</files>
