This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
README_ENHANCED.md
README.md
setup-test-db.sh
setup-test-db.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="README_ENHANCED.md">
# scripts

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "scripts",
  "description": "Directory containing 1 code files with 0 classes and 5 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "5 function definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `setup-test-db.ts` (typescript)

**Functions:**
- `log()` - Line 32
- `success()` - Line 37
- `error()` - Line 41
- `warning()` - Line 45
- `async main()` - Line 188

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="setup-test-db.sh">
#!/bin/bash

# Test Database Setup Script
# This script creates and configures the test database for CI/CD and local development

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
DB_NAME="${DATABASE_NAME:-tcad_scraper_test}"
DB_USER="${DATABASE_USER:-postgres}"
DB_PASSWORD="${DATABASE_PASSWORD:-postgres}"
DB_HOST="${DATABASE_HOST:-localhost}"
DB_PORT="${DATABASE_PORT:-5432}"
DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}"

echo -e "${GREEN}=== Test Database Setup ===${NC}"
echo "Database: $DB_NAME"
echo "User: $DB_USER"
echo "Host: $DB_HOST:$DB_PORT"
echo ""

# Function to check if PostgreSQL is running
check_postgres() {
    echo -e "${YELLOW}Checking PostgreSQL connection...${NC}"
    if PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -c '\q' 2>/dev/null; then
        echo -e "${GREEN}✓ PostgreSQL is running${NC}"
        return 0
    else
        echo -e "${RED}✗ Cannot connect to PostgreSQL${NC}"
        echo "Please ensure PostgreSQL is running:"
        echo "  - Docker: docker-compose up -d postgres"
        echo "  - System: sudo systemctl start postgresql"
        return 1
    fi
}

# Function to check if database exists
database_exists() {
    PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres \
        -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1
}

# Function to drop database if it exists
drop_database() {
    echo -e "${YELLOW}Dropping existing database '$DB_NAME'...${NC}"
    PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres \
        -c "DROP DATABASE IF EXISTS \"$DB_NAME\";"
    echo -e "${GREEN}✓ Database dropped${NC}"
}

# Function to create database
create_database() {
    echo -e "${YELLOW}Creating database '$DB_NAME'...${NC}"
    PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres \
        -c "CREATE DATABASE \"$DB_NAME\";"
    echo -e "${GREEN}✓ Database created${NC}"
}

# Function to run migrations
run_migrations() {
    echo -e "${YELLOW}Running Prisma migrations...${NC}"
    cd "$(dirname "$0")/.."
    DATABASE_URL="$DATABASE_URL" npx prisma migrate deploy
    echo -e "${GREEN}✓ Migrations applied${NC}"
}

# Function to verify database schema
verify_schema() {
    echo -e "${YELLOW}Verifying database schema...${NC}"

    # Check if main tables exist
    local tables=("properties" "scrape_jobs" "monitored_searches")
    for table in "${tables[@]}"; do
        if PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME \
            -tAc "SELECT 1 FROM information_schema.tables WHERE table_name='$table'" | grep -q 1; then
            echo -e "${GREEN}  ✓ Table '$table' exists${NC}"
        else
            echo -e "${RED}  ✗ Table '$table' missing${NC}"
            return 1
        fi
    done

    echo -e "${GREEN}✓ Schema verification passed${NC}"
}

# Function to seed test data (optional)
seed_test_data() {
    if [ "$SEED_DATA" = "true" ]; then
        echo -e "${YELLOW}Seeding test data...${NC}"
        PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME <<EOF
-- Insert test property
INSERT INTO properties (
    id, property_id, name, prop_type, city, property_address,
    appraised_value, scraped_at, created_at, updated_at
) VALUES (
    gen_random_uuid(),
    'TEST001',
    'Test Property Owner',
    'R',
    'AUSTIN',
    '123 Test St, Austin, TX 78701',
    500000,
    NOW(),
    NOW(),
    NOW()
) ON CONFLICT (property_id) DO NOTHING;
EOF
        echo -e "${GREEN}✓ Test data seeded${NC}"
    fi
}

# Function to display usage
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --drop        Drop existing database before creating"
    echo "  --seed        Seed database with test data"
    echo "  --verify-only Only verify schema, don't create/migrate"
    echo "  --help        Show this help message"
    echo ""
    echo "Environment variables:"
    echo "  DATABASE_NAME     (default: tcad_scraper_test)"
    echo "  DATABASE_USER     (default: postgres)"
    echo "  DATABASE_PASSWORD (default: postgres)"
    echo "  DATABASE_HOST     (default: localhost)"
    echo "  DATABASE_PORT     (default: 5432)"
}

# Parse command line arguments
DROP_EXISTING=false
SEED_DATA=false
VERIFY_ONLY=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --drop)
            DROP_EXISTING=true
            shift
            ;;
        --seed)
            SEED_DATA=true
            shift
            ;;
        --verify-only)
            VERIFY_ONLY=true
            shift
            ;;
        --help)
            show_usage
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    # Check if PostgreSQL is running
    if ! check_postgres; then
        exit 1
    fi

    if [ "$VERIFY_ONLY" = "true" ]; then
        # Just verify schema
        if database_exists; then
            verify_schema
        else
            echo -e "${RED}✗ Database '$DB_NAME' does not exist${NC}"
            exit 1
        fi
    else
        # Full setup
        if [ "$DROP_EXISTING" = "true" ] && database_exists; then
            drop_database
        fi

        # Create database if it doesn't exist
        if ! database_exists; then
            create_database
        else
            echo -e "${YELLOW}Database '$DB_NAME' already exists, skipping creation${NC}"
        fi

        # Run migrations
        run_migrations

        # Verify schema
        verify_schema

        # Seed test data if requested
        seed_test_data
    fi

    echo ""
    echo -e "${GREEN}=== Setup Complete ===${NC}"
    echo "Database URL: $DATABASE_URL"
    echo ""
    echo "To run tests with this database:"
    echo "  DATABASE_URL=\"$DATABASE_URL\" npm test"
    echo ""
    echo "To connect with psql:"
    echo "  PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME"
}

# Run main function
main
</file>

<file path="setup-test-db.ts">
#!/usr/bin/env tsx

/**
 * TCAD Scraper - Test Database Setup Script (Cross-platform Node.js version)
 * This script automates the setup of a local test database for development
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as readline from 'readline';

const execAsync = promisify(exec);

// Configuration
const config = {
  dbName: process.env.POSTGRES_DB || 'tcad_scraper_test',
  dbUser: process.env.POSTGRES_USER || 'postgres',
  dbPassword: process.env.POSTGRES_PASSWORD || 'postgres',
  dbHost: process.env.POSTGRES_HOST || 'localhost',
  dbPort: process.env.POSTGRES_PORT || '5432',
  redisHost: process.env.REDIS_HOST || 'localhost',
  redisPort: process.env.REDIS_PORT || '6379',
};

// Colors for output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  reset: '\x1b[0m',
};

function log(message: string, color?: keyof typeof colors) {
  const colorCode = color ? colors[color] : '';
  console.log(`${colorCode}${message}${colors.reset}`);
}

function success(message: string) {
  log(`✓ ${message}`, 'green');
}

function error(message: string) {
  log(`✗ ${message}`, 'red');
}

function warning(message: string) {
  log(`⚠ ${message}`, 'yellow');
}

async function checkCommand(command: string): Promise<boolean> {
  try {
    await execAsync(`${command} --version`);
    return true;
  } catch {
    return false;
  }
}

async function checkPostgres(): Promise<boolean> {
  process.stdout.write('Checking PostgreSQL connection... ');
  try {
    const cmd = process.platform === 'win32'
      ? `SET PGPASSWORD=${config.dbPassword} && psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -c "SELECT 1" > nul 2>&1`
      : `PGPASSWORD="${config.dbPassword}" psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -c "SELECT 1" > /dev/null 2>&1`;

    await execAsync(cmd);
    success('PostgreSQL is running');
    return true;
  } catch {
    error('PostgreSQL is not running');
    return false;
  }
}

async function checkRedis(): Promise<boolean> {
  process.stdout.write('Checking Redis connection... ');
  try {
    await execAsync(`redis-cli -h ${config.redisHost} -p ${config.redisPort} ping`);
    success('Redis is running');
    return true;
  } catch {
    error('Redis is not running');
    return false;
  }
}

async function createDatabase(): Promise<void> {
  process.stdout.write(`Checking if database '${config.dbName}' exists... `);

  try {
    // Check if database exists
    const checkCmd = process.platform === 'win32'
      ? `SET PGPASSWORD=${config.dbPassword} && psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -lqt`
      : `PGPASSWORD="${config.dbPassword}" psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -lqt`;

    const { stdout } = await execAsync(checkCmd);

    if (stdout.includes(config.dbName)) {
      warning('Database already exists');
      return;
    }

    // Create database
    console.log('Creating...');
    const createCmd = process.platform === 'win32'
      ? `SET PGPASSWORD=${config.dbPassword} && psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -c "CREATE DATABASE ${config.dbName};"`
      : `PGPASSWORD="${config.dbPassword}" psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -c "CREATE DATABASE ${config.dbName};"`;

    await execAsync(createCmd);
    success(`Database '${config.dbName}' created successfully`);
  } catch (err) {
    error(`Failed to create database: ${(err as Error).message}`);
    throw err;
  }
}

async function runMigrations(): Promise<void> {
  console.log('Running Prisma migrations...');
  const databaseUrl = `postgresql://${config.dbUser}:${config.dbPassword}@${config.dbHost}:${config.dbPort}/${config.dbName}`;

  process.env.DATABASE_URL = databaseUrl;

  try {
    // Generate Prisma Client
    process.stdout.write('Generating Prisma Client... ');
    await execAsync('npx prisma generate', {
      env: { ...process.env, DATABASE_URL: databaseUrl }
    });
    success('Done');

    // Run migrations
    process.stdout.write('Deploying migrations... ');
    await execAsync('npx prisma migrate deploy', {
      env: { ...process.env, DATABASE_URL: databaseUrl }
    });
    success('Done');
  } catch (err) {
    error(`Migration failed: ${(err as Error).message}`);
    throw err;
  }
}

async function verifySchema(): Promise<void> {
  process.stdout.write('Verifying database schema... ');

  try {
    const cmd = process.platform === 'win32'
      ? `SET PGPASSWORD=${config.dbPassword} && psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -d ${config.dbName} -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"`
      : `PGPASSWORD="${config.dbPassword}" psql -h ${config.dbHost} -p ${config.dbPort} -U ${config.dbUser} -d ${config.dbName} -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"`;

    const { stdout } = await execAsync(cmd);
    const tableCount = parseInt(stdout.trim(), 10);

    if (tableCount > 0) {
      success(`Found ${tableCount} tables`);
    } else {
      error('No tables found');
      throw new Error('Schema verification failed');
    }
  } catch (err) {
    error(`Schema verification failed: ${(err as Error).message}`);
    throw err;
  }
}

async function promptUser(question: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

async function seedTestData(): Promise<void> {
  const shouldSeed = await promptUser('Would you like to seed test data? (y/N): ');

  if (shouldSeed) {
    console.log('Seeding test data...');
    warning('Seed script not implemented yet');
  }
}

async function main() {
  console.log('==========================================');
  console.log('TCAD Scraper - Test Database Setup');
  console.log('==========================================');
  console.log('');

  console.log('Configuration:');
  console.log(`  Database: ${config.dbName}`);
  console.log(`  User: ${config.dbUser}`);
  console.log(`  Host: ${config.dbHost}:${config.dbPort}`);
  console.log(`  Redis: ${config.redisHost}:${config.redisPort}`);
  console.log('');

  try {
    // Check prerequisites
    const hasPsql = await checkCommand('psql');
    if (!hasPsql) {
      error('PostgreSQL client (psql) not found. Please install PostgreSQL.');
      process.exit(1);
    }

    const hasRedis = await checkCommand('redis-cli');
    if (!hasRedis) {
      warning('Redis CLI not found. Skipping Redis check.');
    } else {
      const redisRunning = await checkRedis();
      if (!redisRunning) {
        warning('Redis is not running. Tests may fail.');
        console.log('  To start Redis: redis-server');
      }
    }

    // Check PostgreSQL
    const postgresRunning = await checkPostgres();
    if (!postgresRunning) {
      console.log('');
      error('Cannot connect to PostgreSQL');
      console.log('');
      console.log('To start PostgreSQL:');
      console.log(`  - macOS (Homebrew): brew services start postgresql`);
      console.log(`  - Docker: docker run --name postgres -e POSTGRES_PASSWORD=${config.dbPassword} -p 5432:5432 -d postgres:16`);
      console.log(`  - Linux (systemd): sudo systemctl start postgresql`);
      console.log(`  - Windows: net start postgresql-x64-16`);
      console.log('');
      process.exit(1);
    }

    console.log('');

    // Create database
    await createDatabase();

    console.log('');

    // Run migrations
    await runMigrations();

    console.log('');

    // Verify schema
    await verifySchema();

    console.log('');

    // Optional: Seed data
    await seedTestData();

    console.log('');
    console.log('==========================================');
    success('Test database setup complete!');
    console.log('==========================================');
    console.log('');
    console.log(`Database URL: postgresql://${config.dbUser}:${config.dbPassword}@${config.dbHost}:${config.dbPort}/${config.dbName}`);
    console.log('');
    console.log('Next steps:');
    console.log('  1. Run tests: npm test');
    console.log('  2. Start dev server: npm run dev');
    console.log('  3. View database: npm run prisma:studio');
    console.log('');

    process.exit(0);
  } catch (err) {
    console.log('');
    error(`Setup failed: ${(err as Error).message}`);
    process.exit(1);
  }
}

// Run main function
main().catch((err) => {
  error(`Unexpected error: ${err.message}`);
  process.exit(1);
});
</file>

</files>
